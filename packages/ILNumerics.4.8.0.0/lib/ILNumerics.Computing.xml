<doc>
  <assembly>
    <name>ILNumerics.Computing</name>
  </assembly>
  <members>
    <member name="T:ILNumerics.ILSpecialData">
      <summary>
            A helper class that can be used to generate various simple yet non-trivial test data sets
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILMath">
      <summary>
            Main math class, exposes all static math functions. Users should write algorithms in a class derived from <c>ILMath</c>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.#cctor">
      <summary>
            Main math class providing static builtin functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Byte})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the Input Array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Double})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Single})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Magnitude of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Magnitude of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Magnitude of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Magnitude of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Int64})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Int32})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acosc(ILNumerics.ILInArray{System.Double})">
      <summary>
Arccosine of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acosc(ILNumerics.ILInArray{System.Single})">
      <summary>
Arccosine of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Arccosine values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Arccosine values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{System.Single})">
      <summary>
Arccosine of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{System.Double})">
      <summary>
Arccosine of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Double})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Int64})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Int32})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Byte})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Single})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(System.Func{System.Double,System.Double,System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply(System.Func{System.Single,System.Single,System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply(System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply(System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply(System.Func{System.Int64,System.Int64,System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply(System.Func{System.UInt32,System.UInt32,System.UInt32},ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply(System.Func{System.Int32,System.Int32,System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply(System.Func{System.Byte,System.Byte,System.Byte},ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,ILNumerics.ILSize)">
      <summary>
            Create new array, fill elements with constant value
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="value">Constant value for all elements</param>
      <param name="size">Size of new array</param>
      <returns>New array according to size with all elements set to 'value'</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int32[])">
      <summary>
            Create new array, fill element with constant value
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="value">Constant value for all elements</param>
      <param name="size">Size of new array</param>
      <returns>New array according to size with all elements set to 'value'</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[],System.Int32[])">
      <summary>
            Create array, given elements and size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">System.Array of predefined elements</param>
      <param name="size">Size of every dimension for the new array, must correspond to the number of elements in <paramref name="elements" />.</param>
      <returns>Newly created array</returns>
      <remarks>
        <para>The System.Array given as <paramref name="elements" />is taken 
            as storage for the new array without copy. Make sure not to reference that 
            System.Array directly afterwards.</para>
        <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[],ILNumerics.ILSize)">
      <summary>
            Create array, given elements and size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">System.Array of predefined elements</param>
      <param name="size">Size of the new array, must correspond to the number of elements in <paramref name="elements" />.</param>
      <returns>Newly created array</returns>
      <remarks>
        <para>The System.Array given as <paramref name="elements" />is taken 
            as storage for the new array without copy. Make sure not to reference that 
            System.Array directly afterwards.</para>
        <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool. 
            </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(ILNumerics.ILSize,``0[])">
      <summary>
            Create array, given elements and size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">Variable argument list with elements</param>
      <param name="size">Size of the new array, must correspond to the number of elements in <paramref name="elements" />.</param>
      <returns>Newly created array</returns>
      <remarks>
        <para>The elements given as <paramref name="elements" /> are used 
            for the new array without copy. For <typeparamref name="T" /> being a reference type, make sure not to reference any  
            elements directly afterwards.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[])">
      <summary>
            Create column vector from given elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">List of elements</param>
      <returns>Newly created vector with elements given</returns>
      <remarks>
        <para>If an System.Array was given as params argument, the array is directly taken 
            as storage for the new array without copy. Make sure not to reference the 
            System.Array directly afterwards!</para>
        <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool.</para>
        <para>The shape of the vector created is controlled by the setting switch <see cref="P:ILNumerics.Settings.CreateRowVectorsByDefault" />.
            This switch defaults to <c>false</c> which will cause the creation of a column vector. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.ILMath.row``1(``0[])" />
      <see cref="M:ILNumerics.ILMath.column``1(``0[])" />
    </member>
    <member name="M:ILNumerics.ILMath.row``1(``0[])">
      <summary>
            Create row vector
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">Elements of the row vector</param>
      <returns>New row vector</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.column``1(``0[])">
      <summary>
            Create column vector
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">Elements of the column vector</param>
      <returns>New column vector</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asinc(ILNumerics.ILInArray{System.Single})">
      <summary>
Arcsine of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asinc(ILNumerics.ILInArray{System.Double})">
      <summary>
Arcsine of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Arcsine values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Arcsine values of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{System.Single})">
      <summary>
Arcsine of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{System.Double})">
      <summary>
Arcsine of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Arctangent of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arctangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Arctangent of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arctangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{System.Single})">
      <summary>
Arctangent of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arctangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{System.Double})">
      <summary>
Arctangent of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arctangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan2(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Arcus tangens of elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise arcus tangens of both inputs</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.atan2(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Arcus tangens of elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise arcus tangens of both inputs</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Bitwise 'and' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'and' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Bitwise 'and' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'and' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Bitwise 'and' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'and' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitnot(ILNumerics.ILInArray{System.Int32})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitnot(ILNumerics.ILInArray{System.UInt32})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitnot(ILNumerics.ILInArray{System.Int64})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitnot(ILNumerics.ILInArray{System.UInt64})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitnot(ILNumerics.ILInArray{System.SByte})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitnot(ILNumerics.ILInArray{System.Byte})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Bitwise 'or' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'or' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Bitwise 'or' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'or' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Bitwise 'or' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'or' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Bitwise 'xor' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'xor' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Bitwise 'xor' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'xor' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Bitwise 'xor' of elements in A and B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'xor' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.cart2pol(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">X coordinates</param>
      <param name="Y">Y coordinates</param>
      <param name="Z">Z coordinates (height)</param>
      <param name="outRadius">[Output] Radius if not null on entry</param>
      <param name="outZ">[Output] Z if not null on entry</param>
      <returns>Angles; radius and Z are returned as output parameters, if on entry not null</returns>
      <remarks>Theta, radius and Z must be the same size or either one may be scalar. 
            Polar coordinate arrays returned are of the same size then the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cart2pol(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">X coordinates</param>
      <param name="Y">Y coordinates</param>
      <param name="Z">Z coordinates (height)</param>
      <param name="outRadius">[Output] Radius if not null on entry</param>
      <param name="outZ">[Output] Z if not null on entry</param>
      <returns>Angles; radius and Z are returned as output parameters, if on entry not null</returns>
      <remarks>Theta, radius and Z must be the same size or either one may be scalar. 
            Polar coordinate arrays returned are of the same size then the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ccomplex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create complex array from real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Array with real part elements</param>
      <param name="imag">Array with imaginary part elements</param>
      <returns>Complex array constructed out of real and imaginary parts</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same and neither of 
            the input is scalar.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ccomplex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Create complex array from real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Array with real part elements</param>
      <param name="imag">Array with imaginary part elements</param>
      <returns>Complex array constructed out of real and imaginary parts</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same and neither of 
            the input is scalar.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Round towards positive infinity
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded up to next integer value</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Round towards positive infinity
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded up to next integer value</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{System.Single})">
      <summary>
Round towards positive infinity
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded up to next integer value</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{System.Double})">
      <summary>
Round towards positive infinity
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded up to next integer value</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[])">
      <summary>
            Create a cell row vector from given arrays
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be copied inside the cell</param>
      <returns>Cell vector</returns>
      <remarks>
        <para>The new cell will be created as vector, having the array 'values' given as parameter as cell elements. Those elements will 
            be protected by changes from outside the cell.</para>
        <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>A common use of the <c>cell</c> function is the concatenation of arrays and constants for subarray definitions, as shown in the following example:</para>
        <code>
            ILArray&lt;double&gt; A = counter(4,3,2); 
            A
            //&lt;Double&gt; [4,3]
            // 1          5          9 
            // 2          6         10 
            // 3          7         11 
            // 4          8         12 
            
            // extract 1st, 2nd and last row:
            ILArray&lt;double&gt; B = A[cell(0,1,end),full]; 
            B
            //&lt;Double&gt; [3,3]
            // 1          5          9 
            // 2          6         10 
            // 4          8         12 
            </code>
        <para>Here, <c>cell</c> is used to concatenate individual indices determining the rows to select for the subarray. Using a cell here is convenient, because arbitrary types 
            can be stored in cells - integer, floating point types or special placeholders, like expressions (<see cref="P:ILNumerics.ILMath.end" /> and <see cref="P:ILNumerics.ILMath.full" />).</para>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILSize,ILNumerics.ILBaseArray[])">
      <summary>
            Create cell, initialize with arrays and size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">Size of the new cell</param>
      <param name="arrays">List of arrays for the cell elements, column major order</param>
      <returns>Cell of specified size, initialized with arrays</returns>
      <remarks>If number of arrays given is smaller than the number of elements given by <paramref name="size" />, trailing 
            elements in the cell returned will be set to null.
            <para>The <see cref="M:ILNumerics_ILMath_size(params int[])" /> function is convenient for the specification of size descriptors.</para><para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <example>
        <code>
            ILArray&lt;double&gt; A = rand(10,20,30); 
            ILCell C = cell(size(3,2),A, A+1, zeros(2,3)); 
            C
            //Cell [3,2]
            // &lt;Double&gt; [10,20,30]          &lt;String&gt;        4th element  
            // &lt;Double&gt; [10,20,30]                                 (null)
            // &lt;Double&gt; [2,3]                                      (null)
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[],System.Int32[])">
      <summary>
            Create cell, initialize with arrays and size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Predefined array with arrays, directly be used as new cell element storage</param>
      <param name="size">Size of newly created cell</param>
      <returns>Cell with size of <paramref name="size" /> and elements from <paramref name="arrays" /></returns>
      <remarks>The array given in <paramref name="arrays" /> is directly be used for the newly created cell. Make sure, not 
            to reference the system array afterwards. However, arrays  referenced from within the parameter <paramref name="arrays" /> 
            are stored as clone into the new cell. Therefore, those arrays are properly protected from changes by altering any array outside the cell.
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[])" />
    </member>
    <member name="M:ILNumerics.ILMath.checknull``1(ILNumerics.ILInArray{``0},System.Func{ILNumerics.ILRetArray{``0}})">
      <summary>
            Check if A is valid, assign default on null
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="A">Input parameter</param>
      <returns>Result of evaluation(A) or A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.check``1(ILNumerics.ILInArray{``0},System.Func{ILNumerics.ILInArray{``0},ILNumerics.ILRetArray{``0}},System.Boolean,System.String,ILNumerics.ILInArray{``0})">
      <summary>
            Check if A is a valid parameter
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="A">Input parameter</param>
      <param name="ErrorMessage">[optional] Exception message</param>
      <param name="evaluation">[optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
      <param name="allowNullInput">[optional] Only if A is null -&gt; for true: returns null, false: throws exception. If <paramref name="Default" /> was defined, this parameter is ignored.</param>
      <param name="Default">[optional] If <paramref name="A" /> is null on input, this value is returned. If no default is given (i.e: null), <paramref name="allowNullInput" /> is evaluated.</param>
      <returns>Result of evaluation(A) or A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput" /> is false</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.check(ILNumerics.ILInLogical,System.Func{ILNumerics.ILInLogical,ILNumerics.ILRetLogical},System.Boolean,System.String)">
      <summary>
            Check if A is a valid parameter
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input parameter</param>
      <param name="ErrorMessage">[optional] Exception message</param>
      <param name="evaluation">[optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
      <param name="allowNullInput">[optional] Only if A is null -&gt; for true: returns null, false: throws exception</param>
      <returns>Result of evaluation(A) or A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput" /> is false</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.check(ILNumerics.ILInCell,System.Func{ILNumerics.ILInCell,ILNumerics.ILRetCell},System.Boolean,System.String)">
      <summary>
            Check if A is a valid parameter
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input parameter</param>
      <param name="ErrorMessage">[Optional] Exception message</param>
      <param name="evaluation">[Optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
      <param name="allowNullInput">[Optional] Only if A is null -&gt; true: returns null, false: throws exception</param>
      <returns>Result of evaluation(A) or A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput" /> is false</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{System.Double},System.Boolean)">
      <summary>
Cholesky factorization
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br /> 
            The elements of A will not be altered.</param>
      <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
      <returns>Cholesky factorization</returns>
      <remarks>
        <para>If <paramref name="throwException" /> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. <para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{System.Single},System.Boolean)">
      <summary>
Cholesky factorization
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br /> 
            The elements of A will not be altered.</param>
      <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
      <returns>Cholesky factorization</returns>
      <remarks>
        <para>If <paramref name="throwException" /> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. <para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
Cholesky factorization
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br /> 
            The elements of A will not be altered.</param>
      <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
      <returns>Cholesky factorization</returns>
      <remarks>
        <para>If <paramref name="throwException" /> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. <para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{ILNumerics.complex},System.Boolean)">
      <summary>
Cholesky factorization
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br /> 
            The elements of A will not be altered.</param>
      <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
      <returns>Cholesky factorization</returns>
      <remarks>
        <para>If <paramref name="throwException" /> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. <para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{System.Double})">
      <summary>
            Complex conjugate of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>The array itself</returns>
      <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{System.Single})">
      <summary>
            Complex conjugate of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>The array itself</returns>
      <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Complex conjugate of array A
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex conjugate of array A</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Complex conjugate of array A
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex conjugate of array A</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.convert``2(ILNumerics.ILInArray{``0})">
      <summary>
            Convert a numeric array to another numeric type
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <typeparam name="inT">Type of array to convert</typeparam>
      <typeparam name="outT">Type of array to return</typeparam>
      <returns>Converted array</returns>
      <remarks> The newly created array will be converted to the required type. 
            <para>The array returned will always use new memory! Even if the type requested 
            matches the incoming type.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILBaseArray)">
      <summary>
            convert arbitrary numeric array to double array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>double array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to UInt64 array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>UInt64 (ulong) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to Int64 array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>Int64 (long) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to UInt32 array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>UInt32 (uint) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to Int32 array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>Int32 (int) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to Int16 array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>Int16 (short) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to byte array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>byte array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to fcomplex array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>fcomplex array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to complex array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>complex array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILBaseArray)">
      <summary>
Converts arbitrary numeric array to float array.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>Single (float) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Cosine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Cosine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{System.Single})">
      <summary>
Cosine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{System.Double})">
      <summary>
Cosine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Hyperbolic cosine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic cosine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{System.Single})">
      <summary>
Hyperbolic cosine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{System.Double})">
      <summary>
Hyperbolic cosine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(ILNumerics.ILBaseArray[])">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <returns>Double array with elements counting from 1 to dimensions.NumberOfElements</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Int32[])">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <returns>Double array with elements counting from 1 ... dimensions.NumberOfElements</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,ILNumerics.ILBaseArray[])">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <param name="start">Starting number</param>
      <param name="inc">Incrementing step</param>
      <returns>Double array with elements counting from start to start + (dimensions.NumberOfElements * inc)</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,ILNumerics.ILSize)">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <param name="start">Starting number</param>
      <param name="inc">Incrementing step</param>
      <returns>Double array with elements counting from start to start + (dimensions.NumberOfElements * inc)</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(ILNumerics.ILSize)">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <returns>Double array with elements counting from 1 ... dimensions.NumberOfElements</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray[])">
      <summary>
            Create n-dimensional array with counting elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Initial value</param>
      <param name="increment">Increment for each element</param>
      <param name="dimensions">Variable number of numeric, scalar arrays with dimension specification</param>
      <returns>Array with elements counting from <paramref name="start" /> along the first dimension with steps of <paramref name="increment" />.</returns>
      <remarks>
        <example>
          <code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // This will create an array with all elements having contant value of -4f:
            // (note: start, increment and dimension specifier do not need to be of the same type)
            <![CDATA[ILArray<float> A = ILMath.counter<float>(4.0,0,4,3,2);]]></code>
        </example>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILSize)">
      <summary>
            Create n-dimensional array with counting elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Initial value</param>
      <param name="increment">Increment for each element</param>
      <param name="dimensions">Variable int array with dimension specification</param>
      <returns>Array with elements counting from <paramref name="start" /> to dimensions.NumberOfElements - <paramref name="start" />.</returns>
      <remarks>
        <example>
          <code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // This will create an array with all elements having contant value of -4f:
            // (note: start, increment and dimension specifier do not need to be of the same type)
            <![CDATA[ILArray<float> A = ILMath.counter<float>(4.0,0,4,3,2);]]></code>
        </example>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cross(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Boolean)">
      <summary>
            Cross products of columns of two arrays
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">First array with vectors in columns</param>
      <param name="B">Second array with vectors in columns</param>
      <param name="normalize">If true: normalize resulting vectors to length 1.0.</param>
      <returns>Array with cross products of vectors from A and B</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cross(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Boolean)">
      <summary>
            Cross products of columns of two arrays
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">First array with vectors in columns</param>
      <param name="B">Second array with vectors in columns</param>
      <param name="normalize">If true: normalize resulting vectors to length 1.0.</param>
      <returns>Array with cross products of vectors from A and B</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.csvread``1(System.IO.Stream,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String,System.Globalization.CultureInfo,System.Text.Encoding)">
      <summary>
            Reads comma seperated values from stream, optionally using custom separators, element and number formats.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type to return.</typeparam>
      <param name="stream">Stream with CSV data in lines.</param>
      <param name="startRow">[optional] Start reading the values from that row. Default: 0.</param>
      <param name="startCol">[optional] Start reading values from that column. Default: 0.</param>
      <param name="endRow">[optional] Index of the last row to take into account. Default: last row in <paramref name="stream" />.</param>
      <param name="endCol">[optional] Index of the last column to take into account. Default: last column in <paramref name="stream" />.</param>
      <param name="elementConverter">[optional] Custom function to convert each element from its string representation. Default: parse as <see cref="T:System.Double" />.</param>
      <param name="elementSeparator">[optional] String seperating individual elements. Default: , (comma)</param>
      <param name="culture">[optional] Number format used while parsing individual elements. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[optional] Encoding used to read bytes from stream. Default: ASCII encoding.</param>
      <returns>Matrix with elements read from <paramref name="stream" />.</returns>
      <remarks>
        <para>The data lines in <paramref name="stream" /> are parsed using <paramref name="elementSeparator" /> as element 
            separator. Arbitrary element types <typeparamref name="T" /> can be parsed by providing a customized function 
            <paramref name="elementConverter" /> for parsing individual elements. The current threads culture is temporarily changed to use the 
            <see href="System.Globalization.NumberFormatInfo">number format info</see> provided in <paramref name="culture" />. The number 
            format provides the parser with info about decimal separators among others used to determine number formats for parsing.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.csvread``1(System.String,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String,System.Globalization.CultureInfo)">
      <summary>
            Reads comma seperated values from lines in a string, optionally using custom separators, element and number formats.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type to return.</typeparam>
      <param name="csvData">String with CSV data in lines.</param>
      <param name="startRow">[optional] Start reading the values from that row. Default: 0.</param>
      <param name="startCol">[optional] Start reading values from that column. Default: 0.</param>
      <param name="endRow">[optional] Index of the last row to take into account. Default: last row in <paramref name="csvData" />.</param>
      <param name="endCol">[optional] Index of the last column to take into account. Default: last column in <paramref name="csvData" />.</param>
      <param name="elementConverter">[optional] Custom function to convert each element from its string representation. Default: parse as <see cref="T:System.Double" />.</param>
      <param name="elementSeparator">[optional] String seperating individual elements. Default: , (comma)</param>
      <param name="culture">[optional] Number format used while parsing individual elements. Default: invariant culture (not current thread culture!)</param>
      <returns>Matrix with elements read from <paramref name="csvData" />.</returns>
      <remarks>
        <para>The data lines in <paramref name="csvData" /> is parsed using <paramref name="elementSeparator" /> as element 
            separator. Arbitrary element types <typeparamref name="T" /> can be parsed by providing a customized function 
            <paramref name="elementConverter" /> for parsing individual elements. The current threads culture is temporarily changed to use the 
            <see href="System.Globalization.NumberFormatInfo">number format info</see> provided in <paramref name="culture" />. The number 
            format provides the parser with info about decimal separators among others used to determine number formats for parsing.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.csvwrite``1(ILNumerics.ILInArray{``0},System.IO.Stream,System.Func{``0,System.String},System.String,System.Globalization.CultureInfo,System.Text.Encoding)">
      <summary>
            Write ILNumerics array as seperated strings to stream
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type of input array A</typeparam>
      <param name="A">ILNumerics array to write as CSV. This is expected to be a matrix.</param>
      <param name="stream">Stream to write values to.</param>
      <param name="elementConverter">[optional] Custom function used to convert elements of A to string. Default: [T].ToString()</param>
      <param name="elementSeparator">[optional] Character chain used to seperate individual elements. Default: ',' (comma).</param>
      <param name="culture">[optional] Number format info used to acquire formatting information for converting numbers to string. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[optional] Encoding used to write the string representation of individual elements to the bytes of the stream.</param>
      <remarks>
        <para>A is expected to be a matrix. If A has more than 2 dimensions trailing dimensions will be joined to the second dimension. This corresponds to: A[":;:"].</para>
        <para>The optional parameters <paramref name="elementConverter" />, <paramref name="elementSeparator" /> and <paramref name="culture" />
            are used to control the format of the resulting CSV result.<paramref name="elementConverter" /> is used to convert a single element of <paramref name="A" /> into its string representation, using the current cultures number format or the <see cref="T:System.Globalization.CultureInfo" /> provided by <paramref name="culture" />.</para>
        <para>Individual elements will be seperated in the CSV result by ',' (comma) or by the character chain provided by <paramref name="elementSeparator" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.csvwrite``1(ILNumerics.ILInArray{``0},System.String,System.Func{``0,System.String},System.String,System.Globalization.CultureInfo,System.Text.Encoding)">
      <summary>
            Write ILNumerics array as seperated strings to file
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type of input array A</typeparam>
      <param name="A">ILNumerics array to write as CSV. This is expected to be a matrix.</param>
      <param name="filename">Name of the file to write values to.</param>
      <param name="elementConverter">[optional] Custom function used to convert elements of A to string. Default: [T].ToString()</param>
      <param name="elementSeparator">[optional] Character chain used to seperate individual elements. Default: ',' (comma).</param>
      <param name="culture">[optional] Number format info used to acquire formatting information for converting numbers to string. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[optional] Encoding used to write the string representation of individual elements to the bytes of the file.</param>
      <remarks>
        <para>A is expected to be a matrix. If A has more than 2 dimensions trailing dimensions will be joined to the second dimension. This corresponds to: A[":;:"].</para>
        <para>The optional parameters <paramref name="elementConverter" />, <paramref name="elementSeparator" /> and <paramref name="culture" />
            are used to control the format of the resulting CSV result.<paramref name="elementConverter" /> is used to convert a single element of <paramref name="A" /> into its string representation, using the current cultures number format or the <see cref="T:System.Globalization.CultureInfo" /> provided by <paramref name="culture" />.</para>
        <para>Individual elements will be seperated in the CSV result by ',' (comma) or by the character chain provided by <paramref name="elementSeparator" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Cumulative sum along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Cumulative sum along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
            Cumulative sum along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Cumulative sum along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Cumulative sum along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Cumulative sum along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Cumulative sum along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Cumulative sum along elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{System.Double})">
      <summary>
             Determinant of square matrix
             <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix (square)</param>
      <returns>Determinant of A</returns>
      <remarks>
        <para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br />
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
        <para>For scalar A, a plain copy of A is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
    </member>
    <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{System.Single})">
      <summary>
             Determinant of square matrix
             <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix (square)</param>
      <returns>Determinant of A</returns>
      <remarks>
        <para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br />
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
        <para>For scalar A, a plain copy of A is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
    </member>
    <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
             Determinant of square matrix
             <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix (square)</param>
      <returns>Determinant of A</returns>
      <remarks>
        <para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br />
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
        <para>For scalar A, a plain copy of A is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
    </member>
    <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
             Determinant of square matrix
             <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix (square)</param>
      <returns>Determinant of A</returns>
      <remarks>
        <para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br />
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
        <para>For scalar A, a plain copy of A is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
    </member>
    <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diag``1(ILNumerics.ILInArray{``0},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on 'X' a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Int64},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.UInt32},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Int32},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Byte},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(ILNumerics.ILBaseArray)">
      <summary>
            Size of dimensions of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Double array with the length of each dimension of A</returns>
      <remarks>If A is null, an empty array will be returned. Otherwise the array returned will always be a row vector of length s. s &gt;= 2<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(ILNumerics.ILBaseArray,System.Int32)">
      <summary>
            Length of one specific dimension of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Number of dimension to query the length for</param>
      <returns>Length of dimension 'dim'</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int32[])">
      <summary>
            Create a size descriptor
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dimensions">Arbitrary number of dimension length</param>
      <returns>Size descriptor</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.length(ILNumerics.ILBaseArray)">
      <summary>
            Longest dimension of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>If A is null:0 - length of longest dimension of A</returns>
      <remarks>This is an alias/abreviation for A.Dimensions.Longest<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ndims(ILNumerics.ILBaseArray)">
      <summary>
            Number of dimensions of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>If A is null: 0 - else number of dimensions of A</returns>
      <remarks>This is an alias/abreviation for A.Dimensions.NumberOfDimensions<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.numel(ILNumerics.ILBaseArray)">
      <summary>
            Number of elements of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Number of elements of A</returns>
      <remarks>This is an alias/abreviation for A.Dimensions.NumberOfElements<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Divide elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Divide elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Divide elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Divide elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Divide elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Divide elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Divide elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Divide elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})">
      <summary>
            Compute eigenvalues of general square matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
      <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n]</param>
      <param name="V">Output (optional): eigenvectors</param>
      <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
      <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
      <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
        <para>Depending on the parameter <paramref name="balance" />, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})">
      <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <returns>Array of size [n,1] with eigenvalues of A in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
      <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /></exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Double,System.Double)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
      <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /> or if either one is &lt;= 0.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single})">
      <summary>
            Compute eigenvalues of general square matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
      <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n]</param>
      <param name="V">Output (optional): eigenvectors</param>
      <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
      <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
      <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
        <para>Depending on the parameter <paramref name="balance" />, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single})">
      <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <returns>Array of size [n,1] with eigenvalues of A in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
      <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /></exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Single,System.Single)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
      <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /> or if either one is &lt;= 0.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Compute eigenvalues of general square matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
      <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n]</param>
      <param name="V">Output (optional): eigenvectors</param>
      <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
      <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
      <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
        <para>Depending on the parameter <paramref name="balance" />, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <returns>Array of size [n,1] with eigenvalues of A in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
      <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /></exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Single,System.Single)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
      <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /> or if either one is &lt;= 0.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Compute eigenvalues of general square matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
      <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n]</param>
      <param name="V">Output (optional): eigenvectors</param>
      <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
      <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
      <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})" /> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
        <para>Depending on the parameter <paramref name="balance" />, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <returns>Array of size [n,1] with eigenvalues of A in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
      <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /></exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Double,System.Double)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
      <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /> or if either one is &lt;= 0.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <returns>Vector of eigenvalues. size [n x 1]</returns>
      <remarks>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
      <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <returns>Vector of eigenvalues. size [n x 1]</returns>
      <remarks>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
      <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <returns>Vector of eigenvalues. size [n x 1]</returns>
      <remarks>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
      <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <returns>Vector of eigenvalues. size [n x 1]</returns>
      <remarks>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
      <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.empty">
      <summary>
            Create empty double array of size [0,0].
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(ILNumerics.ILSize)">
      <summary>
            Create empty double array of specific size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">(Empty-) size of new empty array</param>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int32[])">
      <summary>
            Create empty double array of specific size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">(Empty-) size of new empty array</param>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1">
      <summary>
            Create empty array of size [0,0] and arbitrary element type
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty(ILNumerics.ILSize)">
      <summary>
            Create empty double array of specific size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">(Empty-) size of new empty array</param>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty(System.Int32[])">
      <summary>
            Create empty double array of specific size
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">(Empty-) size of new empty array</param>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.localMember``1">
      <summary>
            Create new empty array, used for array class member initialization
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <returns>Empty array which can afterwards be used for arbitrary assignements (Assign(), or 'array.A = ..' assignements)</returns>
      <remarks>The array returned will be an empty array initially. Its main purpose is to provide 
            a persistant array initialization. The array will not be disposed after leaving the current scope
            and can therefore be utilized for initializing class attributes. After initialization, use the 'ILArray.A = ...' property (C#) 
            or the ILArray.Assign() function to assign new values to the array.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="M:ILNumerics.ILMath.localLogical">
      <summary>
            Create new empty logical array, used for logical class member (attributes) initialization
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>Empty logical array which can afterwards be used for arbitrary assignements (Assign(), or 'array.A = ..' assignements)</returns>
      <remarks>The logical array returned will be an empty logical array initially. Its main purpose is to provide 
            a persistant array initialization. The array will not be disposed after leaving the current scope
            and can therefore be utilized for <see href="http://ilnumerics.net/ClassRules.html">initializing class attributes</see>. After initialization, use the 'ILLogical.a = ...' property (C#) 
            or the ILLogical.Assign() function to assign new values to the array.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="M:ILNumerics.ILMath.localCell">
      <summary>
            Create new empty cell array, used for cell class member (attributes) initialization
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>Empty cell array which can afterwards be used for arbitrary assignements (Assign(), or 'array.A = ..' assignements)</returns>
      <remarks>The cell array returned will be an empty cell array initially. Its main purpose is to provide 
            a persistant array initialization. The array will not be disposed after leaving the current scope
            and can therefore be utilized for <see href="http://ilnumerics.net/ClassRules.html">initializing class attributes</see>. After initialization, use the 'ILCell.a = ...' property (C#) 
            or the ILCell.Assign() function to assign new values to the array.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="F:ILNumerics.ILMath.pi">
      <summary>
            Definition of pi
            </summary>
      <remarks>This is an convenience alias for Math.PI</remarks>
    </member>
    <member name="F:ILNumerics.ILMath.pif">
      <summary>
            Definition of pi, single precision
            </summary>
      <remarks>This is an convenience alias for Math.PI</remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.String},ILNumerics.ILInArray{System.String})">
      <summary>
            Elementwise logical 'equal' operator
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array 1</param>
      <param name="B">Input array 2</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input - empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the size of both arrays does not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Exponential of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Exponential of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Exponential of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Exponential of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{System.Single})">
      <summary>
Exponential of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Exponential of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{System.Double})">
      <summary>
Exponential of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Exponential of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eye(System.Int32,System.Int32)">
      <summary>
            Create double matrix having unity diagonal values
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="columns">Number of columns</param>
      <returns>Unity matrix (diagonal matrix) of type double</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eye``1(System.Int32,System.Int32)">
      <summary>
            Create unity matrix, arbitrary numeric type
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="columns">Number of columns</param>
      <returns>Unity matrix (diagonal matrix) of element type T</returns>
      <typeparam name="T">Element type</typeparam>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the type specified is not supported. Supported types are: double, float, complex, fcomplex, int, long, short, byte</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Double})">
      <summary>
            Fast fourier transform (1D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first 
            non singleton dimension.</para>
        <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Fast fourier transform (1D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Fast inverse fourier transform (1D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input (frequency domain)</param>
      <returns>Inverse transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform, complex hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array</param>
      <returns>Real output array, same size as A</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Fast fourier transform along specific dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Real input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Fast fourier transform along specific dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Inverse fast fourier transform along specific dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Inverse fast fourier transform, complex hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Real output array, same size as A</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Double})">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The output array returned will be complex hermitian.</para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (2D, hermitian input)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Double})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Double},System.Int32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Tnput array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Inverse fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Single})">
      <summary>
            Fast fourier transform (1D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first 
            non singleton dimension.</para>
        <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Fast fourier transform (1D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Fast inverse fourier transform (1D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input (frequency domain)</param>
      <returns>Inverse transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform, complex hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array</param>
      <returns>Real output array, same size as A</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Fast fourier transform along specific dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Real input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Fast fourier transform along specific dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Inverse fast fourier transform along specific dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Inverse fast fourier transform, complex hermitian input
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Real output array, same size as A</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Single})">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The output array returned will be complex hermitian.</para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (2D, hermitian input)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Single})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Single},System.Int32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Tnput array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Inverse fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Double},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Int64},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int64})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.UInt32},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.UInt32})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Int32},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Single},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Byte},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Byte})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInLogical,System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutLogical)">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Round towards zero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded towards zero</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Round towards zero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded towards zero</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{System.Single})">
      <summary>
Round towards zero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded towards zero</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{System.Double})">
      <summary>
Round towards zero
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded towards zero</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fliplr``1(ILNumerics.ILInArray{``0})">
      <summary>
            Reverse order of columns of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Inner element type</typeparam>
      <param name="A">Input matrix</param>
      <returns>Matrix of same size as A, having the order of its columns reversed</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.ILInArray{System.Double})">
      <summary>
            Reverse order of columns of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <returns>Matrix of same size as A, having the order of its columns reversed</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.flipud``1(ILNumerics.ILInArray{``0})">
      <summary>
            Reverse order of rows of a matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Inner element type</typeparam>
      <param name="A">Input matrix</param>
      <returns>Matrix of same size as A, having the order of its rows reversed</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.ILInArray{System.Double})">
      <summary>
            Reverse order of rows of a matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <returns>Matrix of same size as A, having the order of its rows reversed</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Round towards negative infinity
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded downwards to next integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Round towards negative infinity
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded downwards to next integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{System.Single})">
      <summary>
Round towards negative infinity
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded downwards to next integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{System.Double})">
      <summary>
Round towards negative infinity
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded downwards to next integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.free``1(``0[])">
      <summary>
            Return a System.Array to the memory pool
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">the element type</typeparam>
      <param name="obj4Dispose">the System.Array to be returned to the pool.</param>
      <remarks>Thes function allows the manual regristration of System.Arrays to the ILNumerics memory pool. See <see cref="M:ILNumerics.ILMath.New``1(System.Int32)" /> for a usage example.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.New``1(System.Int32)" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Double}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{ILNumerics.complex}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Byte}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Int64}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Int32}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Single}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat``1(ILNumerics.ILInArray{``0}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.imag(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Imaginary part of complex array elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Complex input array</param>
      <returns>Imaginary part of complex array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.imag(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Imaginary part of complex array elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Complex input array</param>
      <returns>Imaginary part of complex array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ind2sub(ILNumerics.ILBaseArray,System.Int32)">
      <summary>
            Convert sequential index into subscript indices
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="seqindex">Sequential index</param>
      <returns>Subscript indices</returns>
      <remarks>
        <para>The index array returned will have the length of number of dimensions of A</para>
        <para>If A is a null or an empty array, the return value will be also be empty</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.IndexOutOfRangeException">If seqindex is &lt; 0 or &gt;= numel(A)</exception>
    </member>
    <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Byte})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isempty(ILNumerics.ILBaseArray)">
      <summary>
            Test if array is empty
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>True if at least one dimension of A has length 0, false otherwise</returns>
      <remarks>
        <para>This function is an alias for A.IsEmpty. Consider using the matrix property directly for improved performance.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="P:ILNumerics.ILBaseArray.IsEmpty" />
    </member>
    <member name="M:ILNumerics.ILMath.isequal(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Compares two arrays, return System.bool as result
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements and sizes of both arrays match; false otherwise</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Compare two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>True if all non-NaN elements in A and B equal, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{System.Double})">
      <summary>
Finds finite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{System.Single})">
      <summary>
Finds finite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Finds finite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Finds finite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{System.Double})">
      <summary>
Locate infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{System.Single})">
      <summary>
Locate infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Locate infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Locate infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{System.Double})">
      <summary>
Finds invalid value elements (not-a-number)
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{System.Single})">
      <summary>
Finds invalid value elements (not-a-number)
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Finds invalid value elements (not-a-number)
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Finds invalid value elements (not-a-number)
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{System.Double})">
      <summary>
Finds negative infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{System.Single})">
      <summary>
Finds negative infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Finds negative infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Finds negative infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnull(ILNumerics.ILBaseArray)">
      <summary>
            Determine, if the array A is null (NULL, not assigned)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>True, if the array is null, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnullorempty(ILNumerics.ILBaseArray)">
      <summary>
            Determine, if the array A is null (NULL or not assigned) or empty
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>True, if the array is null or empty, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{System.Double})">
      <summary>
Finds positive infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{System.Single})">
      <summary>
Finds positive infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Finds positive infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Finds positive infinite value elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.linspace(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Create linearly spaced row vector of 100 elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First value</param>
      <param name="end">Last value</param>
      <returns>Row vector with 100 elements linearly spaced between start and end</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linspace``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Create linearly spaced row vector, generic output type
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First value, scalar, numeric</param>
      <param name="end">Last value, scalar, numeric</param>
      <param name="length">Number of elements to create, scalar, numeric</param>
      <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linspace(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Create linearly spaced row vector, double precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First value</param>
      <param name="end">Last value</param>
      <param name="length">Number of elements to create</param>
      <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadArray``1(System.String,System.String)">
      <summary>
            Load single array from matfile file
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type of the array to return</typeparam>
      <param name="filename">Path to the matfile</param>
      <param name="arrayname">[Optional] name of the requested array in the matfile (default: empty -&gt; take the first array found)</param>
      <returns>The array requested</returns>
      <remarks>
        <para>If <paramref name="arrayname" /> is ommited, the first array is returned.</para>
        <para>This function is based on <see cref="T:ILNumerics.ILMatFile" /> which works with Matlab mat files version 6 only. 
            In order to access Matlab mat files of a newer version, use the <see cref="!:ILNumerics.IO.HDF5.H5File" /> API.</para>
        <para>The typeparameter <typeparamref name="T" /> must match the type of elements stored in the mat file.</para>
        <seealso cref="T:ILNumerics.ILMatFile" />
        <seealso cref="!:ILNumerics.IO.HDF5.H5File" />
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadImage(System.String,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image file
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="filename">Image filename</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned. All channels are accumulated in the single element. Each channel 
            is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make sure, the image is provided in a compatible format.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadImage(System.IO.Stream,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image stream
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="inputStream">Image data as stream</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned. All channels are accumulated in the single element. Each channel 
            is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make sure, the image is provided in a compatible format.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadImage(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="image">Image</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned. All channels are accumulated in the single element. Each channel 
            is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make sure, the image is provided in a compatible format.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadChannels(System.String,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="filename">Path to image file to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadChannels(System.IO.Stream,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="inputStream">Image stream with image data to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadChannels(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="image">Image to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadBinary``1(System.IO.Stream,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Action{System.Array,System.Int32,System.Array,System.Int32,System.Int32})">
      <summary>
            Load binary data from stream
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for returned array</typeparam>
      <param name="stream">Input stream to read from</param>
      <param name="leadDimLen">length of the 'leading dimension', how many elements of T fit into one scanline?</param>
      <param name="height">height of the area to read</param>
      <param name="width">widht of the area to read</param>
      <param name="offsetWidth">[Optional] Skip that many columns. Default: 0</param>
      <param name="offsetHeight">[Optional] Skip that many rows. Default: 0</param>
      <param name="convertScanLine">[optional] Function used for copying individual scanlines. Default: null (Buffer.BlockCopy)</param>
      <returns>Array with element type <typeparamref name="T" /> and size as specified with a binary copy of the region read from <paramref name="stream" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logc(ILNumerics.ILInArray{System.Single})">
      <summary>
Logarithm of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logc(ILNumerics.ILInArray{System.Double})">
      <summary>
Logarithm of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Logarithm of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Logarithm of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{System.Single})">
      <summary>
Logarithm of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logarithm of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{System.Double})">
      <summary>
Logarithm of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logarithm of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10c(ILNumerics.ILInArray{System.Single})">
      <summary>
Logarithm of base 10 of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of base 10 of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10c(ILNumerics.ILInArray{System.Double})">
      <summary>
Logarithm of base 10 of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of base 10 of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Logarithm of base 10 of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of base 10 of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Logarithm of base 10 of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of base 10 of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{System.Single})">
      <summary>
Logarithm of base 10 of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logarithm of base 10 of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{System.Double})">
      <summary>
Logarithm of base 10 of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logarithm of base 10 of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logical(System.Byte[],System.Int32[])">
      <summary>
            Create logical array explicitely.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="data">system array of 0/1 valued byte elements</param>
      <param name="size">the size of the new logical array</param>
      <returns>a new logical with the elements from data and the given size</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logspace(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create logarithmically spaced row vector of 30 elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First exponent value.</param>
      <param name="end">Last exponent value.</param>
      <returns>Row vector with 30 elements logathmically spaced between 10^start and 10^end.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logspace(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create logarithmically spaced row vector.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First exponent value.</param>
      <param name="end">Last exponent value.</param>
      <param name="length">Number of elements to create.</param>
      <returns>Row vector with 'length' elements logarithmically spaced between 10^start and 10^end.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Shifts the elements of A bitwise to the left by value of B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the left by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Shifts the elements of A bitwise to the left by value of B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the left by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Shifts the elements of A bitwise to the left by value of B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the left by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> instead.</para>
        <para>The matrix L will be a solid ILArray.</para>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix to be decomposed. Size [m x n]</param>
      <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para><example><code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example><para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> which returns the permuation matrix P also.</para><para>All of the matrices U and L returned will be solid ILArrays.</para><para>lu uses the Lapack function ?getrf.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
      <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para><example><code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code></example><para>lu uses the Lapack function ?getrf.</para><para>All of the matrices U,L,P returned will be solid ILArrays.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> instead.</para>
        <para>The matrix L will be a solid ILArray.</para>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix to be decomposed. Size [m x n]</param>
      <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para><example><code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example><para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> which returns the permuation matrix P also.</para><para>All of the matrices U and L returned will be solid ILArrays.</para><para>lu uses the Lapack function ?getrf.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
      <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para><example><code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code></example><para>lu uses the Lapack function ?getrf.</para><para>All of the matrices U,L,P returned will be solid ILArrays.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> instead.</para>
        <para>The matrix L will be a solid ILArray.</para>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix to be decomposed. Size [m x n]</param>
      <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para><example><code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example><para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> which returns the permuation matrix P also.</para><para>All of the matrices U and L returned will be solid ILArrays.</para><para>lu uses the Lapack function ?getrf.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
      <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para><example><code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code></example><para>lu uses the Lapack function ?getrf.</para><para>All of the matrices U,L,P returned will be solid ILArrays.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> instead.</para>
        <para>The matrix L will be a solid ILArray.</para>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix to be decomposed. Size [m x n]</param>
      <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para><example><code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example><para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /> which returns the permuation matrix P also.</para><para>All of the matrices U and L returned will be solid ILArrays.</para><para>lu uses the Lapack function ?getrf.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
      <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para><example><code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code></example><para>lu uses the Lapack function ?getrf.</para><para>All of the matrices U,L,P returned will be solid ILArrays.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})" />
      <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.MMultBlockedThreaded(System.Double[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Experimental! Do not use! This function is not working in a mutithreaded context!!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A"></param>
      <param name="B"></param>
      <param name="C"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="k"></param>
      <param name="kc"></param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.MMultBlockedThreaded(System.Single[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Experimental! Do not use! This function is not working in a mutithreaded context!!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A"></param>
      <param name="B"></param>
      <param name="C"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="k"></param>
      <param name="kc"></param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.MMultBlockedThreaded(ILNumerics.fcomplex[],ILNumerics.fcomplex[],ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Experimental! Do not use! This function is not working in a mutithreaded context!!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A"></param>
      <param name="B"></param>
      <param name="C"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="k"></param>
      <param name="kc"></param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.MMultBlockedThreaded(ILNumerics.complex[],ILNumerics.complex[],ILNumerics.complex[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Experimental! Do not use! This function is not working in a mutithreaded context!!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A"></param>
      <param name="B"></param>
      <param name="C"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="k"></param>
      <param name="kc"></param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Double})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Single})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
      <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
      <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="Z">Vector of z values</param>
      <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
      <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
      <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
      <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
      <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
      <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="Z">Vector of z values</param>
      <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
      <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
      <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
      <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
      <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
      <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="Z">Vector of z values</param>
      <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
      <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
      <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
      <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
      <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
      <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="Z">Vector of z values</param>
      <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
      <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
      <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
      <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Double})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Single})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Modulus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Modulus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Modulus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Modulus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Modulus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Modulus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Double}[])">
      <summary>
            Multiplicate an arbitrary number of matrices from left to right
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="matrices">Input matrices </param>
      <returns>Result of matrix multiplication for all matrices</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            General matrix multiply this array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <param name="B">Input matrix B</param>
      <returns>Matrix with result of matrix multiplication</returns>
      <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Single}[])">
      <summary>
            Multiplicate an arbitrary number of matrices from left to right
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="matrices">Input matrices </param>
      <returns>Result of matrix multiplication for all matrices</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            General matrix multiply this array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <param name="B">Input matrix B</param>
      <returns>Matrix with result of matrix multiplication</returns>
      <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
      <summary>
            Multiplicate an arbitrary number of matrices from left to right
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="matrices">Input matrices </param>
      <returns>Result of matrix multiplication for all matrices</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            General matrix multiply this array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <param name="B">Input matrix B</param>
      <returns>Matrix with result of matrix multiplication</returns>
      <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.complex}[])">
      <summary>
            Multiplicate an arbitrary number of matrices from left to right
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="matrices">Input matrices </param>
      <returns>Result of matrix multiplication for all matrices</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            General matrix multiply this array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <param name="B">Input matrix B</param>
      <returns>Matrix with result of matrix multiplication</returns>
      <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.String},ILNumerics.ILInArray{System.String})">
      <summary>
            Elementwise logical 'not equal' operator
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal elements in B, '0' else</returns>
      <remarks>
        <para>On empty input - empty array will be returned.</para>
        <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
    </member>
    <member name="M:ILNumerics.ILMath.New``1(System.Int32)">
      <summary>
             Request System.Array <typeparamref name="T" />[] from ILNumerics Memory Pool
             <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">the element type</typeparam>
      <param name="minLength">
        <b>minimal</b> length of the array returned</param>
      <returns>A system array of element type <typeparamref name="T" /> and minimal length <paramref name="minLength" />.</returns>
      <remarks>
        <para>This function fetches a System.Array from the collection of available arrays which are currently held in the ILNumerics Memory Pool. 
             If no matching array is available, a new array will be allocated from the runtime.</para>
        <para>Important note: the array returned is not guaranteed to be cleared! Furthermore, it may contain more elements than requested by <paramref name="minLength" />!</para>
        <para>The array returned is fetched from the collection of available arrays in the pool. If no matching array was found, a new array is requested from the managed heap.</para>
        <para>The user is reponsible to return the array to the pool once finished using it. The <see cref="M:ILNumerics.ILMath.free``1(``0[])" /> method should be used for returning an array.</para>
        <para>Keep in mind, the array returned may be <b>longer</b> as requested! Therefore, in order to reference its elements use the <paramref name="minLength" /> parameter rather than the System.Array.Length property.</para>
        <example>A system array is needed inside a computational loop. The loop calls a native function repeatedly which requests a working array. The System.Array is requested from the pool and returned to the pool after usage.
             <code><![CDATA[
            [System.Runtime.InteropServices.DllImport("myDLL")]
            private static extern void MyDllFunc(double[] a, int lenA, double[] b, double[] work, int lenWork);
            
            public static ILRetArray<double> MyFunc(ILInArray<double> A) {
                using (ILScope.Enter(A)) {
                    // myDllFunc needs storage for the result
                    ILArray<double> ret = zeros(A.Size);
                    ILArray<double> tmpRow = zeros(1, A.S[1]);
            
                    // myDllFunc needs a working storage:
                    double[] work = New<double>(A.S[1]);
                    // for all rows of A use the same working array
                    for (int i = 0; i < A.S[0]; i++) {
                        using (ILScope.Enter()) {
                            ILArray<double> ARow = A[i, full];
                            MyDllFunc(ARow.GetArrayForRead(), A.Length, tmpRow.GetArrayForWrite(), work, A.Length);
                            ret[i, full] = tmpRow;
                        }
                    }
                    // return the System.Array to the pool 
                    free(work);
                    return ret;
                }
            }
             ]]></code>
             However, in most situations, the handling of system.arrays directly can be circumvented. The same goal as in the 
             example could be archieved as follows: 
             <code><![CDATA[       
             public static ILRetArray<double> MyFunc(ILInArray<double> A) {
            using (ILScope.Enter(A)) {
                // myDllFunc needs storage for the result
                ILArray<double> ret = zeros(A.Size);
                ILArray<double> tmpRow = zeros(1, A.S[1]);
                // myDllFunc needs a working storage. We us a regular ILNumerics array 
                // which we dont have to free afterwards. 
                ILArray<double> work = zeros(tmpRow.S); 
            
                // for all rows of A use the same working array
                for (int i = 0; i < A.S[0]; i++) {
                    using (ILScope.Enter()) {
                        ILArray<double> ARow = A[i, full];
                        MyDllFunc(ARow.GetArrayForRead(), A.Length, tmpRow.GetArrayForWrite(), work.GetArrayForWrite(), A.Length);
                        ret[i, full] = tmpRow;
                    }
                }
                // returning the working storage is not needed here...
            
                return ret;
            }
            }]]></code>
             Both examples archieve a 100% memory efficiency by completely reusing the memory needed within the function. 
             </example>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{System.Double},System.Double)">
      <summary>
            Vector or matrix norm
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input matrix or vector</param>
      <param name="degree">[optional] degree of norm (default: 2)</param>
      <returns>Array of same type as input array A</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of: 
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item><item>System.double.PositiveInfinity: return Max(abs(A))</item><item>System.double.NegativeInfinity: return Min(abs(A))</item></list>
            For matrices <paramref name="degree" /> must be one out of: 
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Double)">
      <summary>
            Vector or matrix norm
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input matrix or vector</param>
      <param name="degree">[optional] degree of norm (default: 2)</param>
      <returns>Array of same type as input array A</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of: 
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item><item>System.double.PositiveInfinity: return Max(abs(A))</item><item>System.double.NegativeInfinity: return Min(abs(A))</item></list>
            For matrices <paramref name="degree" /> must be one out of: 
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{System.Single},System.Double)">
      <summary>
            Vector or matrix norm
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input matrix or vector</param>
      <param name="degree">[optional] degree of norm (default: 2)</param>
      <returns>Array of same type as input array A</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of: 
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item><item>System.double.PositiveInfinity: return Max(abs(A))</item><item>System.double.NegativeInfinity: return Min(abs(A))</item></list>
            For matrices <paramref name="degree" /> must be one out of: 
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{ILNumerics.complex},System.Double)">
      <summary>
            Vector or matrix norm
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input matrix or vector</param>
      <param name="degree">[optional] degree of norm (default: 2)</param>
      <returns>Array of same type as input array A</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of: 
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item><item>System.double.PositiveInfinity: return Max(abs(A))</item><item>System.double.NegativeInfinity: return Min(abs(A))</item></list>
            For matrices <paramref name="degree" /> must be one out of: 
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones(System.Int32[])">
      <summary>
            Create new double array, set initial values to 1
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones(ILNumerics.NumericType,ILNumerics.ILSize)">
      <summary>
            Create array initialized with all elements set to one
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType" />
            enum.</param>
      <param name="size">Size descriptor</param>
      <returns>Array of inner type corresponding to <paramref name="type" /> argument.</returns>
      <remarks>The array returned must be casted to the appropriate actual type afterwards and assigned to a concrete array! Caution: 
            This overload is provided for compatibility reasons only! Use <see cref="M:ILNumerics.ILMath.ones``1(ILNumerics.ILSize)" /> instead.
            <para><list type="number"><listheader>The following types are supported: </listheader><item>Double</item><item>Single</item><item>Complex</item><item>FComplex</item><item>Byte</item><item>Int32</item><item>Int64</item></list></para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int32[])">
      <summary>
            Create array initialized with all elements set to one
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Numeric type specification.</typeparam>
      <param name="size">Size descriptor</param>
      <returns>Array of inner type corresponding to the given type.</returns>
      <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para><list type="number"><listheader>The following types are supported: </listheader><item>Double</item><item>Single</item><item>complex</item><item>fcomplex</item><item>Byte</item><item>Int32</item><item>UInt32</item><item>Int64</item></list></para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(ILNumerics.ILSize)">
      <summary>
            Create array initialized with all elements set to one
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Numeric type specification.</typeparam>
      <param name="size">Size descriptor</param>
      <returns>Array of inner type corresponding to the given type.</returns>
      <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para><list type="number"><listheader>The following types are supported: </listheader><item>Double</item><item>Single</item><item>complex</item><item>fcomplex</item><item>Byte</item><item>Int32</item><item>UInt64</item><item>Int64</item></list></para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones(ILNumerics.ILSize)">
      <summary>
            Create new double array, set initial values to 1
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>Array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double})">
      <summary>
            Pseudo - inverse of input argument M
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <returns>Pseudo inverse of input matrix M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest number greater than zero</item></list>
            You may use a overloaded function to define an alternative tolerance. 
            <para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)" />
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)">
      <summary>
            Pseudo inverse of input matrix M
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
      <returns>Pseudo inverse of M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest constructable double precision number greater than zero</item></list><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Single})">
      <summary>
            Pseudo - inverse of input argument M
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <returns>Pseudo inverse of input matrix M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest number greater than zero</item></list>
            You may use a overloaded function to define an alternative tolerance. 
            <para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)" />
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Single},System.Single)">
      <summary>
            Pseudo inverse of input matrix M
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
      <returns>Pseudo inverse of M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest constructable double precision number greater than zero</item></list><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Pseudo - inverse of input argument M
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <returns>Pseudo inverse of input matrix M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest number greater than zero</item></list>
            You may use a overloaded function to define an alternative tolerance. 
            <para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)" />
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.fcomplex)">
      <summary>
            Pseudo inverse of input matrix M
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
      <returns>Pseudo inverse of M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest constructable double precision number greater than zero</item></list><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Pseudo - inverse of input argument M
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <returns>Pseudo inverse of input matrix M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest number greater than zero</item></list>
            You may use a overloaded function to define an alternative tolerance. 
            <para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)" />
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.complex)">
      <summary>
            Pseudo inverse of input matrix M
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
      <returns>Pseudo inverse of M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest constructable double precision number greater than zero</item></list><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pol2cart(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Transform polar/ cylindrical coordinates into scalar coordinates
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="theta">Angle to x axis</param>
      <param name="radius">Radius from z axis</param>
      <param name="Z">Height</param>
      <param name="outY">If on entry not null, the Y components are returned in outY</param>
      <param name="outZ">If on entry not null, the Z components are returned in outZ</param>
      <returns>X component, Y and Z are returned as out parameter if requested</returns>
      <remarks>Theta, radius and Z must be of the same size or either one may be scalar. 
            Scalar coordinate arrays returned are of the same size then the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pol2cart(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Transform polar/ cylindrical coordinates into scalar coordinates
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="theta">Angle to x axis</param>
      <param name="radius">Radius from z axis</param>
      <param name="Z">Height</param>
      <param name="outY">If on entry not null, the Y components are returned in outY</param>
      <param name="outZ">If on entry not null, the Z components are returned in outZ</param>
      <returns>X component, Y and Z are returned as out parameter if requested</returns>
      <remarks>Theta, radius and Z must be of the same size or either one may be scalar. 
            Scalar coordinate arrays returned are of the same size then the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.poly(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Polynomial evaluation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="c">Vector of coefficients of the polynomial</param>
      <param name="x">Position where the polynomial is to be evaluated. The position may be either a scalar, a vector or a matrix.</param>
      <example>
        <code><![CDATA[
             //Evaluation of the polynomial 1+x+2.1 x + x^2+3x^3 at (1,1,1)
             ILArray<float> y = Optimization.poly(ILMath.array<float>(1.0, 2.1, 1.0, 3.0),ILMath.ones<float>(3, 1));
            ]]></code>
      </example>
      <returns>The value of a polynomial of degree d at position x, with d=c.lenght-1</returns>
      <remarks> If the input position is an array, the evaluation will be done elementwise<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.poly(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Polynomial evaluation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="c">Vector of coefficients of the polynomial</param>
      <param name="x">Position where the polynomial is to be evaluated. The position may be either a scalar, a vector or a matrix.</param>
      <example>
        <code><![CDATA[
             //Evaluation of the polynomial 1+x+2.1 x + x^2+3x^3 at (1,1,1)
             ILArray<double> y = Optimization.poly(ILMath.array<double>(1.0, 2.1, 1.0, 3.0), ILMath.ones<double>(3, 1));
            ]]></code>
      </example>
      <returns>The value of a polynomial of degree d at position x, with d=c.lenght-1</returns>
      <remarks> If the input position is an array, the evaluation will be done elementwise<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Power elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Power elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Power elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Power elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Power elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Power elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Power elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Power elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            QR decomposition, returning Q and R
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
      <summary>
            QR decomposition, returning Q and R, optionally economical sized
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
      <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize" /> (see remarks below)</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            QR decomposition with pivoting
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
      <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
      <summary>
            QR decomposition with pivoting, possibly economical sized
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize" /> (see remarks).</param>
      <param name="economySize">
        <para>If true, <list type="bullet"><item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item><item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
        <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /></para>
      </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize" /> is 
            true, a row vector of length n otherwise</para></param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> 
            (see remarks below)</returns>
      <remarks>
        <para> If <paramref name="economySize" /> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
        <para>If <paramref name="economySize" /> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
        <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            QR decomposition, returning Q and R
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
      <summary>
            QR decomposition, returning Q and R, optionally economical sized
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
      <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize" /> (see remarks below)</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            QR decomposition with pivoting
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
      <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
      <summary>
            QR decomposition with pivoting, possibly economical sized
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize" /> (see remarks).</param>
      <param name="economySize">
        <para>If true, <list type="bullet"><item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item><item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
        <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /></para>
      </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize" /> is 
            true, a row vector of length n otherwise</para></param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> 
            (see remarks below)</returns>
      <remarks>
        <para> If <paramref name="economySize" /> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
        <para>If <paramref name="economySize" /> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
        <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            QR decomposition, returning Q and R
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            QR decomposition, returning Q and R, optionally economical sized
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
      <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize" /> (see remarks below)</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            QR decomposition with pivoting
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
      <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            QR decomposition with pivoting, possibly economical sized
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize" /> (see remarks).</param>
      <param name="economySize">
        <para>If true, <list type="bullet"><item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item><item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
        <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /></para>
      </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize" /> is 
            true, a row vector of length n otherwise</para></param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> 
            (see remarks below)</returns>
      <remarks>
        <para> If <paramref name="economySize" /> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
        <para>If <paramref name="economySize" /> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
        <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            QR decomposition, returning Q and R
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            QR decomposition, returning Q and R, optionally economical sized
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
      <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize" /> (see remarks below)</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            QR decomposition with pivoting
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
      <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            QR decomposition with pivoting, possibly economical sized
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize" /> (see remarks).</param>
      <param name="economySize">
        <para>If true, <list type="bullet"><item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item><item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
        <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})" /></para>
      </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize" /> is 
            true, a row vector of length n otherwise</para></param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> 
            (see remarks below)</returns>
      <remarks>
        <para> If <paramref name="economySize" /> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
        <para>If <paramref name="economySize" /> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
        <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.r(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Region creator for subarray specifications
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Begin of region, index of first element</param>
      <param name="end">End of region, last element</param>
      <returns>An array which specifies all indices of the region</returns>
      <remarks>The r function provides a shorter way to specify regions in subarray
            expressions. Other than alternatives like <see cref="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)" />, 
            it also enables the use of the <see cref="P:ILNumerics.ILMath.end" /> keyword - even in 
            conjunction with simple mathematical expressions.<para>[ILNumerics Computing Engine]</para></remarks>
      <example>
        <code>ILArray&lt;double&gt; A = counter(5,4,3), B;
            
            // the following subarrays will all create the same B: 
            B = A[full,r(1,end-1),full]; 
            B = A[r(0,end),"1,2",":"];
            B = A[":;1:2;0:end"];
            
            // however, these expression will <b>not</b> work:
            B = A[":;0:end-1,:"]; // 'end' expression evaluation is not supported in strings. 
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.r(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Stepped region creator for subarray specifications
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Begin of region, index of first element</param>
      <param name="end">End of region, last element</param>
      <param name="step">Increment, distance between created indices</param>
      <returns>An array which specifies the indices of the region</returns>
      <remarks>The r function provides a shorter way to specify regions in subarray
            expressions. Other than alternatives like <see cref="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)" />, 
            it also enables the use of the <see cref="P:ILNumerics.ILMath.end" /> keyword - even in 
            conjunction with simple mathematical expressions.<para>[ILNumerics Computing Engine]</para></remarks>
      <example>
        <code>ILArray&lt;double&gt; A = counter(5,4,3), B;
            
            // the following subarrays will all create the same B: 
            B = A[full,r(1,end-1),full]; 
            B = A[r(0,end),"1,2",":"];
            B = A[":;1:2;0:end"];
            
            // however, these expression will <b>not</b> work:
            B = A[":;0:end-1,:"]; // 'end' expression evaluation is not supported in strings. 
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int32[])">
      <summary>
            Pseudo random N-dimensional array elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dimensions">int array or individual int parameters specifying 
            dimensions for new array to be created.</param>
      <returns>N-dimensional array filled with random numbers.</returns>
      <remarks>
        <para>Uniformly distributed elements within the range 0.0 ... 1.0 are created.</para>
        <para>The initial seed will be set to Environment.TickCount on the first call.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int32[])">
      <summary>
            Normal randomly-distributed N-dimensional array elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
      <returns>N-dimensional array filled with random numbers.</returns>
      <remarks>The elements lie within the range 0.0 ... 1.0 and are choosen to be normally 
            distributed.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{System.Double},System.Double)">
      <summary>
            Rank of matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
      <returns>Rank of matrix A</returns>
      <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet"><item>length(A) - the longest dimension of A</item><item>norm(A) being the largest singular value of A, </item><item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item></list><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Double)">
      <summary>
            Rank of matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
      <returns>Rank of matrix A</returns>
      <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet"><item>length(A) - the longest dimension of A</item><item>norm(A) being the largest singular value of A, </item><item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item></list><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{System.Single},System.Double)">
      <summary>
            Rank of matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
      <returns>Rank of matrix A</returns>
      <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet"><item>length(A) - the longest dimension of A</item><item>norm(A) being the largest singular value of A, </item><item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item></list><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{ILNumerics.complex},System.Double)">
      <summary>
            Rank of matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
      <returns>Rank of matrix A</returns>
      <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet"><item>length(A) - the longest dimension of A</item><item>norm(A) being the largest singular value of A, </item><item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item></list><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Real part of complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Complex input array</param>
      <returns>Real part of complex array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Real part of complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Complex input array</param>
      <returns>Real part of complex array</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Double},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Byte},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Int64},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Int32},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Single},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``1(ILNumerics.ILInArray{``0},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Double},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Double},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Byte},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Byte},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int64},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int64},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int32},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int32},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Single},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Single},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.ILInArray{``0},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions array. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.ILInArray{``0},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new reference array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Round to nearest integer
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded to nearest integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Round to nearest integer
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded to nearest integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{System.Single})">
      <summary>
Round to nearest integer
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded to nearest integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{System.Double})">
      <summary>
Round to nearest integer
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded to nearest integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Shifts the elements of A bitwise to the right by value of B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the right by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Shifts the elements of A bitwise to the right by value of B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the right by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Shifts the elements of A bitwise to the right by value of B.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the right by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Double})">
      <summary>
Signum of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Single})">
      <summary>
Signum of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Signum of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Signum of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int64})">
      <summary>
Signum of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int32})">
      <summary>
Signum of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int16})">
      <summary>
Signum of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Byte})">
      <summary>
Signum of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{System.Double})">
      <summary>
Sinus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Sinus of elements from input array</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Sinus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Sinus of elements from input array</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Sinus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Sinus of elements from input array</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{System.Single})">
      <summary>
Sinus of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Sinus of elements from input array</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Hyperbolic sine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic sine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic sine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic sine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{System.Single})">
      <summary>
Hyperbolic sine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic sine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{System.Double})">
      <summary>
Hyperbolic sine of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic sine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item><item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item><item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.MatrixProperties@)">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
      <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the <paramref name="props" /> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. 
            </item><item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item><item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy'.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B by means of rounding errors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), the precision given by <see cref="P:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
      <param name="B">Solution vector or matrix. Size [n x m]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via backward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A below the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
      <param name="B">Solution vector. Size [n x 1]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via forward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A above the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item><item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item><item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.MatrixProperties@)">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
      <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the <paramref name="props" /> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. 
            </item><item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item><item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy'.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B by means of rounding errors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), the precision given by <see cref="P:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
      <param name="B">Solution vector or matrix. Size [n x m]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via backward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A below the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
      <param name="B">Solution vector. Size [n x 1]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via forward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A above the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item><item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item><item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@)">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
      <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the <paramref name="props" /> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. 
            </item><item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item><item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy'.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B by means of rounding errors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), the precision given by <see cref="P:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
      <param name="B">Solution vector or matrix. Size [n x m]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via backward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A below the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
      <param name="B">Solution vector. Size [n x 1]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via forward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A above the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item><item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item><item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.MatrixProperties@)">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
      <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the <paramref name="props" /> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. 
            </item><item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item><item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy'.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B by means of rounding errors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), the precision given by <see cref="P:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
      <param name="B">Solution vector or matrix. Size [n x m]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via backward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A below the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
      <param name="B">Solution vector. Size [n x 1]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via forward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A above the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.UInt32},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.UInt32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String})">
      <summary>
            Sort strings in A along first non singleton dimension ascending
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},System.Boolean)">
      <summary>
            Sort strings in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},System.Int32,System.Boolean)">
      <summary>
            Sort strings in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <param name="dim">Dimension to sort along</param>
      <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
      <summary>
             Sort data in A along dimension 'dim'
             <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array: empty, scalar, vector or matrix</param>
      <param name="descending">Specifies the direction of sorting</param>
      <param name="dim">Dimension to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix also</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>
        <para>The data in A will be sorted using the quick sort algorithm. Data 
             along the dimension <paramref name="dim" /> will get sorted independently from data 
             in the next row/column.</para>
        <para>This overload also returns an array 'Indices' which will hold the indices into the original 
             elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort``3(ILNumerics.ILInArray{``0},ILNumerics.ILOutArray{``2},System.Int32,System.Boolean,ILNumerics.Algorithms.ILKeyMapper{``0,``1})">
      <summary>
            Generic bucket sort algorithm in A along arbitrary dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array: empty, scalar, vector or matrix</param>
      <param name="descending">Specifies the direction of sorting</param>
      <param name="dim">Dimension to sort along</param>
      <param name="Indices">[Input/Output] The values in Indices will be returned in the same sorted order as the elements 
            in A. This can be used to derive a permutation matrix of the sorted indices.</param>
      <typeparam name="T">Element type of values of A</typeparam>
      <typeparam name="S">Subelement type. For element type of string this would be 'char'</typeparam>
      <typeparam name="I">Element type of indices</typeparam>
      <param name="keymapper">Instancce of an object of type ILKeyMapper. This object must 
            be derived from ILKeyMapper{T,SubelementType} and match the generic argument <typeparamref name="T" />. It will be 
            used to split single elements into its subelements and map their content into bucket numbers. For all 
            reference types except those of type string you will have to write your own ILKeyMapper class for that purpose.</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>
        <para>The data in A will be sorted using the bucket sort algorithm. Data 
            along the dimension <paramref name="dim" /> will get sorted independently. I.e., for dim = 0, columns are sorted independently.</para>
        <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Therefore, the unsorted indices must be provided by the user on entry. Indices must not be null.</para>
        <para>This generic version is able to sort arbitrary element types. Even user defined reference types can be sorted 
            by specifying a user defined ILKeyMapper class instance. Also the type of Indices may be arbitrarily choosen. In difference 
            to the regular sort function overload, Indices must manually be given to the function on entry. Elements in 'Indices'
            are sorted in the same order as the elements of A.</para>
        <para>By using this overload you may use the same permutation matrix several times to reflect the 
            manipulations done to A due multiple sort processes. The Indices given will directly be used for the sorting 
            disregarding initial order.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrtc(ILNumerics.ILInArray{System.Single})">
      <summary>
Square root of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array - positive and negative values allowed</param>
      <returns>Square root of elements of A - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrtc(ILNumerics.ILInArray{System.Double})">
      <summary>
Square root of array elements - complex output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array - positive and negative values allowed</param>
      <returns>Square root of elements of A - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Square root of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Square root of elements of A </returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Square root of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Square root of elements of A </returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{System.Single})">
      <summary>
Square root of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array - only positive values are allowed.</param>
      <returns>Square root of elements of A - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{System.Double})">
      <summary>
Square root of array elements - real output
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array - only positive values are allowed.</param>
      <returns>Square root of elements of A - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sub2ind(ILNumerics.ILBaseArray,System.Int32[])">
      <summary>
            Convert subscript indices to sequential index
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="subscripts">Subscripts</param>
      <returns>Sequential index for subscript indices</returns>
      <remarks>The function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector 
            is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the 
            rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 
            'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing 
            unit in double precision. The result will be rounded to the nearest integer (midpoint away from zero) and clamped to the limits 
            (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results 
            in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to 
            as 'saturation'.)</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Double})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Single})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Vector with min(M,N) singular values of A as column vector</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Vector with min(M,N) singular values of A as column vector</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Vector with min(M,N) singular values of A as column vector</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Vector with min(M,N) singular values of A as column vector</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
      <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
      <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
      <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
      <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean,System.Boolean)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
      <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
      <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
      <returns>Singular values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean,System.Boolean)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
      <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
      <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
      <returns>Singular values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean,System.Boolean)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
      <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
      <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
      <returns>Singular values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean,System.Boolean)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
      <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
      <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
      <returns>Singular values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Tangens of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Tangens of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Tangens of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Tangens of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{System.Single})">
      <summary>
Tangens of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Tangens of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{System.Double})">
      <summary>
Tangens of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Tangens of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Hyperbolic tangent of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic tangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic tangent of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic tangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{System.Single})">
      <summary>
Hyperbolic tangent of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic tangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{System.Double})">
      <summary>
Hyperbolic tangent of array elements
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic tangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Double})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Single})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.triu``1(ILNumerics.ILInArray{``0})">
      <summary>
            Extrac upper triangular part of matrix A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Type of matrix elements</typeparam>
      <param name="A">Input matrix A, size [m x n]</param>
      <returns>Array of size [m x n], holding upper triangular part of A. The lower trianglular part is filled with zeros.</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tril``1(ILNumerics.ILInArray{``0})">
      <summary>
            Lower triangular part of matrix
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Inner type of matrix</typeparam>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Array of size [m x n], holding lower triangular part of A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Regulary spaced vector
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value</param>
      <param name="end">End value</param>
      <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with interval 1. The last element 
            of the returned vector will be less than or equal to end, if start <![CDATA[<]]> end.</returns>
      <remarks>This is the same as vector (start,1,end).<para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If start <![CDATA[>]]> end</exception>
    </member>
    <member name="M:ILNumerics.ILMath.vec``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Regularly spaced vector, spacing 1
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value</param>
      <param name="end">End value</param>
      <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with stepsize of 1. The last element 
            of the returned vector will be less than or equal to end, if start &lt; end. </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vec``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Regulary spaced column vector
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value</param>
      <param name="step">Step size</param>
      <param name="end">End value</param>
      <returns>Column vector of length N, where N is the number of elements 
            between start and end, all equally spaced with stepsize of 'step'. The last element 
            of the returned vector will be less than or equal to end, if start &lt; end. If start 
            &gt; end, the elements in the vector will linearly decrease from 
            start to end. In this case, step must be negative.</returns>
      <remarks>
        <para>The shape of the vector created is controlled by the setting switch <see cref="P:ILNumerics.Settings.CreateRowVectorsByDefault" />.
            This setting defaults to 'false' which will cause the creation of a column vector. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Double}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{ILNumerics.complex}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Byte}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Int64}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Int32}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Single}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat``1(ILNumerics.ILInArray{``0}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other.
            </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.zeros(System.Int32[])">
      <summary>
            Create double array with all elements initialized to 0
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">Size description</param>
      <returns>Zeros-filled array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros(ILNumerics.ILSize)">
      <summary>
            Create double array with all elements initialized to 0
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">Size descriptor</param>
      <returns>Zeros-filled array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(ILNumerics.ILSize)">
      <summary>
            Create array with all elements initialized to default(T)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="size">Size descriptor</param>
      <returns>New array, initialized to default(T)</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int32[])">
      <summary>
            Create new array of arbitrary element type, initialized to '0'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="size">Size description</param>
      <returns>New array having the size determined by 'dims', initialized to '0'</returns>
      <remarks>For T deriving from Sytem.ValueType elements will be '0'. All other element types
            will be initialized to default(T).<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros(ILNumerics.NumericType,ILNumerics.ILSize)">
      <summary>
            Create array initialized with all elements set to zero
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType" />
            enum.</param>
      <param name="size">Size descriptor</param>
      <returns>Array of inner type corresponding to <paramref name="type" /> argument.</returns>
      <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para><list type="number"><listheader>The following types are supported: </listheader><item>Double</item><item>Single</item><item>Complex</item><item>FComplex</item><item>Byte</item><item>Int32</item><item>Int64</item></list></para><para>This function is provided for downward compatibility reasons only and will be removed in a future update. It is recommended to use the <see cref="M:ILNumerics.ILMath.zeros``1(ILNumerics.ILSize)" /> or <see cref="M:ILNumerics.ILMath.zeros``1(System.Int32[])" /> overloads instead.</para><para>The interface of this function does not confirm to the rules of functions in ILNumerics. Therefore, in order to prevent for potential memory issues, the return value should be converted to 
            a concrete array type explicitely: </para><example><code>
            ILArray&lt;double&gt; A = todouble(zeros(NumericType.double, size(10,20))); 
            
            // better and easier would be: 
            ILArray&lt;double&gt; B = zeros&lt;double&gt;(10,20); 
            </code></example><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.gammaLog(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the natural logarithm of the Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Gamma_function">Wikipedia - Gamma function</a> 
            and <a href="http://mathworld.wolfram.com/LogGammaFunction.html">Wolfram MathWorld - Log Gamma function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>log(gamma(<paramref name="x" />)) with <c>gamma(<paramref name="x" />) = from 0 to ∞ ∫(t^(<paramref name="x" />-1)exp(-t))dt</c>.</returns>
      <remarks>
        <list type="bullet">
          <item>The value of the Gamma function can be found simply using the exponential of the value found from the function. Example: exp(gammaLog(10.0)) will give the value of the gamma function at 10.0.</item>
          <item>In this particular implementation the positive real numbers are supported.</item>
          <item>If the given point <paramref name="x" /> is negative the return value will be double.NaN.</item>
          <item>If the given point <paramref name="x" /> is zero the return value will be double.PositiveInfinity.</item>
          <item>If any of the given points is double.NaN or double.IsInfinity is true, an ArgumentException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.gamma(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Gamma_function">Wikipedia - Gamma function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>
        <c>gamma(<paramref name="x" />) = from 0 to ∞ ∫(t^(<paramref name="x" />-1)exp(-t))dt</c>.</returns>
      <remarks>
        <list type="bullet">
          <item>The value of the Gamma function is simply calculated as the exponential of the value found from the natural logarithm of Gamma function.</item>
          <item>In this particular implementation the positive real numbers are supported.</item>
          <item>If the given point <paramref name="x" /> is negative the return value will be double.NaN.</item>
          <item>If the given point <paramref name="x" /> is zero the return value will be double.PositiveInfinity.</item>
          <item>If any of the given points is double.NaN or double.IsInfinity is true, an ArgumentException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.factorial(ILNumerics.ILInArray{System.Int32})">
      <summary>
Factorial, from an array of integer elements.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Factorial">Wikipedia - Factorial</a>.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="n">Input array of non-negative integers.</param>
      <returns>An array of same size as <paramref name="n" /> with the factorial of each element.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input array is empty, an empty array will be returned.</item>
          <item>If an element of the array <paramref name="n" /> is negative, the result will be double.NaN.</item>
          <item>If any of the given points is NaN or Infinity an ArgumentException will be thrown.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.factorialLog(ILNumerics.ILInArray{System.Int32})">
      <summary>
Natural logarithm of factorial, from an array of integer elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="n">Input array of non-negative integers.</param>
      <returns>An array of same size as <paramref name="n" /> with the natural logarithm of factorials of each element in <paramref name="n" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input array is empty, an empty array will be returned.</item>
          <item>If an element of the array is negative, the result will be double.NaN.</item>
          <item>If the factorial of an element of the array is infinity, the result will be infinity.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.beta(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Evaluates the componentwise beta function at an array of points defined by <paramref name="w" /> and <paramref name="z" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Beta_function">Wikipedia - Beta function</a>.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="z">Input array.</param>
      <param name="w">Input array so that <paramref name="z" /> &gt; <paramref name="w" /> for all component.</param>
      <returns> An array of same size as <paramref name="z" /> and with component values of the beta function.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="z" />i &lt; <paramref name="w" />i, the solution will be double.NaN.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If z and w size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.binomialCoefficients(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            Binomial coefficients of elements in <paramref name="n" /> and <paramref name="k" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Binomial_coefficient">Wikipedia - Binomial coefficient</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="n">Input array <paramref name="n" />.</param>
      <param name="k">Input array <paramref name="k" />.</param>
      <returns>An array of same size as <paramref name="n" /> and <paramref name="k" /> with values of the binomial coefficients.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="n" />i &lt; <paramref name="k" />i, the solution will be double.NaN.</item>
          <item>If any elements in <paramref name="n" /> and <paramref name="k" /> has the same value, the solution will be +1.0.</item>
          <item>If any elements in <paramref name="n" /> or <paramref name="k" /> has a negative value, the solution will be double.NaN.</item>
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If n and k size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.binomialCoefficientsLog(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            Natural logarithm of binomial coefficients of elements in <paramref name="n" /> and <paramref name="k" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Binomial_coefficient">Wikipedia - Binomial coefficient</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="n">Input array <paramref name="n" />.</param>
      <param name="k">Input array <paramref name="k" />.</param>
      <returns>An array of same size as <paramref name="n" /> and <paramref name="k" /> with values of the binomial coefficients.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="n" />i &lt; <paramref name="k" />i, the solution will be double.NaN.</item>
          <item>If any elements in <paramref name="n" /> and <paramref name="k" /> has the same value, the solution will be +1.0.</item>
          <item>If any elements in <paramref name="n" /> or <paramref name="k" /> has a negative value, the solution will be double.NaN.</item>
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If n and k size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.gammaIncomplete(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the lower incomplete Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Incomplete_gamma_function">Wikipedia - Incomplete gamma function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <param name="a">The parameter of Gamma.</param>
      <returns>The value of the lower incomplete Gamma function.</returns>
      <remarks>
        <list type="bullet">
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If x is empty, an empty array will be returned.</item>
          <item>If any of the given points is NaN or Infinity an ArgumentException will be thrown.</item>
          <item>If any elements in <paramref name="x" /> is negative, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.betaIncomplete(System.Double,System.Double,ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the incomplete Beta function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function">Wikipedia - Incomplete beta function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated. <paramref name="x" />  must be in [0,1].</param>
      <param name="a">A scalar, first parameter of the incomplete Beta function.</param>
      <param name="b">A scalar, second parameter of the incomplete Beta function.</param>
      <returns>The value of the incomplete Beta function at a given point.</returns>
      <remarks>
        <list type="bullet">
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If x is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi &gt; 1</c> and <c>xi &lt; 1</c>, double.NaN will be returned at that element.</item>
          <item>If any element of x is <c>xi == 0</c>, 0.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == 1</c>, 1.0 will be returned at that element.</item>
          <item>If a or b is negative, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.errorFunction(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function">Wikipedia - Error function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>The value of the error function at the given point <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, +1.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NegativeInfinity</c>, -1.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NaN</c>, double.NaN will be returned at that element.</item>
          <item>If </item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.errorFunctionComplement(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates of the complementary (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function">Wikipedia - Complementary Error function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>The value of the complementary error function at the given point <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NegativeInfinity</c>, +2.0 will be returned at that element.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.errorFunctionInverse(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the inverse of the (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function#Inverse_functions">Wikipedia - Inverse Error function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the inverse error function at the given point <paramref name="x" />.</returns>&gt;
            <remarks><list type="bullet"><item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item><item>If <paramref name="x" /> is empty, an empty array will be returned.</item><item>If any element of x is <c>xi &gt;= +1.0</c>, double.PositiveInfinity will be returned at that element.</item><item>If any element of x is <c>xi &lt;= -1.0</c>, double.NegativeInfinity will be returned at that element.</item></list><para>[ILNumerics Computing Engine]</para></remarks></member>
    <member name="M:ILNumerics.ILMath.logistic(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the sigmoid logistic function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Logistic_function">Wikipedia - Logistic function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, +1.0 will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.NegativeInfinity</c>, 0.0 will be returned at that element.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <returns>The value of the logistic function at the given point <paramref name="x" />.</returns>
    </member>
    <member name="M:ILNumerics.ILMath.logit(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the inverse of the sigmoid logistic function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Logit_function">Wikipedia - Logit function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">point defined between 0 and 1.</param>
      <returns>The logarithm of <paramref name="x" /> divided by 1.0 - <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi ≥ 1.0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi ≤ 0.0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 1.0</c>, double.PositiveInfinity will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned at that element.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJ0(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 1.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJ1(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJn(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Evaluates the Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselY0(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselY1(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselYn(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Evaluates the Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedI0(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedI1(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedIn(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedK0(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedK1(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedKn(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJ0(ILNumerics.ILInArray{System.Single})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 1.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJ1(ILNumerics.ILInArray{System.Single})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJn(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Evaluates the Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselY0(ILNumerics.ILInArray{System.Single})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselY1(ILNumerics.ILInArray{System.Single})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselYn(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Evaluates the Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedI0(ILNumerics.ILInArray{System.Single})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedI1(ILNumerics.ILInArray{System.Single})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedIn(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedK0(ILNumerics.ILInArray{System.Single})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedK1(ILNumerics.ILInArray{System.Single})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedKn(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diGamma(ILNumerics.ILInArray{System.Double})">
      <summary>
            Computes the Digamma function which is mathematically defined as the derivative of the logarithm of the gamma function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Digamma_function">Wikipedia - Digamma function</a>
            and <a href="http://mathworld.wolfram.com/DigammaFunction.html">Wolfram MathWorld - Digamma function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="xi">The point where the function is evaluated.</param>
      <returns>The value of the DiGamma function at <paramref name="xi" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="xi" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="xi" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.NaN</c> or <c>xi == double.NegativeInfinity</c>, there will be a double.NaN returned at that element.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, there will be a double.PositiveInfinity returned at that element.</item>
          <item>If any element of x is <c>xi &lt; 0</c> and is a round number, there will be a double.NegativeInfinity returned at that element.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMath.Lapack">
      <summary>
            Concrete interface wrapper class providing the native LAPACK functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>The LAPACK wrapper will be initialized the first time, 
            a call to any static method of ILMath is made. The decision, which 
            native module to load is done by use of native CPUID assembly statements.
            If the current processor does not support those calls or is not recognizable
            by ILNumerics, a generic - not optimized - version of native LAPACK code will
            be used than.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILMath.FFTImplementation">
      <summary>
            Platform specific FFT implementation, <b>internally</b> used to compute fft
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMath.BuildDate">
      <summary>
            The date of the build of this module
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMath.end">
      <summary>
            Substitute for the index of the last element of a dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>The 'end' placeholder can be used in subarray specification expressions. It will get 
            evaluated in a delayed manner, once the index of the dimension (and therefore the dimension length)
            is known. It than evaluates to the number of the index of the last element in the dimension.
            <para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILMath.eps">
      <summary>
            Double precision epsilon - the smallest difference from 1.0
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMath.epsf">
      <summary>
            Single precision epsilon - the smalles difference from 1.0f
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMath.MachineParameterDouble">
      <summary>
            Give extensive numerical machine parameter informations - double precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMath.MachineParameterSingle">
      <summary>
            Give extensive numerical machine parameter informations - single precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMath.full">
      <summary>
            Address the whole dimension for subarray access
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.sinc(System.Int32,System.Int32,System.Single)">
      <summary>
            Generate sinc function in 2D, useful for plotting examples
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="cols">Number of columns</param>
      <param name="periods">Influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
      <returns>Matrix with sinc data in 2 dimensions</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.sinc(System.Int32,System.Int32)">
      <summary>
            Generate sinc function in 2D, useful for plotting examples
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="cols">Number of columns</param>
      <returns>Matrix with sinc data in 2 dimensions</returns>
      <remarks>The function generates 4 zero crossings in each direction<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.sincf(System.Int32,System.Int32)">
      <summary>
            Generate sinc function in 2D, single precision, useful for plotting examples
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="cols">Number of columns</param>
      <returns>Matrix with sinc data in 2 dimensions</returns>
      <remarks>The function generates 4 zero crossings in each direction<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.sincf(System.Int32,System.Int32,System.Single)">
      <summary>
            Generate sinc function in 2D, useful for plotting examples
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="cols">Number of columns</param>
      <param name="periods">Influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
      <returns>Matrix with sinc data in 2 dimensions</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.sincos1D(System.Int32,System.Double)">
      <summary>
            Create specified periods of sine and cosine data
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="numSamples">Number of samples</param>
      <param name="periods">Number of (full) periods to be generated, must be &gt; 0</param>
      <returns>Matrix with sine data in first column, cosine data in second column</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.sincos1Df(System.Int32,System.Double)">
      <summary>
            Create specified periods of sine and cosine data, single precision
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="numSamples">Number of samples</param>
      <param name="periods">Number of (full) periods to be generated, must be &gt; 0</param>
      <returns>Matrix with sine data in first column, cosine data in second column</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.waterfall(System.Int32,System.Int32)">
      <summary>
            Create demo data for surface plots looking like a waterfall
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="cols">Number of columns</param>
      <returns>Matrix with data showing a waterfall terrain. </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.waterfallf(System.Int32,System.Int32)">
      <summary>
            Create demo data for surface plots looking like a waterfall
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="cols">Number of columns</param>
      <returns>Matrix with data showing a waterfall terrain. </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.sphere(System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Create surface data of a sphere
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="n">Number of facettes per angle</param>
      <param name="X">[Output] X coords</param>
      <param name="Y">[Output] Y coords</param>
      <param name="Z">[Output] Z coords</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.moebius(System.Int32,System.Double,System.Double,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Create surface data for a Möbius strip
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="n">Granularity (number of facettes)</param>
      <param name="w">Width</param>
      <param name="R">Radius</param>
      <param name="X">[Output] X coords</param>
      <param name="Y">[Output] Y coords</param>
      <param name="Z">[Output] Z coords</param>
      <remarks>Möbius strip is a surfcae, crated by cutting a regular strip, twisting one end by 180 deg and glueing 
            both ends together again.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSpecialData.torus(System.Single,System.Single,System.Int32,System.Int32)">
      <summary>
            Create torus cartesian coordinates, to be used for surface plotting
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="outerRadius">[optional] the outer radius of the torus ring, default: 0.75</param>
      <param name="innerRadius">[optional] the inner radius of the torus ring, default: 0.25</param>
      <param name="stepsPoloidal">[optional] number of grid points in poloidal direction, default: 100</param>
      <param name="stepsToroidal">[optional] number of grid points in toroidal direction, default: 100</param>
      <returns>Data array with cartesian coordinates of the torus gris points. </returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILSpecialData.terrain">
      <summary>
            Get example terrain data, 401 x 401 short matrix with heights in meters
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics_Licensing.ILLicHelper_3a22bfd55dff48d9b870040f3478daf2_">
      <summary>
            This type supports ILNumerics infrastructure. Do not edit the code!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>This type is automatically generated by ILNumerics Ultimate VS. If you encounter problems compiling this file, make sure to reference ILNumerics.Core in your project!<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
  </members>
</doc>
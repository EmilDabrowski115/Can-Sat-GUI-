<doc>
  <assembly>
    <name>ILNumerics.Core</name>
  </assembly>
  <members>
    <member name="T:ILNumerics.Misc.ILBucketSort">
      <summary>
            Bucket sort algorithm (for internal use)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This class is not intended to be used directly. Sorting functionality is supplied by <see cref="M:ILMath.sort(ILInArray{double})" /><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILBucketSort.BucketSort``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``2},ILNumerics.Algorithms.ILKeyMapper{``0,``1},ILNumerics.Misc.ILBucketSort.SortMethod)">
      <summary>
            Bucket sort algorithm
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input"></param>
      <param name="indices">Return corresponding source element indices</param>
      <param name="mapper"></param>
      <param name="method"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILBucketSort.SortMethod">
      <summary>
            Sort method for bucket sorts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Misc.ILBucketSort.SortMethod.ConstantLength">
      <summary>
            Constant length
            </summary>
    </member>
    <member name="F:ILNumerics.Misc.ILBucketSort.SortMethod.VariableLenth">
      <summary>
            Variable length
            </summary>
    </member>
    <member name="T:ILNumerics.Algorithms.ILKeyMapper`2">
      <summary>
            Key mapper class, to be overriden for user defined classes to be sorted with bucket sort
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="ElementType">Type of elements. Elements are constructed out of any number of subelements</typeparam>
      <typeparam name="SubelementType">Type of subelements</typeparam>
      <remarks>This class can be extended to enable sorting (bucket sort) for arbitrary types. The elements of those types may be devidable into subelements.
            <para>Examples of sortable classes:
            <list><item>colors: number/type of subelements: 1/any (e.g. the color code). One should write a <![CDATA[ILKeyMapper<Color,int>]]>.</item><item>strings: number/type of subelements: arbitrary/char. Here a sample ILASCIKeyMapper implementation exists already. This implementation is the default implementation used for bucket sort via ILMath.sort().</item><item>trees: number/type of subelements: arbitrary/tree nodes. One should write a key mapper to map a node of a tree to a bucket number</item><item>...</item></list></para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`1)">
      <summary>
            Maps subelement types to bucket index
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="inSubelement">Item</param>
      <returns>Bucket index</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`0,System.Int32,System.Int32)">
      <summary>
            Map subelemt - provide fallback on error
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">Element item</param>
      <param name="position">Position of subelement in element item to be mapped</param>
      <param name="fallback">If position is out of range, give back fallback</param>
      <returns>Mapped bucket for subelement or fallback on error</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.SubelementsCount(`0)">
      <summary>
            Count subelements in an element
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element"></param>
      <returns></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.GetSubelement(`0,System.Int32)">
      <summary>
            Get subelement from element item
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">Element item</param>
      <param name="idx">Position of subitem in element</param>
      <returns>Subitem referenced</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.#ctor(System.Int32)">
      <summary>
            Construct key mapper
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="NumberOfKeys">Maximm number of different subitems (keys)</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Algorithms.ILKeyMapper`2.NumberOfKeys">
      <summary>
            Maximum number of keys (different subitems)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Algorithms.ILASCIIKeyMapper">
      <summary>
            Concrete implementation of a key mapper for strings
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>this class is the default key mapper, used for bucket sort on strings<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.Char)">
      <summary>
            map subelement to bucket
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="inSubelement">subelement to be mapped</param>
      <returns>ASCII code of the subelement character</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.String,System.Int32,System.Int32)">
      <summary>
            Map char out of string with fallback
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">full string item</param>
      <param name="position">position of character in string</param>
      <param name="fallback">fallback bucket number, if position is out of range</param>
      <returns>ASCII code for character specified, fallback on error</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.GetSubelement(System.String,System.Int32)">
      <summary>
            give one char from string
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">full string item</param>
      <param name="idx">character position in string</param>
      <returns>character in string</returns>
      <exception cref="T:System.IndexOutOfRangeException"> if idx is not within element ranges</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.SubelementsCount(System.String)">
      <summary>
            Count numer of characters in string
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">element item</param>
      <returns>number of characters in string - length of string</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.#ctor">
      <summary>
            construct ASCII key mapper for 256 buckets
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Algorithms.ILIntLimitedKeyMapper">
      <summary>
            Integer key mapper - sample implementation for bucket sort
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This mapper may be used for sorting integers with bucketsort. 
            <para>The integers to be sorted must be positive and limited. It corresponds to the number of buckets to be created.</para><para>This implementation serves as a sample implementation for bucket sort. You should consider using quicksort instead, which is implemented for ILMath.sort()</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.GetSubelement(System.Int32,System.Int32)">
      <summary>
            Gives subelement - i.e. the element itself
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">element</param>
      <param name="idx">(ignored)</param>
      <returns>element</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32,System.Int32,System.Int32)">
      <summary>
            map element - ignoring position &amp; fallback
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">integer element</param>
      <param name="position">(ignored)</param>
      <param name="fallback">(ignored)</param>
      <returns>integer element</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32)">
      <summary>
            map (copy) subelement
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="inSubelement">subelement</param>
      <returns>subelement</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.SubelementsCount(System.Int32)">
      <summary>
            number of subelements in an element (Here: always 1)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">element</param>
      <returns>1</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.#ctor(System.Int32)">
      <summary>
            construct integer key mapper
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="limit">maximum number of buckets to be used</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILListItem`2">
      <summary>
            List items to be used in ILQueueList
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T1">Data type</typeparam>
      <typeparam name="T2">Index type</typeparam>
      <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0)">
      <summary>
            construct list item by data
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="item">item data</param>
      <remarks>the indet will be set to its default value<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0,`1)">
      <summary>
            construct list item, takes item data and index
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="item">item data</param>
      <param name="index">index</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILListItem`2.Index">
      <summary>
            index stored with this item
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILQueueList`2">
      <summary>
            Queuelist - a queue with partial list properties
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T1">data type</typeparam>
      <typeparam name="T2">index type</typeparam>
      <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0,`1)">
      <summary>
            add indexed item at end of queue
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0)">
      <summary>
            add item at end of queue
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILListItem{`0,`1})">
      <summary>
            add item at end of queue
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILQueueList{`0,`1})">
      <summary>
            add queue list to end of this queue list
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="list">queue list to be added</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.Dequeue">
      <summary>
            Remove from start of queue
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>item from start of queue</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(`0)">
      <summary>
            Add to start of queue
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="item">item data to add to start of queue</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(ILNumerics.Misc.ILQueueList{`0,`1})">
      <summary>
            concatenate 2 queuelists
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="qlist">queue list to be added at start of this queuelist</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.Sort``1(ILNumerics.Algorithms.ILKeyMapper{`0,``0})">
      <summary>
            sort utilizing bucket sort
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="SubelementType">subelement type</typeparam>
      <param name="mapper">keymapper mapping subelement items to buckets</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.ToArray">
      <summary>
            convert (copy) items to system array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>system array with items</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.Clear">
      <summary>
            Clear this queue list from all elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.GetEnumerator">
      <summary>
            Create enumerator utilizing 'foreach'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>enumerator for contained elements</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQueueList`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            gives enumerator for internal list items (ILListItem)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>ILListItem's</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILQueueList`2.Count">
      <summary>
            number of items currently in the queue (readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILQueueList`2.ListItems">
      <summary>
            Gives enumerator for contained items (ILListItem)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILQuickSort">
      <summary>
            This class provides a number of one dimensional quicksort implementations for several datatypes/ properties
            <para>[ILNumerics Core Module]</para>
      </summary>
      <summary>
            the class provides a number of one dimensional quicksort implementations for several datatypes/ properties
            </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Double[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Double[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.Double*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.UInt64[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.UInt64[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.UInt64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.UInt64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.UInt64*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.UInt32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.UInt32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.UInt32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.UInt32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.UInt32*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.UInt16[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.UInt16[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.UInt16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.UInt16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.UInt16*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Int64[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Int64[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Int64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Int64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.Int64*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.Int32*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Int16[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Int16[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Int16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Int16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.Int16*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Single[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Single[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.Single*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(ILNumerics.fcomplex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(ILNumerics.fcomplex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(ILNumerics.fcomplex*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(ILNumerics.complex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(ILNumerics.complex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(ILNumerics.complex*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Char[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Char[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Char[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Char[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.Char*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Byte[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Byte[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Byte[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Byte[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort" />. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()" /> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
        <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortDesc(double[], int, int, int)" /></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAsc_ITMT_noNaN(System.Byte*,System.Int32,System.Int32,System.Int32)">
      <summary>
            This sorts large _vectors_ via ThreadPool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vec"></param>
      <param name="lo"></param>
      <param name="hi"></param>
      <param name="inc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Int32*,System.Double*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Int32*,System.Double*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,System.Double*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,System.Double*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Int32*,System.Single*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Int32*,System.Single*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,System.Single*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,System.Single*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Int32*,ILNumerics.fcomplex*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Int32*,ILNumerics.fcomplex*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,ILNumerics.fcomplex*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,ILNumerics.fcomplex*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Int32*,ILNumerics.complex*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Int32*,ILNumerics.complex*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,ILNumerics.complex*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,ILNumerics.complex*)">
      <summary>
            sort nan elements to the end, test if the array is already sorted
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true, if already sorted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Double[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Double[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.UInt64[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.UInt64[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.UInt64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.UInt64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.UInt32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.UInt32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.UInt32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.UInt32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.UInt16[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.UInt16[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.UInt16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.UInt16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Int64[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Int64[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Int64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Int64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Int16[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Int16[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Int16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Int16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Single[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Single[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(ILNumerics.fcomplex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(ILNumerics.fcomplex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(ILNumerics.complex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(ILNumerics.complex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Char[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Char[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Char[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Char[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Byte[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Byte[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Byte[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Byte[],System.Int32[],System.Int32,System.Int32,System.Int32)">
      <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
      <param name="lo">lowest index of sorting range</param>
      <param name="hi">highest index of sorting range</param>
      <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP" /></param>
      <param name="inc">spacing between elements (dimension specifier)</param>
      <remarks>
        <para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" /> and above. 
            Below that length, a simple insertion sort is used instead.</para>
        <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" />.</para>
        <para>
          <b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILArray`1">
      <summary>
             The main rectilinear array to be used in algorithms
             <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="ElementType">Inner type. This will mostly be one of the predefined numeric <see cref="!:System.Value" /> 
             types or one of the complex ILNumerics floating point types: <see cref="T:ILNumerics.complex" /> and <see cref="T:ILNumerics.fcomplex" />.</typeparam>
      <remarks>This class serves as the main rectilinear array, holding arbitrary elements (usually numeric types) 
             in arbitrary dimensions.
             <para>Arrays of this type may use any type as generic element. However, common mathematical functions and operators 
             are defined for a limited number of inner types only. All binary operations (+,-,*,/,<![CDATA[<,>,<=]]>,etc.) are 
             defined for two arrays with the same <i>numeric type</i>, would it be from the <c>System</c> namespace (<c>double</c>, 
             <c>int</c>,...) or <c>ILNumerics.complex</c>/ <c>ILNumerics.fcomplex</c>. Most algebraic functions require floating point 
             types. See the <see cref="!:ILNumerics.ILMath" /> class for a list of all computational functions.</para><para>Arrays are capable of creating flexible <a href="http://ilnumerics.net/$Subarray0.html" target="ILMain">subarrays</a> 
             and are mutable at runtime. Read about all details of ILNumerics arrays in the 
             <a href="http://ilnumerics.net/$Arrays.html" target="ILMain">ILNumerics Array documentation</a>.</para><para>Arrays of this type are dense arrays. Cloning arrays is done as lazy 
             copy on write, i.e.: clones of existing arrays do only use new memory when attempting to alter one of them. Arrays integrate into the memory 
             management of ILNumerics. Read about the most <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">important 
             simple rules</a> for using arrays in custom computational functions.</para><para>Arrays come with overloaded mathematical operators, allowing for a convenient syntax. A 
             sophisticated memory management in the back will make sure, that as little memory as needed is used, even in 
             expressions like: a + c * 2 / abs(sin(c) * -b / log(a)). Here all arrays are of the same size. Evaluating 
             this expression does only need the memory of twice the size of one array. Memory gets collected and reused 
             for every subexpression evaluation. Further optimization options exist, as described in 
             <a href="http://ilnumerics.net/$PerfMemoryOpt.html" target="ILMain">Optimizing Algorithm Performance</a>.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <para>A simple example demonstrating some uses of arrays in a very simple application:</para>
        <code>using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using ILNumerics; 
            
            
            namespace ConsoleApplication1 {
                class Program : ILMath {
                    static void Main(string[] args) {
                        ILArray&lt;double&gt; A = rand(10,20);
                        ILArray&lt;double&gt; B = A * 30 + 100; 
                        ILLogical C = any(multiply(B,B.T)); 
                        Console.Out.Write(-B); 
                        Console.ReadKey(); 
                    }
                }
            }
            </code>
      </example>
      <seealso cref="T:ILNumerics.ILLogical" />
      <seealso cref="T:ILNumerics.ILCell" />
      <seealso href="http://ilnumerics.net/$Arrays.html" />
      <seealso href="http://ilnumerics.net/$GeneralRules.html" />
      <seealso href="http://ilnumerics.net/$Subarray0.html" />
    </member>
    <member name="T:ILNumerics.ILDenseArray`1">
      <summary>
            This type is used internally. It provides a common base type for rectilinear arrays with dense storage layouts.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="ElementType">Element type</typeparam>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILBaseArray`1">
      <summary>
            Typed base class for all ILNumerics data storage classes for any storage type.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>You should not use this type directly. It serves as a base class 
            for all typed storages only and will be used by derived classes like ILArray<![CDATA[<>]]>.</para>
        <para>If you are looking for an (untyped) base class to be used as generic class for any ILArray types, you should use ILBaseArray instead!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILBaseArray">
      <summary>
            Base type for all arrays of ILNumerics. This class serves internal purpose and is usually not directly used.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>All numerical arrays derive from ILBaseArray. ILBaseArrays itself 
            cannot be instantiated. Currently, the only specialized array type existing in ILNumerics is ILArray<![CDATA[<T>]]>. It describes 
            a rectilinear dense array. There is the option (and  low priority plan) to 
            extend the collection of derived array types to encompass triangular, diagonal and sparse arrays. 
            <para>[ILNumerics Core Module]</para></remarks>
      <threadsafety static="true" instance="false" />
      <seealso href="http://ilnumerics.net/FunctionRules.html" />
    </member>
    <member name="F:ILNumerics.ILBaseArray.m_name">
      <summary>
            Name of this array
            </summary>
    </member>
    <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Double)~ILNumerics.ILBaseArray">
      <summary>
            Implicit cast from scalar of typeof(a) to <c>ILRetArray&lt;typeof(A)&gt;</c>
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Input scalar</param>
      <returns>A ILRetArray of same type as <paramref name="a" /> and size 1x1</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.complex)~ILNumerics.ILBaseArray">
      <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Input scalar</param>
      <returns>A ILRetArray of same type as <paramref name="a" /> ans size 1x1</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.fcomplex)~ILNumerics.ILBaseArray">
      <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Input scalar</param>
      <returns>A ILRetArray of same type as <paramref name="a" /> ans size 1x1</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.String)~ILNumerics.ILBaseArray">
      <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="s">Input scalar</param>
      <returns>A ILRetArray of same type as <paramref name="s" /> and size 1x1</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Double[])~ILNumerics.ILBaseArray">
      <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Input scalar</param>
      <returns>A ILRetArray of same type as <paramref name="a" /> ans size 1x1</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.Equals(System.Object)">
      <summary>
            Compare elements and shape of this array with another array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Other array</param>
      <returns>true if shape and element values of both arrays match, false otherwise</returns>
      <remarks>
        <para>'Equals' accepts two vectors even if the orientations do not match. Therefore, a row vector 
            with the same element values than another column vector would be considered equal to each other.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.GetHashCode">
      <summary>
            Generate a hash code based on the current arrays values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Hash code</returns>
      <remarks>The hashcode is created by taking the values currently stored in the array into account.
            Therefore, the function iterates over all elements in the array - which makes it somehow an expensive 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.Clone">
      <summary>
            Clone this array (shallow)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>ILBaseArray as new representation of this storages data.</returns>
      <remarks>The object returned will be of the same size than this array.
            This this is a 'shallow' copy only! I.e., if elements are copied only. If they are 
            references to any objects, those objects are not replicated.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
      <summary>
            Print values of this instance to a stream.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outStream">Stream to write the values into.</param>
      <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)" /> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
      <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags" />. Specifies the way 
            the values will be serialized.</param>
      <remarks>
        <para>If method 'Formatted' is used, any occurences of NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style for the output.</para>
        <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as 
            the array name for writing. This array instance will be the only array in the mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.ToString">
      <summary>
            Convert to string
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>String representation of content</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.ToString(System.Int32)">
      <summary>
            Convert to string with limited length
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="maxLength">Maximal length of returned string; set to 0 to not limit result</param>
      <returns>String representation of content</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.ShortInfo">
      <summary>
            Short textual summary of this instance, used for debug output
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>String representation of type and size</returns>
      <remarks>The type of elements and the size of the array are displayed. If the array
            is scalar, its value is displayed next to the type.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.Dispose">
      <summary>
            Dispose this array and all its content
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.GetElementType">
      <summary>
            Gets the System.Type of the elements stored in this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Sytem.Type of the generic argument of concreate subclass instances</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray.GetStorageHandle">
      <summary>
            Get a GC handle for the underlying storage system array for unsafe operations. CAUTION! Use at own risk!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>GCHandle with address of first element of the pinned underlying one dimensional system storage or an un-allocated handle if this storage cannot get accessed.</returns>
      <remarks>This method is provided to give users a generic way to access the underlying system array for unsafe (native) operations. Extreme care must be taken when 
            using this method. Therefore, it is not recommended for 'everyday' use. Users must not forget to free the handle as soon as possible after use!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsDisposed">
      <summary>
            Determine if this array has been disposed already. Disposed arrays should not be used.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.Size">
      <summary>
            Size descriptor specification
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.Dimensions">
      <summary>
            [deprecated] Use 'Size' as size descriptor!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.S">
      <summary>
            Size descriptor shortcut
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.D">
      <summary>
            [deprecated] Use 'S' as size descriptor!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.Length">
      <summary>
            Length of the longest dimension of this instance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This property is readonly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.Name">
      <summary>
            Gets the name of this array or sets it
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsScalar">
      <summary>
            Test if this instance is a scalar
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsMatrix">
      <summary>
            Test if this instance is a matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must be at most 2. This attribute is readonly.
            <para>Keep in mind that all ILArrays have at least 2 dimensions. Therefore, vectors and 
            scalar arrays are considered a matrix of size [n,1] / [1,n] or [1,1].</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsVector">
      <summary>
            Test if this array is a vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsRowVector">
      <summary>
            Test if this array instance is a row vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsColumnVector">
      <summary>
            Test if this array instance is a column vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsEmpty">
      <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsComplex">
      <summary>
            Determine if this array is of complex inner type.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray.IsNumeric">
      <summary>
            Determine if this array is of numeric inner type.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.Serialize(System.IO.Stream)">
      <summary>
             Serialize this array into a binary stream.
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
      <returns>True on success, false on error.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.Deserialize(System.IO.Stream)">
      <summary>
            Deserialize / restore array from binary stream 'inStream'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="inStream">System.IO.Stream to reconstruct the 
            array from</param>
      <returns>Array reconstructed from stream.</returns>
      <exception cref="T:System.Runtime.Serialization.SerializationException">If the array could not get restored</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.GetValue(System.Int32[])">
      <summary>
            Get single element from this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Indices, location of element</param>
      <returns>The selected value</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@)">
      <summary>
            Get minimum and maximum value of all elements - if any
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="min">[Output] Minimum value</param>
      <param name="max">[Output] Maximum value</param>
      <returns>true if the limits exists and could be computed, false otherwise</returns>
      <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@,System.Boolean)">
      <summary>
            Get minimum and maximum value of all elements - if any
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="min">[Output] Minimum value</param>
      <param name="max">[Output] Maximum value</param>
      <param name="includeInfNaNs">true: recognize Inf, NaN values; false: ignore those values</param>
      <returns>true if the limits exists and could be computed, false otherwise</returns>
      <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.GetElementType">
      <summary>
            Gets the System.Type of the elements stored in this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Sytem.Type of the generic argument of concreate subclass instances</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.System#Collections#Generic#IEnumerable{ElementType}#GetEnumerator">
      <summary>
            Enumerator returning elements as ElementType
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Enumerator</returns>
      <remarks>This method enables the us of ILNumerics arrays in foreach loops.
            <para>This iterator implements IEnumerable&lt;ElementType&gt; explicitely and is used in situations, 
            where instances of ILNumerics arrays are casted to instances of the IEnumerable interface. This iterator 
            is not integrated into the ILNumerics memory management.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Enumerator returning elements as ElementType
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Enumerator</returns>
      <remarks>This method enables the use of ILNumerics arrays in foreach loops directly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseArray`1.GetEnumerator">
      <summary>
            Enumerator returning elements as ElementType
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Enumerator</returns>
      <remarks>This method enables the use of ILNumerics arrays in foreach loops directly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray`1.IsComplex">
      <summary>
            Determine if this array has complex elements.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray`1.IsNumeric">
      <summary>
            Determine if this array holds numeric values.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table"><listheader><term>inner type</term></listheader><item><term>System.double</term><description>floating point, real, 8 bytes </description></item><item><term>System.float</term><description>floating point real, 4 bytes</description></item><item><term>ILNumerics.complex</term><description>floating point complex, 16 bytes</description></item><item><term>ILNumerics.fcomplex</term><description>floating point complex, 8 bytes</description></item><item><term>System.char</term><description>integer, real, 1 byte</description></item><item><term>System.byte</term><description>integer, real, 1 byte</description></item><item><term>System.Int16</term><description>integer, real, 2 byte</description></item><item><term>System.Int32</term><description>integer, real, 4 byte</description></item><item><term>System.Int64</term><description>integer, real, 8 byte</description></item><item><term>System.UInt16</term><description>unsigned integer, real, 2 byte</description></item><item><term>System.UInt32</term><description>unsigned integer, real, 4 byte</description></item><item><term>System.UInt64</term><description>unsigned integer, real, 8 byte</description></item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseArray`1.Storage">
      <summary>
            Access to internal typed storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.GetArrayForRead">
      <summary>
            Get direct reference to inner System.Array storage for <b>read access</b> - use with care!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Reference to inner System.Array for reading</returns>
      <remarks>This method is provided for experts only! Altering elements of this 
            array may cause the data to be invalidated or corrupted! Use this array only for reading! Note 
            the ILNumerics array storage format (column major). Keep in mind, the length 
            of the internal system array T[] may exceeds the number of elements in this ILNumerics array! 
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;!</para><para>Unlike other member functions of ILNumerics arrays, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You will have to keep 
            track of the reference yourself. As a rule of thumb, the reference is only valid within the current 
            ILNumerics scope, which <a href="http://ilnumerics.net/FunctionRules.html">obligatory for all function bodies</a>. 
            If the reference is used outside of the current 
            ILNumerics scope, the behavior is undefined. It is likely that the reference will address the storage of 
            another ILNumerics array already by then!</para><para>Furthermore, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.Clone">
      <summary>
            Clone of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
        <para>The clone returned will be of the same type as this instance.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.Concat(ILNumerics.ILInArray{`0},System.Int32)">
      <summary>
            Concatenate this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">N-dimensional array. Except for dimensions <paramref name="dim" />
            the dimensions of A must match the dimensions of this storage</param>
      <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
      <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.ExportValues(`0[]@)">
      <summary>
            Copy values of all elements into System.Array.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
      <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.GetEnumerator">
      <summary>
            Enumerator returning elements as ElementType
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Enumerator</returns>
      <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>ILArray&lt;double&gt; A = rand(5,4,6);
            foreach (double element in A) {
                // all elements are scalar double values
                String.Format("Element: {0} ", element);
                // Note: 'element' cannot be used to alter the collection! 
            } </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.GiveStorageAwayOrClone">
      <summary>
            Gives away internal storage for further use (e.g. in ILArray), disposes this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Internal storage</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.Repmat(System.Int32[])">
      <summary>
            Create replication of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims" /> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
      <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims" /></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.Reshape(ILNumerics.ILSize)">
      <summary>
            Reshaped copy of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">New dimensions of the array</param>
      <returns>Reshaped copy of the array</returns>
      <remarks>
        <para>The current instance will not be changed. A new storage is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in <paramref name="dimensions" />
            do not match the number of elements in this array.</exception>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.Reshape(System.Int32[])">
      <summary>
            Reshaped copy of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">New dimensions of the array</param>
      <returns>Reshaped copy of the array</returns>
      <remarks>
        <para>The current instance will not be changed. A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this array.</exception>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.Subarray(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray creation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Range specification, defining the size of the subarray</param>
      <returns>Subarray as copy of a part of this array</returns>
      <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.Shifted(System.Int32)">
      <summary>
            Create array from this array and shift dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">Number of dimensions to shift</param>
      <returns>Shifted version of this array</returns>
      <remarks>
        <para>The shift is done 'to the left':</para>
        <example>
          <code>ILArray&lt;double&gt; A = zeros(2,4); 
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2]
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1);
            // D is now: &lt;double&gt; [4,3,2]
            </code>
        </example>
        <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
        <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T" /> property for readability.</para>
        <para>
          <paramref name="shift" /> must be positive. It is taken modulus the number of dimensions.</para>
        <seealso cref="P:ILNumerics.ILDenseArray`1.T" />
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
      <summary>
            Send values of this instance to stream.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="stream">Stream to write the values into.</param>
      <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)" /> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
      <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags" />. Specifies the way in which
            the values will be serialized.</param>
      <remarks>
        <para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
        <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.TryGetStorage4InplaceOp(`0[]@)">
      <summary>
            Give that storage away for in-place operations, if possible (depends on scope and temp type of array)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true if the storage of the array is about to get disposed anyway</returns>
      <remarks>The function investigates the state of the array. If this is a temporary array in 
            the outer most scope, it would get disposed after the <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_Subtraction(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            Elementwise subtraction operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result of subtraction</returns>
      <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:System.InvalidOperationException">If the array elements are of an unsupported type</exception>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_Addition(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            Elementwise addition operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result of addition</returns>
      <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:System.InvalidOperationException">If the array elements are of an unsupported type</exception>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_Multiply(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            Elementwise multiplication operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result of multiplication</returns>
      <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:System.InvalidOperationException">If the array elements are of an unsupported type</exception>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_Division(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            Elementwise division operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result of division</returns>
      <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:System.InvalidOperationException">If the array elements are of an unsupported type</exception>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_Modulus(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            Elementwise modulus operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result of modulus operation</returns>
      <remarks>The operator is defined for 2 arrays of the same numeric real element types: double, float, int, long, byte.<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:System.InvalidOperationException">If the array elements are of an unsupported type</exception>
    </member>
    <!-- Badly formed XML comment ignored for member "M:ILNumerics.ILDenseArray`1.op_LeftShift(ILNumerics.ILDenseArray{`0},System.Int32)" -->
    <!-- Badly formed XML comment ignored for member "M:ILNumerics.ILDenseArray`1.op_RightShift(ILNumerics.ILDenseArray{`0},System.Int32)" -->
    <member name="M:ILNumerics.ILDenseArray`1.op_Equality(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            'Equalty' operator of two arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Logical array of same size than A and B, result of operation along all elements</returns>
      <remarks>Sizes and types of A and B must match.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_Inequality(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            'unequalty' operator of two arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Logical array of same size than A and B, result of operation along all elements</returns>
      <remarks>Sizes and types of A and B must match.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_GreaterThanOrEqual(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            'greater or equal' operator of two arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Logical array of same size than A and B, result of operation along all elements</returns>
      <remarks>Sizes and types of A and B must match.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_LessThanOrEqual(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            'smaller or equal' operator of two arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Logical array of same size than A and B, result of operation along all elements</returns>
      <remarks>Sizes and types of A and B must match.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_GreaterThan(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            'greater' operator of two arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Logical array of same size than A and B, result of operation along all elements</returns>
      <remarks>Dimension and types of A and B must match.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_LessThan(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
      <summary>
            'smaller' operator of two arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Logical array of same size than A and B, result of operation along all elements</returns>
      <remarks>Dimension and types of A and B must match.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_Explicit(ILNumerics.ILDenseArray{`0})~`0">
      <summary>
            Explicitly convert scalar array to System.Value type (ElementType)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">Array of arbitrary type and size of 1x1</param>
      <returns>Single value of type ElementType and of scalar size (1x1)</returns>
      <exception cref="T:ILNumerics.Exceptions.ILCastException">If input array is not scalar</exception>
      <exception cref="T:System.NullReferenceException">If val is null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_Implicit(`0)~ILNumerics.ILDenseArray{`0}">
      <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">Single element of ElementType type</param>
      <returns>New array of type ILRetArray<![CDATA[<ElementType>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_UnaryNegation(ILNumerics.ILDenseArray{`0})">
      <summary>
            Negate elements of array - if applicable.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>New dense arrray having the elements of A inverted.</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If elements of the array are not of 
            any supported numeric type</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILDenseArray`1.op_OnesComplement(ILNumerics.ILDenseArray{`0})">
      <summary>
            Bitwise negation of array elements.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Arrray of the same size as A having the bits of the elements inverted.</returns>
      <remarks>Supported types: int, uint, long, ulong, sbyte, byte<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A is not of 
            any supported numeric element type.</exception>
    </member>
    <member name="P:ILNumerics.ILDenseArray`1.Storage">
      <summary>
            internal access to the underlying storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILDenseArray`1.C">
      <summary>
            Clone of this array (fast, lazy and shallow)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILDenseArray`1.T">
      <summary>
            Return transposed version of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>For matrices, this swaps columns with rows. For arrays, the dimensions are shifted by one.
            <para>Note, for complex elements, <b>no</b> conjugate is created! Use conj(A.T) if this is intended.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILDenseArray`1.MaxValue">
      <summary>
             [deprecated] Get maximum value of array - if any
             <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This property is marked as deprecated and will be removed in a future version. Use one of the 
            following alternatives instead: 
            <para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@)" />
    </member>
    <!-- Badly formed XML comment ignored for member "P:ILNumerics.ILDenseArray`1.MinValue" -->
    <member name="P:ILNumerics.ILDenseArray`1.ReferenceCount">
      <summary>
            Get number of arrays, referencing the same underlying data storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <return>This number is always greater than or equal to 1.</return>
      <remarks>For temporary arrays (ILRetArray&lt;T&gt;), calling this property is not considered a 
            'regular use' (hence does not dispose off the array as usual).<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Create new ILArray, specify (dense) storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="storage"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILSize)">
      <summary>
            create new ILArray, specify dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0},System.Boolean)">
      <summary>
            create new ILArray, specify storage and if the new array should be disposed automatically
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="storage"></param>
      <param name="registerForDisposal"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILSize,System.Boolean)">
      <summary>
            create new ILArray, specify dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions"></param>
      <param name="registerForDisposal"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.#ctor(`0[],ILNumerics.ILSize)">
      <summary>
            create new ILArray from System.Array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="elements">System.Array</param>
      <param name="size">dimension specifier</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.#ctor(`0[],ILNumerics.ILSize,System.Boolean)">
      <summary>
            create new ILArray from System.Array, optionally register the array for disposal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="elements">System.Array</param>
      <param name="registerForDisposal">if true, the array will be disposed once the current scope is closed</param>
      <param name="size">dimension specifier</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.#ctor(`0[],System.Int32[])">
      <summary>
            create new ILArray from System.Array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="elements">System.Array</param>
      <param name="size">dimension specifier</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.#ctor(`0[])">
      <summary>
            create new ILArray from System.Array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="elements">variable length System.Array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.empty(System.Int32[])">
      <summary>
            [deprecated] Create empty array of arbitrary size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Dimension sizes</param>
      <returns>New empty array</returns>
      <remarks>This function is markes as deprecated and only included for compatibility reasons.
            It will be removed in a future version. Use <see cref="!:ILNumerics.ILMath.empty&lt;T&gt;()" /> instead.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.empty(ILNumerics.ILSize)">
      <summary>
            [deprecated] Create empty array of arbitrary size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Dimension sizes</param>
      <returns>New empty array</returns>
      <remarks>This function is markes as deprecated and only included for compatibility reasons.
            It will be removed in a future version. Use <see cref="!:ILNumerics.ILMath.empty&lt;T&gt;()" /> instead.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(`0)~ILNumerics.ILArray{`0}">
      <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">System type of size scalar</param>
      <returns>New ILArray of type ILArray <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[])~ILNumerics.ILArray{`0}">
      <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">1-dimensional system array, arbitrary type</param>
      <returns>ILNumerics array of same element type as elements of A. If A is null: empty array.</returns>
      <remarks>
        <para>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion</para>
        <para>The size of the result depends on the global option <c>Settings.CreateRowVectorByDefault</c></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="P:ILNumerics.Settings.CreateRowVectorsByDefault" />
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(System.Array)~ILNumerics.ILArray{`0}">
      <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics ILArray
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">System.Array of arbitrary size</param>
      <returns>If A is null: empty array. Otherwise a new ILNumerics ILArray of the same size as A</returns>
      <exception cref="T:System.InvalidCastException">If the type of the elements in A cannot get converted to <typeparamref name="ElementType" />.</exception>
      <exception cref="T:System.InvalidOperationException">If the type of the elements in A is not supported.</exception>
      <remarks>
        <para>Elements of A will be copied to elements of the output array (shallow copy). The following element types are 
            supported for <paramref name="A" /> and <typeparamref name="ElementType" />: double, float, int, uint, long, ulong, short, ushort, sbyte, byte.</para>
        <para>Alternatively, <paramref name="A" /> may consists out of scalar ILArrays (or ILRetArray, ILInArray, ILOutArray) of one of the above element types.</para>
        <para>The resulting ILArray will reflect all dimensions of A. Due to the fact that .NET System.Arrays are stored in row major order and 
            ILNumerics stores array in column major (for compatibility with e.g. Matlab and Fortran) the resulting ILArray will have its dimensions reverted!
            For matrices this corresponds to a matrix transpose.</para>
        <para>System.Convert is used for the conversion of elements in A to destination elements. This includes widening and narrowing conversions. When, for example, 
            array elements of type double are provided and <typeparamref name="ElementType" /> is Int32 the conversion will <b>round</b> the 
            source elements. See the examples below.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <example>
        <code lang="VB" title="VB Code Example">
            '' Elements of System.Value types:
            Dim A1 As ILArray(Of Double) = { 1, 2, 3 }  ' provide int elements
            Dim A2 As ILArray(Of Double) = { 1.0, 2.9, 3.4, 5.12 }  ' provide double elements
            Dim A As Double = 5
            Dim B As Double = 6
            Dim C As Double = 7
            
            Dim A3 As ILArray(Of Double) = { A, B, C } ' provide double variables
            
            Dim A4 As ILArray(Of Double) = { ILMath.cos(A), ILMath.tan(B) * C, C, 3 } ' provide mixed element types, including scalar ILArray  
            </code>
        <code lang="C#" title="C# Code Example"><![CDATA[
            ILArray<double> A1 = new[] { 1, ILMath.cos(2.0), 3, 4 };
            double B = -1, C = 10;
            ILArray<double> A2 = new[] { ILMath.cos(A1[1]), ILMath.tan(B) * C, C, 3 };
            // create from multidimensional System.Array 
            ILArray<int> A3 = new[,] { { 11, 12, 13 }, { 21, 22, 23 } };
            // narrowing conversion: from double to int (note the rounding rules!)
            ILArray<int> A4 = new[,] { { 11.9, 12.1, 13 }, { 21.5, 22.5, 23 } };
            //<Int32> [3,2]
            //    12         22 
            //    12         22 
            //    13         23 ]]></code>
      </example>
      <seealso cref="P:ILNumerics.Settings.CreateRowVectorsByDefault" />
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILArray{`0}">
      <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">2-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILArray{`0}">
      <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">3-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILArray{`0}">
      <summary>
            "Persistence cast" make a steady array out of a temp array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Temporary array</param>
      <returns>Steady ILArray, will survive multiple usages</returns>
      <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILArray{`0}">
      <summary>
            "Persistence cast" make a steady array out of an input array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Steady ILArray, will survive multiple usages</returns>
      <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILArray{`0}">
      <summary>
            "Persistence cast" make a steady array out of an input array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Steady ILArray, will survive multiple usages</returns>
      <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILRetCell">
      <summary>
            Convert dense array to scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar cell having the only element with a clone of array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.Assign(ILNumerics.ILRetArray{`0})">
      <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to '='
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>By using this method, this array is immediately released to the memory pool and replaced by the new array. In difference to that, 
            by using the common '=' assignment operator, the array is released only at the time, the current 
            <see cref="M:ILNumerics.ILScope.Enter" /> block  is left. Therefeore, prefere this method, if a 
            smaller memory pool is crucial.<para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})" />
    </member>
    <member name="M:ILNumerics.ILArray`1.GetArrayForWrite">
      <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Reference to inner System.Array</returns>
      <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;!</para><para>For elements of reference types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly 
            obviously does not simulate a value semantic as all other common API methods do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly or (recommended) prevent from using this 
            function with reference element types.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.SetValue(`0,System.Int32[])">
      <summary>
            Set single value to element at index specified
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New value</param>
      <param name="idx">Index of element to be altered</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
      <summary>
            Alter range of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Array with new values</param>
      <param name="range">Range specification</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILArray`1.a">
      <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to using '='
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>By assigning to this property, this array is immediately released to the memory pool and replaced by the new array. In difference to that, 
            by using the common '=' assignment operator, the array is released only at the time, the current 
            <see cref="M:ILNumerics.ILScope.Enter" /> block  is left. Therefeore, prefere this method, if a 
            smaller memory pool is crucial. However, for variables of type <c>ILArray</c>, regular assignments are allowed as well.<para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})" />
    </member>
    <member name="P:ILNumerics.ILArray`1.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray creation/ manipulation/ deletion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">Range specification, defining the size of the subarray</param>
      <returns>Subarray as copy of this array.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILArray`1.Item(System.Int32)">
      <summary>
            Single element access / manipulation/ deletion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="d1">Sequential index into this array</param>
      <returns>Scalar array with copy of single element addressed.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILArray`1.Item(System.Int32,System.Int32)">
      <summary>
            Single element access / manipulation/ deletion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="d1">Index into leading dimension</param>
      <param name="d2">Index into trailing dimensions</param>
      <returns>Scalar array with copy of single element addressed.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILBaseCell">
      <summary>
            The class implements additional functionality needed for cells
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseCell.Concat(ILNumerics.ILInCell,System.Int32)">
      <summary>
            Concatenate this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Cell to concatenate this cell with</param>
      <param name="dim">Dimension index along which to concatenate the cells.</param>
      <returns>New cell with concatenation of all elements of both cells</returns>
      <remarks>The array returned will be a copy of both cells involved. 
            If <paramref name="dim" /> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting cell has the size of both input cells, laid beside one 
            another along the <paramref name="dim" /> dimension.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseCell.GetArray``1(ILNumerics.ILBaseArray[])">
      <summary>
            Retrieve a single array of a known type from a cell position
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type of the array</typeparam>
      <param name="indices">Position of the array within this cell</param>
      <returns>Lazy, shallow clone of the array found at the given position</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseCell.GetBaseArray(ILNumerics.ILBaseArray[])">
      <summary>
            For EXPERTS only! Retrieve a single element from the given position
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Position of the element to retrieve, must evaluate to a scalar position</param>
      <returns>A clone of the scalar element found</returns>
      <remarks>
        <para>The method returns a lazy, shallow clone of the content of the cell element specified by <paramref name="indices" />. 
            However, the return type (<code>ILBaseArray</code>) is not strongly typed and may contain <b>any</b> element. According to the 
            true element stored in the cell, this might be an array of arbitrary type, null or even another cell. Moreover, handling 
            <code>ILBaseArray</code> directly is not recommended for ILNumerics, since this would hinder the memory management from proper 
            functioning. Therefore: <b>The use of this method is not recommended and left to ILNumerics experts - for very 
            specific and rare situations.</b></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseCell.GetCell(ILNumerics.ILBaseArray[])">
      <summary>
            Retrieves a subcell of this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Subcell definition, arbitrary size</param>
      <returns>A cell with a lazy, shallow clone of the elements of this cell, addressed by <paramref name="indices" /></returns>
      <remarks>The cell returned will have the size and shape specified by <paramref name="indices" />.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseCell.GetEnumerator">
      <summary>
            Enumerator returning elements as scalar cells
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Enumerator</returns>
      <remarks>This method enables the use of cells in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILBaseCell.GetValue(System.Int32[])">
      <summary>
            Retrieve single element from this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Position of the element</param>
      <returns>Lazy, shallow clone of the element to retrieve or null, if there is no element at this place</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseCell.GetValue``1(System.Int32[])">
      <summary>
            Retrieve a typed single element from within the cell, supports deep indexing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Expected type of the value to be returned</typeparam>
      <param name="indices">Location of the single element addressed</param>
      <returns>A clone of the single element addressed by <paramref name="indices" /></returns>
      <remarks>The element returned will have the type given by <typeparamref name="T" />. It is an error to specify 
            a different type as the true type of the element specified. An exception is thrown if both types differ.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseCell.IsTypeOf``1(ILNumerics.ILBaseArray[])">
      <summary>
            Test if an element of the cell is an array of the given element type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">The array element type to check the cell element against</typeparam>
      <param name="position">Position of the cell element to be tested</param>
      <returns>true if the element found at the given position is an array of the element type <typeparamref name="T" />, false otherwise</returns>
      <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T" />. That means, in order to find out, if the first cell element stores an array of int (<code>ILArray&lt;int&gt;</code>), 
            one may use <code>cell.IsTypeOf&lt;int&gt;(0)</code></para><para>In order to test, if a cell element is of type <code>ILCell</code>, one can provide the type <code>ILCell</code> as type parameter: 
            <code>cell.IsTypeOf&lt;ILCell&gt;(0)</code>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <code>ILCell</code>. The reason of this is: the type of elements of <code>ILCell</code> is 
            an implementation detail and therefore hidden to the user.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
        <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short&gt;(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String&gt;      first element  &lt;Int16&gt; [2,3,4,5,6] 
                     &lt;Double&gt;          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string&gt;(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell&gt;(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short&gt;(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell&gt;(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;&gt; never gives true
            </code></example>
    </member>
    <member name="M:ILNumerics.ILBaseCell.Reshape(ILNumerics.ILSize)">
      <summary>
            Create reshaped copy of this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">New size of the cell</param>
      <returns>Reshaped copy of the cell</returns>
      <remarks>
        <para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="size" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size" /> do not match the number of elements in this cell.</exception>
    </member>
    <member name="M:ILNumerics.ILBaseCell.Reshape(System.Int32[])">
      <summary>
            Create reshaped copy of this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">New size of the cell</param>
      <returns>Reshaped copy of the cell</returns>
      <remarks>
        <para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="size" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size" /> do not match the number of elements in this cell.</exception>
    </member>
    <!-- Badly formed XML comment ignored for member "M:ILNumerics.ILBaseCell.Repmat(System.Int32[])" -->
    <member name="M:ILNumerics.ILBaseCell.Shifted(System.Int32)">
      <summary>
            Dimension shifted cell from this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">Number of dimensions to shift</param>
      <returns>Shifted version of this cell</returns>
      <remarks>
        <para>The shift is done 'to the left':</para>
        <example>
          <code>ILCell A = cell(2,4); <br />
            ILCell B = A.Shifted(1); <br />
            // B is now: ILCell [4,2] <br />
            // <br />
            ILCell C = cell(2,4,3);<br />
            ILCell D = C.Shifted(1); <br />
            // D is now: ILCell [4,3,2] <br /></code>
        </example>
        <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style. </para>
        <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T" /> property for readability.</para>
        <para>
          <paramref name="shift" /> must be positive. It is taken modulus the number of dimensions.</para>
        <seealso cref="P:ILNumerics.ILDenseArray`1.T" />
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseCell.Subarray(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access. Get/set regular subarray.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Address range</param>
      <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
      <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para><para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para><para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example><code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para><para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseCell.T">
      <summary>
            Transposed version of this ILCell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This property is an alias for 'Shifted(1). <para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="M:ILNumerics.ILBaseCell.Shifted(System.Int32)" />
    </member>
    <member name="P:ILNumerics.ILBaseCell.Storage">
      <summary>
            Access to the more specialized version (ILCellStorage) of this storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseCell.C">
      <summary>
            Clone of this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>
            Clones of all arrays in ILNumerics.Server are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays on write access.</para>
        <para>Cells profit from the same efficient clone creation process. However, since a cell may store an arbitrarily deep 
            hirarchy of other cells and arrays, in order to clone a cell, the cells elements have to be cloned as well - in an 
            recursive manner. Clones play an important role for ILNumerics cells. They are used to implement value semantics for cell
            elements. I.e.: the cloned cell returned cannot not be used to alter elements of the original cell in any way.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILBaseLogical">
      <summary>
            Boolean array for high performance relational operations on arbitrary arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Logical arrays are derived from <![CDATA[ILArray<byte>]]>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <![CDATA[ILArray<byte>]]>.
            The difference between <![CDATA[<byte>]]> and an ILLogical is, the ILLogical 
            storing a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.#ctor(ILNumerics.Storage.ILDenseStorage{System.Byte},System.Boolean)">
      <summary>
            Constructor creating ILLogical from dense storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new ILLogical</param>
      <param name="isTempArray">Indicate whether the result is supposed to be a temporary array (true) or persistent (false)</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.sumElements">
      <summary>
            Sum all elements of this storage.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Number of non zero elements</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.Concat(ILNumerics.ILInLogical,System.Int32)">
      <summary>
            Concatenate this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">N-dimensional array. Except for dimensions <paramref name="dim" />
            the dimensions of A must match the dimensions of this storage</param>
      <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
      <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.Reshape(ILNumerics.ILSize)">
      <summary>
            Create reshaped copy of this logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">New dimensions of the array</param>
      <returns>Reshaped copy of this array</returns>
      <remarks>
        <para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size" /> do not match the number of elements in this array.</exception>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.Reshape(System.Int32[])">
      <summary>
            Create reshaped copy of this logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">New dimensions of the array</param>
      <returns>Reshaped copy of the array</returns>
      <remarks>
        <para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size" /> do not match the number of elements in this array.</exception>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.Repmat(System.Int32[])">
      <summary>
            Create replication of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims" /> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
      <returns>array being created out of multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims" /></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.Shifted(System.Int32)">
      <summary>
            Create logical array from this logical and shift dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">Number of dimensions to shift</param>
      <returns>Shifted version of this array</returns>
      <remarks>
        <para>The shift is done 'to the left':</para>
        <example>
          <code>ILArray&lt;double&gt; A = zeros(2,4); 
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2] 
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code>
        </example>
        <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
        <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T" /> property for readability.</para>
        <para>
          <paramref name="shift" /> must be positive. It is taken modulus the number of dimensions.</para>
        <seealso cref="P:ILNumerics.ILDenseArray`1.T" />
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.Subarray(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray from this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">Arrays specifying the ranges to create subarray from</param>
      <returns>Subarray as specified</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.ShortInfo">
      <summary>
            Short summary of this logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Type and size information</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILBaseLogical.empty(ILNumerics.ILSize)">
      <summary>
            [deprecated] create empty ILLogical
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>empty ILLogical.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseLogical.NumberNonZero">
      <summary>
            Number of 'true' elements in this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This value caches the number of 'true' elements in this logical array. 
            It may be used for information purposes but is actually needed internally for performance 
            reasons.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILBaseLogical.T">
      <summary>
            Shift the dimensions of this array by one (transpose for matrix)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILBaseLogical.C">
      <summary>
            Create clone of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILCell">
      <summary>
            Mathematical container class holding arbitrary array objects as elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Cells act as general purpose container. Cells store arbitrary arrays of arbitrary element type. 
            Theses elements commonly are cells itself. <c>ILCell</c> is used for local cell variables in 
            your algorithms. 
            <para>More details about cells are found in the <a href="http://ilnumerics.net/$Cells.html">online manual</a>.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="T:ILNumerics.ILCell" />
    </member>
    <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
      <summary>
            Create cell object with pre-created data in specified dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
      <param name="size">size of the new cell</param>
      <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
      <summary>
            Create cell object with pre-created data in specified dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
      <param name="size">size of the new cell</param>
      <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILCell.#ctor(System.Int32[])">
      <summary>
            [deprecated] create new cell object, elements will be 'null'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">dimension sizes of the new cell</param>
      <remarks>
        <para>After creation, the cell elements can be set by use 
            of the indexer methods or by using corresponding methods of ILCell like SetValue()</para>
        <para>Consider using <see cref="M:ILNumerics.ILMath.cell()" /> in order to create 
            cell arrays.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="P:ILNumerics.ILCell.Item(System.Int32[])" />
      <seealso cref="P:ILNumerics.ILCell.Item(ILNumerics.ILBaseArray[])" />
      <seealso cref="M:ILNumerics.ILBaseCell.GetArray``1(ILNumerics.ILBaseArray[])" />
    </member>
    <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILRetCell)~ILNumerics.ILCell">
      <summary>
            Convert temporary cell to persistent cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Temporary cell</param>
      <returns>Persistent cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILInCell)~ILNumerics.ILCell">
      <summary>
            Convert input parameter cell to persistent cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input parameter cell</param>
      <returns>Persistent cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILCell">
      <summary>
            Convert output parameter cell to persistent cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Output parameter cell</param>
      <returns>Persistent cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILCell.Assign(ILNumerics.ILRetCell)">
      <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILCell.SetValue(ILNumerics.ILBaseArray,System.Int32[])">
      <summary>
            Set single element of the cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">The new value</param>
      <param name="idx">Indices specifying the location to set the element to</param>
      <remarks>The function supports the following features: 
            <list type="bullet"><item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item><item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item><item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item><item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item></list><para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value" />, the corresponding 
            element is overwritten or removed.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILCell.SetValue(ILNumerics.Storage.ILStorage,System.Int32[])">
      <summary>
            Set single element of the cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">The new value</param>
      <param name="idx">Indices specifying the location to set the element to</param>
      <remarks>The function supports the following features: 
            <list type="bullet"><item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item><item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item><item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item><item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item></list><para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value" />, the corresponding 
            element is overwritten or removed.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILCell.SetRange(ILNumerics.ILInCell,ILNumerics.ILBaseArray[])">
      <summary>
            Alter range of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Array with new values</param>
      <param name="range">Range specification</param>
      <remarks>All common array modification/ reshaping/ removing/ expansion rules apply.
            <para>Like for almost all operations on cell, the values stored in the cell are 
            not connected to the original cell elements outside the cell (value semantics).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILCell.GetArrayForWrite">
      <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Reference to inner System.Array</returns>
      <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;!</para><para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILCell.a">
      <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILCell.Item(System.Int32[])">
      <summary>
            Get/set/remove single element
            <para>[ILNumerics Core Module]</para>
      </summary>
      <paramref name="indices" value="Index to element" />
      <value>Inner element, new inner element or null</value>
      <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example>For <c>
            ILArray&lt;double&gt; A = ILMath.counter(1,12);</c>, <c>A[2]</c> gives: 3.0.
            But the transpose 
            <c>A.T[2]</c> gives also: 3.0.
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -&gt; out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example><para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para><para><list type="bullet"><listheader>The type of the element returned depends on the type of the element addressed:</listheader><item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item><item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item><item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item></list></para><para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example><code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code></example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILCell.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access. Get/set regular subarray.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Address range</param>
      <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
      <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para><para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para><para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example><code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para><para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.ILInArray`1">
      <summary>
            Rectangular array, used as input parameter only
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="ElementType">Inner type. This will mostly be a system numeric type or a 
            complex floating point type.</typeparam>
      <remarks>
        <para>This class extends the primary <c>ILArray</c> by optimizing its behavior for the case when used as an
            input parameter to functions.</para>
        <para>When writing your own function all <i>input</i> parameters should be of type <c>ILInArray</c>. 
            Similary, all return types should be of type <see cref="T:ILNumerics.ILRetArray`1" /> and all "out" parameters of type <see cref="T:ILNumerics.ILOutArray`1" />.</para>
        <para>Other than being used to transfer arguments into functions, <c>ILInArray</c> should not be used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="T:ILNumerics.ILArray`1" />
      <seealso cref="T:ILNumerics.ILRetArray`1" />
      <seealso cref="T:ILNumerics.ILOutArray`1" />
    </member>
    <member name="M:ILNumerics.ILInArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            create new ILInArray, specify (dense) storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="storage"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.#ctor(ILNumerics.ILSize)">
      <summary>
            create new ILInArray, specify dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.#ctor(`0[],System.Int32[])">
      <summary>
            create new ILInArray from System.Array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="elements">System.Array</param>
      <param name="dimensions">dimension specifier</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0)~ILNumerics.ILInArray{`0}">
      <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">System type of size scalar</param>
      <returns>New ILInArray of type ILInArray <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[])~ILNumerics.ILInArray{`0}">
      <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">1-dimensional system array, arbitrary type</param>
      <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
      <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(System.Array)~ILNumerics.ILInArray{`0}">
      <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Arbitrarily sized System.Array</param>
      <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
      <remarks>The inner type of input array <paramref name="A" /> must match the requested type
            <typeparamref name="ElementType" />. The resulting ILInArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILCastException"> if type of input does not match 
            ElementType</exception>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILInArray{`0}">
      <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">2-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILInArray{`0}">
      <summary>
            Implicitly casts three dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">3-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILRetCell">
      <summary>
            Implicitly cast ILInArray to ILRetCell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="array">Input array</param>
      <returns>1x1 cell holding the array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILInArray{`0}">
      <summary>
            Convert temporary to input parameter array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="array">Temp array</param>
      <returns>Input parameter array, will survive the current scope only</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILInArray{`0}">
      <summary>
            Convert persistent to input parameter array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="array">Persistent array</param>
      <returns>Input parameter array, will survive the current scope only</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILInArray{`0}">
      <summary>
            Convert output paramter array to input parameter array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="array">Output parameter array</param>
      <returns>Input parameter array, will survive the current scope only</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILInArray`1.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray creation/ manipulation/ deletion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">Range specification, defining the size of the subarray</param>
      <returns>Subarray as copy of this array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILInArray`1.Item(System.Int32)">
      <summary>
            Single element access
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="d1">Sequential index into this array</param>
      <returns>Scalar array with copy of single element addressed.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILInArray`1.Item(System.Int32,System.Int32)">
      <summary>
            Single element access
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="d1">Index into leading dimension</param>
      <param name="d2">Index into trailing dimensions</param>
      <returns>Scalar array with copy of single element addressed.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILInCell">
      <summary>
            Mathematical container class holding arbitrary array objects as elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Cells act as general purpose container. Cells store arbitrary arrays of arbitrary element type. 
            Theses elements commonly are cells itself. <c>ILInCell</c> acts as input parameter 
            in function declarations only. 
            Use <see cref="T:ILNumerics.ILCell" /> for local cell variables in your algorithms. 
            <para>More details about cells are found in the <a href="http://ilnumerics.net/$Cells.html">online manual</a>.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="T:ILNumerics.ILCell" />
    </member>
    <member name="M:ILNumerics.ILInCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
      <summary>
            Create cell object with pre-created data in specified dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
      <param name="size">Size of the new cell</param>
      <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
      <summary>
            Create cell object with pre-created data in specified dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
      <param name="size">size of the new cell</param>
      <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInCell.#ctor(System.Int32[])">
      <summary>
            create new cell object, elements will be 'null'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">dimension sizes of the new cell</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILRetCell)~ILNumerics.ILInCell">
      <summary>
            Convert temporary cell to input parameter type cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="cell">Temporary cell</param>
      <returns>Input parameter type cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILInCell">
      <summary>
            Convert temporary cell to input parameter type cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="cell">ILCell</param>
      <returns>Input parameter type cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILInCell">
      <summary>
            Convert output parameter type cell to input parameter type cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="cell">Output parameter type cell</param>
      <returns>Input parameter type cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILInCell.Item(System.Int32[])">
      <summary>
            Return single element in a scalar cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <paramref name="indices" value="Index to element" />
      <remarks>
        <para>The indexer retrieves a single element from within the cell. It returns the single element 
            in a new (scalar) cell. Use dereferencing functions like GetArray&lt;T&gt;() in order to retrieve 
            the element value (ie. the array addressed) without a cell container.</para>
        <para>Input parameter type cells are immutable! They are not intended to be altered! Therefore, 
            write access on such cells is disabled. In order to alter content of a cell, assign the cell to a regular
            persistent cell of type <see cref="T:ILNumerics.ILCell" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILInCell.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access. Get regular subarray.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Address range</param>
      <returns>Cell array with subcell range from this instance, addressed by <c>indices</c></returns>
      <remarks>
        <para>The indexer is used to query subcell ranges. All general indexing/ subarray addressing rules apply.
            The elements addressed are returned within a new temporary cell instance.</para>
        <para>Input parameter type cells are immutable! They are not intended to be altered! Therefore, 
            write access on such cells is disabled. In order to alter content of a cell, assign the cell to a regular
            persistent cell of type <see cref="T:ILNumerics.ILCell" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILInLogical">
      <summary>
            Boolean array for high performance relational operations on arbitrary arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Logical arrays are derived from <![CDATA[ILArray<byte>]]>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <![CDATA[ILArray<byte>]]>.
            The difference between <![CDATA[ILArray<byte>]]> and logical arrays is, the logical array 
            storing a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.#ctor(System.Int32[])">
      <summary>
            constructor - create logical array of specified size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
      <remarks>
            The size parameter may not be null or an empty array! An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.ILSize)">
      <summary>
            constructor - create logical array of specified size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            dimension object
            </param>
      <remarks>
            The size parameter may not be null. An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
      <summary>
            Constructor creating logical array from dense storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
      <summary>
            Constructor creating logical array from (dense) storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array storage, the storage will directly be used for 
            storage of the new logical array</param>
      <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
      <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],System.Int32[])">
      <summary>
            constructor - create logical array of specified size 
            from data array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
      <param name="data"> byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
      <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
      <summary>
            Constructor creating logical array, provide predefined storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
      <param name="dimension">Dimensions specification.</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
      <summary>
            Constructor creating logical array, predefined storage (fast version)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
      <param name="dimension">Dimensions specification.</param>
      <param name="nonZeroCount">number of nonzero elements in <paramref name="data" />. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.op_LogicalNot(ILNumerics.ILInLogical)">
      <summary>
            Invert values of array elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>New logical array, having the element values of A inverted</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.op_Implicit(ILNumerics.ILInLogical)~System.Boolean">
      <summary>
            Implicitly convert logical array to bool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">logical array</param>
      <returns>true if <b>all</b> elements of A are non-zero, false otherwise 
            </returns>
      <remarks>If A is null or empty, the function returns false. Otherwise allall returns true, 
            if all elements of A are non-zero and returns false, if A contains any zero elements.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Boolean)~ILNumerics.ILInLogical">
      <summary>
            Implicitly convert scalar byte to logical array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">Byte scalar</param>
      <returns>New logical array of size 1x1 holding the only element of type <c>byte</c>
            with value of val.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Int32)~ILNumerics.ILInLogical">
      <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">Scalar value</param>
      <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[])~ILNumerics.ILInLogical">
      <summary>
            implicitly cast one dimensional System.Array to ILNumerics array (vector)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">1 dimensional system array, arbitrary type</param>
      <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
      <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Array)~ILNumerics.ILInLogical">
      <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Arbitrarily sized System.Array</param>
      <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
      <remarks>The inner type of input array <paramref name="A" /> must match the requested type
            <typeparamref name="ElementType" />. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
    </member>
    <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILInLogical">
      <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">2-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILInLogical">
      <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">3-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILInLogical.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access (readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">Range specification.</param>
      <returns>Logical array with the elements specified by range</returns>
      <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying any elements 
            in this array. <c>range</c> may contains index specifications for one ... to any 
            dimension. The array returned will have the size specified by range.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.ILLogical">
      <summary>
            Boolean array for high performance relational operations on arbitrary arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Logical arrays are derived from <c><![CDATA[ILArray<byte>]]></c>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <c><![CDATA[ILArray<byte>]]></c>.
            The difference between arrays and logical arrays is: the logical array 
            stores a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.#ctor(System.Int32[])">
      <summary>
            constructor - create logical array of type <c>Byte</c> of specified size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
      <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILArray &lt; byte &gt; of the specified dimensions 
            will be created. The type of storage will be <c>bool</c>.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.ILSize)">
      <summary>
            constructor - create logical array of type <c>Byte</c> of specified size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            dimension object
            </param>
      <remarks>
            The size parameter may not be null. An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            Depending on the requested size an logical array of the specified dimensions 
            will be created. The element type is be <c>bool</c>.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
      <summary>
            Constructor creating logical array from dense storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
      <summary>
            Constructor creating logical array from (dense) storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
      <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
      <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],System.Int32[])">
      <summary>
            constructor - create logical array of specified size 
            from data array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
      <param name="data"> byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
      <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an logical array of the specified size 
            will be created. The type of storage will be <c>byte</c>.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
      <summary>
            Constructor creating logical array, provide predefined storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
      <param name="dimension">Dimensions specification.</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
      <summary>
            Constructor creating logical array, predefined storage (fast version)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
      <param name="dimension">Dimensions specification.</param>
      <param name="nonZeroCount">number of nonzero elements in <paramref name="data" />. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.op_Implicit(System.Boolean)~ILNumerics.ILLogical">
      <summary>
            Implicitly convert boolean scalar to logical array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">Boolean scalar</param>
      <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.op_Implicit(ILNumerics.ILLogical)~System.Boolean">
      <summary>
            Implicitly convert logical array to bool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">logical array</param>
      <returns>true if <b>all</b> elements of A are non-zero, false otherwise 
            </returns>
      <remarks> If A is null or empty, the function returns false. Otherwise allall returns true, 
            if all elements of A are non-zero and returns false, if A contains any zero elements.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.op_Implicit(System.Int32)~ILNumerics.ILLogical">
      <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">Scalar value</param>
      <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[])~ILNumerics.ILLogical">
      <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">1-dimensional system array, arbitrary type</param>
      <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
      <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.op_Implicit(System.Array)~ILNumerics.ILLogical">
      <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Arbitrarily sized System.Array</param>
      <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
      <remarks>The inner type of input array <paramref name="A" /> must match the requested type
            <typeparamref name="ElementType" />. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILCastException"> if type of input does not match 
            ElementType</exception>
    </member>
    <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILLogical">
      <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">2D System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILLogical">
      <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">3-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.op_LogicalNot(ILNumerics.ILLogical)">
      <summary>
            Invert values of array elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="in1">Input array</param>
      <returns>New solid logical array, inverted element values</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.SetValue(System.Byte,System.Int32[])">
      <summary>
            Set single value to element at index specified
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New value</param>
      <param name="idx">Index of element to be altered</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.SetRange(ILNumerics.ILInLogical,ILNumerics.ILBaseArray[])">
      <summary>
            Alter a range of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Array with new values</param>
      <param name="range">Range specification</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.Assign(ILNumerics.ILRetLogical)">
      <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILLogical.GetArrayForWrite">
      <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Reference to inner System.Array</returns>
      <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;!</para><para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILLogical.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">Range specification.</param>
      <returns>Reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
      <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para><para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para><para>In case of removal the ILArray returned will be a reference array.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILLogical.a">
      <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILOutArray`1">
      <summary>
            Rectangular array, used as output parameter only
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="ElementType">Inner type. This will mostly be a system numeric type or a 
            complex floating point type.</typeparam>
      <remarks>
        <para>This class extends the primary <c>ILArray</c> by optimizing its behavior for the case when used as an
            output parameter of functions.</para>
        <para>When writing your own function all <i>output</i> parameters should be of type <c>ILOutArray</c>. Do not
            use <c>out ILArray</c>! Similary, all return types should be of type <see cref="T:ILNumerics.ILRetArray`1" /> and all input parameters of type <see cref="T:ILNumerics.ILInArray`1" />.</para>
        <para>Other than being used to retrieve results from functions, <c>ILOutArray</c> should not be used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="T:ILNumerics.ILArray`1" />
      <seealso cref="T:ILNumerics.ILRetArray`1" />
      <seealso cref="T:ILNumerics.ILInArray`1" />
    </member>
    <member name="M:ILNumerics.ILOutArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Create new output parameter array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="storage">Dense storage for the new array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILOutArray{`0}">
      <summary>
            Creates an output parameter type array from regular array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Original array</param>
      <returns>Output parameter type array, references the original array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})">
      <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutArray`1.GetArrayForWrite">
      <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Reference to inner System.Array</returns>
      <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;!</para><para>For elements of reference types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly 
            obviously does not simulate a value semantic as all other common API methods do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly or (recommended) prevent from using this 
            function with reference element types.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILOutArray`1.SetValue(`0,System.Int32[])">
      <summary>
            Set single value to element at index specified
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New value</param>
      <param name="idx">Index of element to be altered</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutArray`1.SetRange(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
      <summary>
            Alter range of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Array with new values</param>
      <param name="range">Range specification</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILOutArray`1.a">
      <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILOutArray`1.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray creation/manipulation/deletion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">Range specification, defining the size of the subarray</param>
      <returns>Subarray as copy of this array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILOutArray`1.Item(System.Int32)">
      <summary>
            Single element access / manipulation/ deletion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="d1">Sequential index into this array</param>
      <returns>Scalar array with copy of single element addressed.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILOutArray`1.Item(System.Int32,System.Int32)">
      <summary>
            Single element access / manipulation/ deletion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="d1">Index into leading dimension</param>
      <param name="d2">Index into trailing dimensions</param>
      <returns>Scalar array with copy of single element addressed.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILOutCell">
      <summary>
            Mathematical container class holding arbitrary array objects as elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Cells act as general purpose container. Cells store arbitrary arrays of arbitrary element type. 
            Theses elements commonly are cells itself. <c>ILOutCell</c> acts as output parameter 
            in function declarations when a function needs to return multiple (cell) arrays. 
            Use <see cref="T:ILNumerics.ILCell" /> for local cell variables in your algorithms. 
            <para>More details about cells are found in the <a href="http://ilnumerics.net/$Cells.html">online manual</a>.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="T:ILNumerics.ILCell" />
    </member>
    <member name="M:ILNumerics.ILOutCell.#ctor(ILNumerics.Storage.ILCellStorage)">
      <summary>
            do not use this constructor! Out arrays are to be created implicitely only!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="cellStorage">storage of source cell</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILOutCell">
      <summary>
            Implicitely convert persistent cell to output parameter type cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Original cell</param>
      <returns>Output parameter cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutCell.Assign(ILNumerics.ILRetCell)">
      <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutCell.SetValue(ILNumerics.ILBaseArray,System.Int32[])">
      <summary>
            Set single element of the cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">The new value</param>
      <param name="idx">Indices specifying the location to set the element to</param>
      <remarks>The function supports the following features: 
            <list type="bullet"><item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item><item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item><item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item><item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item></list><para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value" />, the corresponding 
            element is overwritten or removed.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILOutCell.SetValue(ILNumerics.Storage.ILStorage,System.Int32[])">
      <summary>
            Set single element of the cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">The new value</param>
      <param name="idx">Indices specifying the location to set the element to</param>
      <remarks>The function supports the following features: 
            <list type="bullet"><item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item><item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item><item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item><item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item></list><para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value" />, the corresponding 
            element is overwritten or removed.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILOutCell.GetArrayForWrite">
      <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Reference to inner System.Array</returns>
      <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;!</para><para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILOutCell.a">
      <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILOutCell.Item(System.Int32[])">
      <summary>
            Get/set/remove single element
            <para>[ILNumerics Core Module]</para>
      </summary>
      <paramref name="indices" value="index to element" />
      <value>Inner element, new inner element or null</value>
      <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example>For <c>ILArray&lt;double&gt; A = ILMath.counter(1,12);</c>, <c>A[2]</c> gives: 3.0.
            But the transpose 
            <c>A.T[2]</c> gives also: 3.0.
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -&gt; out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example><para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para><para><list type="bullet"><listheader>The type of the element returned depends on the type of the element addressed:</listheader><item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item><item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item><item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item></list></para><para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example><code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code></example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para><para>Output parameter type cell carry a reference to the original array they were created from. 
            Modifications of outpur parameter type cells are immediately applied to the original array also.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILOutCell.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access. Get/set regular subarray.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Address range</param>
      <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
      <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para><para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para><para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example><code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para><para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para><para>Output parameter type cell carry a reference to the original array they were created from. 
            Modifications of outpur parameter type cells are immediately applied to the original array also.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.ILOutLogical">
      <summary>
            Boolean array for high performance relational operations on arbitrary arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Logical arrays store true/false conditions as elements. Each element consumes
            one byte. Logical arrays are the output parameter of all relational comparisons.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.#ctor(System.Int32[])">
      <summary>
            Constructor - create logical array of type <c>Byte</c> of specified size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
      <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILArray &lt; byte &gt; of the specified dimensions 
            will be created. The type of storage will be <c>bool</c>.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.ILSize)">
      <summary>
            Constructor - create logical array of type <c>byte</c> of specified size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            Size descriptor
            </param>
      <remarks>
            The size parameter may not be null. An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            Depending on the requested size an logical array of the specified dimensions 
            will be created. The element type is be <c>bool</c>.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
      <summary>
            Constructor creating logical array from dense storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
      <summary>
            Constructor creating logical array from (dense) storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
      <param name="numberNonZero">Number of nonzero elements in A. Must be positive or 0.</param>
      <remarks>Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],System.Int32[])">
      <summary>
            Constructor - create logical array of specified size from data array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
      <param name="data">byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
      <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an logical array of the specified size 
            will be created. The type of storage will be <c>byte</c>.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
      <summary>
            Constructor creating logical array, provide predefined storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
      <param name="size">Dimensions specification.</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
      <summary>
            Constructor creating logical array, predefined storage (fast version)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
      <param name="size">Dimensions specification.</param>
      <param name="nonZeroCount">number of nonzero elements in <paramref name="data" />. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.op_Implicit(ILNumerics.ILLogical)~ILNumerics.ILOutLogical">
      <summary>
            Convert logical array to output parameter type array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Source logical array</param>
      <returns>Output parameter type array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.SetValue(System.Byte,System.Int32[])">
      <summary>
            Set single value to element at index specified
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New value</param>
      <param name="idx">Index of element to be altered</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.SetRange(ILNumerics.ILInLogical,ILNumerics.ILBaseArray[])">
      <summary>
            Alter a range of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Array with new values</param>
      <param name="range">Range specification</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.Assign(ILNumerics.ILRetLogical)">
      <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">new array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILOutLogical.GetArrayForWrite">
      <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Reference to inner System.Array</returns>
      <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;!</para><para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILOutLogical.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">Range specification.</param>
      <returns>Reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
      <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para><para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para><para>In case of removal the ILArray returned will be a reference array.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILOutLogical.a">
      <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILRetArray`1">
      <summary>
            N-dimensional, generic array class, temporary variant, is disposed after first use
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="ElementType">Inner element type</typeparam>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0)~ILNumerics.ILRetArray{`0}">
      <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">Single element of ElementType type</param>
      <returns>New array of of size 1x1 holding the only element with value of val.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[])~ILNumerics.ILRetArray{`0}">
      <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">1-dimensional system array, arbitrary type</param>
      <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
      <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(System.Array)~ILNumerics.ILRetArray{`0}">
      <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Arbitrarily sized System.Array</param>
      <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
      <remarks>The inner type of input array <paramref name="A" /> must match the requested type
            <typeparamref name="ElementType" />. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILRetArray{`0}">
      <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">2-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILRetArray{`0}">
      <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">3-dimensional System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILRetCell">
      <summary>
            Convert array to temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Source array</param>
      <returns>Temporary scalar cell, having the only element with a clone of A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILRetArray{`0}">
      <summary>
            'Clone' conversion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Source array</param>
      <returns>Temporary ILArray, will be disposed after next operation</returns>
      <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. A (fast) clone will be made. This is an alias for A.C.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILRetArray{`0}">
      <summary>
            'Clone' conversion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Source array</param>
      <returns>Temporary ILArray, will be disposed after next operation</returns>
      <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. One example is the conversion of ILArray as return type. 
            A (fast) clone will be made. This is an alias for A.C.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILRetArray{`0}">
      <summary>
            'Clone' conversion
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Source array</param>
      <returns>temporary ILArray, will be disposed after next operation</returns>
      <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. One example is the conversion of ILArray as return type. 
            A (fast) clone will be made. This is an alias for A.C.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.Clone">
      <summary>
            Clone of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
        <para>The clone returned will be of the same type as this instance.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.Concat(ILNumerics.ILInArray{`0},System.Int32)">
      <summary>
            Concatenate this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">n-dimensional storage</param>
      <param name="dim">Dimension index along which to concatenate the arrays.</param>
      <returns>New array with copy elements of this array and A</returns>
      <remarks>The array returned will be a copy of both arrays involved. None 
            of the input arrays will be altered. If <paramref name="dim" /> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting array has the size of both input arrays, laid beside one 
            another along the <paramref name="dim" /> dimension.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.Equals(System.Object)">
      <summary>
            Compare elements and shape of this array with another array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Other array</param>
      <returns>true if shape and element values of both arrays match, false otherwise</returns>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.ExportValues(`0[]@)">
      <summary>
            Copy values of all elements into System.Array.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
      <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.GetEnumerator">
      <summary>
            Enumerator returning elements as ElementType
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Enumerator</returns>
      <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>ILArray&lt;double&gt; A = rand(5,4,6);
            foreach (double element in A) {
                // all elements are scalar double values
                String.Format("Element: {0} ", element);
                // Note: 'element' cannot be used to alter the collection! 
            } </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.GetHashCode">
      <summary>
            Generate a hash code based on the current arrays values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Hash code</returns>
      <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.GetLimits(`0@,`0@)">
      <summary>
            Get minimum and maximum value of all elements - if any
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="min">[Output] Minimum value</param>
      <param name="max">[Output] Maximum value</param>
      <returns>true if the limits exists and could be computed, false otherwise</returns>
      <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.GetValue(System.Int32[])">
      <summary>
            Get single element from this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Indices, location of element</param>
      <returns>The requested element</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.Repmat(System.Int32[])">
      <summary>
            Create replication of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims" /> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
      <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims" /></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.Reshape(ILNumerics.ILSize)">
      <summary>
            Reshaped copy of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">New dimensions of the array</param>
      <returns>Reshaped copy of the array</returns>
      <remarks>
        <para>The current instance will not be changed. A new storage is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in <paramref name="dimensions" />
            do not match the number of elements in this array.</exception>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.Serialize(System.IO.Stream)">
      <summary>
             Serialize this ILArray into a binary stream.
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
      <returns>True on success, false on error.</returns>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.Shifted(System.Int32)">
      <summary>
            Create array from this array and shift dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">Number of dimensions to shift</param>
      <returns>Shifted version of this array</returns>
      <remarks>
        <para>The shift is done 'to the left':</para>
        <example>
          <code>ILArray&lt;double&gt; A = zeros(2,4);
            ILArray&lt;double&gt; B = A.Shifted(1);
            // B is now: &lt;double&gt; [4,2]
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code>
        </example>
        <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
        <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T" /> property for readability.</para>
        <para>
          <paramref name="shift" /> must be positive. It is taken modulus the number of dimensions.</para>
        <seealso cref="P:ILNumerics.ILDenseArray`1.T" />
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.Subarray(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray creation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Range specification, defining the size of the subarray</param>
      <returns>Subarray as copy of a part of this array</returns>
      <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
      <summary>
            Send values of this instance to stream.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="stream">Stream to write the values into.</param>
      <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)" /> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
      <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags" />. Specifies the way in which
            the values will be serialized.</param>
      <remarks>
        <para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
        <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.C">
      <summary>
            Clone of this array (fast, cheap and shallow)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.S">
      <summary>
            Size descriptor shortcut
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.Size">
      <summary>
            Size descriptor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.IsColumnVector">
      <summary>
            Test if this array instance is a column vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.IsRowVector">
      <summary>
            Test if this array instance is a row vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.IsComplex">
      <summary>
            Determine if this array has complex elements.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.IsEmpty">
      <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.IsMatrix">
      <summary>
            Test if this instance is a matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.IsNumeric">
      <summary>
            Determine if this array holds numeric values.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table"><listheader><term>inner type</term></listheader><item><term>System.double</term><description>floating point, real, 8 bytes </description></item><item><term>System.float</term><description>floating point real, 4 bytes</description></item><item><term>ILNumerics.complex</term><description>floating point complex, 16 bytes</description></item><item><term>ILNumerics.fcomplex</term><description>floating point complex, 8 bytes</description></item><item><term>System.char</term><description>integer, real, 1 byte</description></item><item><term>System.byte</term><description>integer, real, 1 byte</description></item><item><term>System.Int16</term><description>integer, real, 2 byte</description></item><item><term>System.Int32</term><description>integer, real, 4 byte</description></item><item><term>System.Int64</term><description>integer, real, 8 byte</description></item><item><term>System.UInt16</term><description>unsigned integer, real, 2 byte</description></item><item><term>System.UInt32</term><description>unsigned integer, real, 4 byte</description></item><item><term>System.UInt64</term><description>unsigned integer, real, 8 byte</description></item></list><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.IsScalar">
      <summary>
            Test if this instance is a scalar
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.IsVector">
      <summary>
            Test if this array is a vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.Length">
      <summary>
            Length of the longest dimension of this instance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.T">
      <summary>
            Return transposed version of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.Name">
      <summary>
            Gets the name of this array (readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray creation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">Range specification, defining the size of the subarray</param>
      <returns>Subarray as copy of a part of this array</returns>
      <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.Item(System.Int32)">
      <summary>
            Single element access
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="d1">Sequential index into this array</param>
      <returns>Scalar array with copy of single element addressed.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetArray`1.Item(System.Int32,System.Int32)">
      <summary>
            Single element access
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="d1">Index into leading dimension</param>
      <param name="d2">Index into trailing dimensions</param>
      <returns>Scalar array with copy of single element addressed.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILRetCell">
      <summary>
            Mathematical container class holding arbitrary array objects as elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Cells act as general purpose container. Cells store arbitrary arrays of arbitrary element type. 
            Theses elements commonly are cells itself. <c>ILRetCell</c> acts as return type 
            in function declarations when a cell needs to be returned from a function. 
            Use <see cref="T:ILNumerics.ILCell" /> for local cell variables in your algorithms. 
            <para>More details about cells are found in the <a href="http://ilnumerics.net/$Cells.html">online manual</a>.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="T:ILNumerics.ILCell" />
    </member>
    <member name="M:ILNumerics.ILRetCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
      <summary>
            Create cell object with pre-created data in specified dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
      <param name="size">Size of the new cell</param>
      <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
      <summary>
            Create cell object with pre-created data in specified dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
      <param name="size">Size of the new cell</param>
      <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.#ctor(System.Int32[])">
      <summary>
            Create new cell object, elements will be 'null'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Size descriptor of the new cell</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Int32)~ILNumerics.ILRetCell">
      <summary>
            Convert primitive integer to a scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Primitive scalar int value</param>
      <returns>New scalar temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Double)~ILNumerics.ILRetCell">
      <summary>
            Convert primitive double to a scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Primitive scalar double value</param>
      <returns>New scalar temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Single)~ILNumerics.ILRetCell">
      <summary>
            Convert primitive float to a scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Primitive scalar float value</param>
      <returns>New scalar temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Byte)~ILNumerics.ILRetCell">
      <summary>
            Convert primitive byte to a scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Primitive byte int value</param>
      <returns>New scalar temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Int32[])~ILNumerics.ILRetCell">
      <summary>
            Encapsulate integer System.Array into a scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">Primitive System.Int32 value - no copy will be made!</param>
      <returns>New scalar temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(System.String)~ILNumerics.ILRetCell">
      <summary>
            Convert string to a scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">String value</param>
      <returns>New scalar temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(System.String[])~ILNumerics.ILRetCell">
      <summary>
            Encapsulate array of strings into a scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">String array - no copy will be made!</param>
      <returns>New scalar temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILRetCell">
      <summary>
            Convert cell to temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Cell</param>
      <returns>Temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILInCell)~ILNumerics.ILRetCell">
      <summary>
            Convert input parameter cell to temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input parameter cell</param>
      <returns>Temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILRetCell">
      <summary>
            Convert output parameter cell to temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Output parameter cell</param>
      <returns>Temporary cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILBaseLogical)~ILNumerics.ILRetCell">
      <summary>
            Wrap single logical array into a new scalar temporary cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Logical array</param>
      <returns>Scalar cell</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.Clone">
      <summary>
            Clone of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
        <para>The clone returned will be of the same type as this instance.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.Concat(ILNumerics.ILInCell,System.Int32)">
      <summary>
            Concatenate this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Cell to concatenate this cell with</param>
      <param name="dim">Dimension index along which to concatenate the cells.</param>
      <returns>new cell with concatenation of all elements of both cells</returns>
      <remarks>The array returned will be a copy of both cells involved. 
            If <paramref name="dim" /> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting cell has the size of both input cells, laid beside one 
            another along the <paramref name="dim" /> dimension.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.Equals(System.Object)">
      <summary>
            Compare elements and shape of this array with another array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Other array</param>
      <returns>true if shape and element values of both arrays match, false otherwise</returns>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.ExportValues(ILNumerics.Storage.ILStorage[]@)">
      <summary>
            Copy values of all elements into System.Array.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
      <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.GetArray``1(ILNumerics.ILBaseArray[])">
      <summary>
            Retrieve a single array of a known type from a cell position
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type of the array</typeparam>
      <param name="indices">Position of the array within this cell</param>
      <returns>Lazy, shallow clone of the array found at the given position</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.GetBaseArray(ILNumerics.ILBaseArray[])">
      <summary>
            Retrieve a single element from the given position
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Position of the element to retrieve, must evaluate to a scalar position</param>
      <returns>A clone of the scalar element found</returns>
      <remarks>
        <para>The method returns a lazy, shallow clone of the content of the cell element specified by <paramref name="indices" />. 
            However, the return type (<code>ILBaseArray</code>) is not strongly typed and may contain <b>any</b> element. According to the 
            true element stored in the cell, this might be an array of arbitrary type, null or even another cell. Moreover, handling 
            <code>ILBaseArray</code> directly is not recommended for ILNumerics, since this would hinder the memory management from proper 
            functioning. Therefore: <b>The use of this method is not recommended and left to ILNumerics experts - for very 
            specific and rare situations.</b></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.GetCell(ILNumerics.ILBaseArray[])">
      <summary>
            Retrieve a subcell of this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Subcell definition, arbitrary size</param>
      <returns>A cell with a lazy, shallow clone of the elements of this cell, addressed by <paramref name="indices" /></returns>
      <remarks>The cell returned will have the size and shape specified by <paramref name="indices" />.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.GetEnumerator">
      <summary>
            Enumerator returning elements as scalar cells
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Enumerator</returns>
      <remarks>This method enables the use of cells in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILRetCell.GetHashCode">
      <summary>
            Generate a hash code based on the current arrays values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Hash code</returns>
      <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.GetLimits(ILNumerics.Storage.ILStorage@,ILNumerics.Storage.ILStorage@)">
      <summary>
            Get minimum and maximum value of all elements - if any
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="min">[Output] Minimum value</param>
      <param name="max">[Output] Maximum value</param>
      <returns>true if the limits exists and could be computed, false otherwise</returns>
      <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.GetValue(System.Int32[])">
      <summary>
            Retrieve single element from this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Position of the element</param>
      <returns>Lazy, shallow clone of the element to retrieve or null, if there is no element at this place</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.GetValue``1(System.Int32[])">
      <summary>
            Retrieve a typed single element from within the cell, supports deep indexing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Expected type of the value to be returned</typeparam>
      <param name="indices">Location of the single element addressed</param>
      <returns>A clone of the single element addressed by <paramref name="indices" /></returns>
      <remarks>The element returned will have the type given by <typeparamref name="T" />. It is an error to specify 
            a different type as the true type of the element specified. An exception is thrown if both types differ.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.IsTypeOf``1(ILNumerics.ILBaseArray[])">
      <summary>
            Test if an element of the cell is an array of the given element type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">The array element type to check the cell element against</typeparam>
      <param name="position">Position of the cell element to be tested</param>
      <returns>true if the element found at the given position is an array of the element type <typeparamref name="T" />, false otherwise</returns>
      <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T" />. That means, in order to find out, if the first cell element stores an array of int (<code>ILArray&lt;int&gt;</code>), 
            one may use <code>cell.IsTypeOf&lt;int&gt;(0)</code></para><para>In order to test, if a cell element is of type <code>ILCell</code>, one can provide the type <code>ILCell</code> as type parameter: 
            <code>cell.IsTypeOf&lt;ILCell&gt;(0)</code>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <code>ILCell</code>. The reason of this is: the type of elements of <code>ILCell</code> is 
            an implementation detail and therefore hidden to the user.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
        <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short&gt;(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String&gt;      first element  &lt;Int16&gt; [2,3,4,5,6] 
                     &lt;Double&gt;          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string&gt;(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell&gt;(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short&gt;(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell&gt;(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;&gt; never gives true
            </code></example>
    </member>
    <member name="M:ILNumerics.ILRetCell.Repmat(System.Int32[])">
      <summary>
            Create replication of this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims" /> is 
            less than the number of dimensions in this cell, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
      <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims" /></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.Reshape(ILNumerics.ILSize)">
      <summary>
            Create reshaped copy of this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">New dimensions of the cell</param>
      <returns>Reshaped copy of the cell</returns>
      <remarks>
        <para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="dimensions" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="dimensions" /> do not match the number of elements in this cell.</exception>
    </member>
    <member name="M:ILNumerics.ILRetCell.Serialize(System.IO.Stream)">
      <summary>
             Serialize this ILArray into a binary stream.
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
      <returns>True on success, false on error.</returns>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.Shifted(System.Int32)">
      <summary>
            Dimension shifted cell from this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">Number of dimensions to shift</param>
      <returns>Shifted version of this cell</returns>
      <remarks>
        <para>The shift is done 'to the left':</para>
        <example>
          <code>ILCell A = cell(2,4); 
            ILCell B = A.Shifted(1);
            // B is now: ILCell [4,2] 
            
            ILCell C = cell(2,4,3);
            ILCell D = C.Shifted(1);
            // D is now: ILCell [4,3,2]
            </code>
        </example>
        <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style. </para>
        <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T" /> property for readability.</para>
        <para>
          <paramref name="shift" /> must be positive. It is taken modulus the number of dimensions.</para>
        <seealso cref="P:ILNumerics.ILDenseArray`1.T" />
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.Subarray(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access (readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Address range</param>
      <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
      <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para><para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements stored in the cell.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetCell.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
      <summary>
            Send values of this instance to stream
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="stream">Stream to write the values into.</param>
      <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)" /> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
      <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags" />. Specifies the way in which
            the values will be serialized.</param>
      <remarks>
        <para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
        <para>Writing cells to *.mat files is NOT SUPPORTED yet! </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.C">
      <summary>
            Clone of this cell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays on write access.</para>
        <para>Cells profit from the same efficient clone creation process. However, since a cell may store an arbitrarily deep 
            hierarchy of other cells and arrays, in order to clone a cell, the cell elements have to be cloned as well - in an 
            recursive manner. Clones play an important role for ILNumerics cells. They are used to implement value semantics for cell
            elements. I.e.: the cloned cell returned cannot not be used to alter elements of the original cell in any way.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.S">
      <summary>
            Size descriptor shortcut
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.Size">
      <summary>
            Size descriptor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.IsColumnVector">
      <summary>
            Test if this array instance is a column vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.IsRowVector">
      <summary>
            Test if this array instance is a row vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.IsComplex">
      <summary>
            Determine if this array has complex elements.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.IsEmpty">
      <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.IsMatrix">
      <summary>
            Test if this instance is a matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.IsNumeric">
      <summary>
            Determine if this array holds numeric values.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table"><listheader><term>inner type</term></listheader><item><term>System.double</term><description>floating point, real, 8 bytes </description></item><item><term>System.float</term><description>floating point real, 4 bytes</description></item><item><term>ILNumerics.complex</term><description>floating point complex, 16 bytes</description></item><item><term>ILNumerics.fcomplex</term><description>floating point complex, 8 bytes</description></item><item><term>System.char</term><description>integer, real, 1 byte</description></item><item><term>System.byte</term><description>integer, real, 1 byte</description></item><item><term>System.Int16</term><description>integer, real, 2 byte</description></item><item><term>System.Int32</term><description>integer, real, 4 byte</description></item><item><term>System.Int64</term><description>integer, real, 8 byte</description></item><item><term>System.UInt16</term><description>unsigned integer, real, 2 byte</description></item><item><term>System.UInt32</term><description>unsigned integer, real, 4 byte</description></item><item><term>System.UInt64</term><description>unsigned integer, real, 8 byte</description></item></list><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.IsScalar">
      <summary>
            Test if this instance is a scalar
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This attribute is readonly. It returns: Dimension.NumberOfElements == 1.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.IsVector">
      <summary>
            Test if this array is a vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.Length">
      <summary>
            Length of the longest dimension of this instance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.T">
      <summary>
            Transposed version of this ILCell
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.Name">
      <summary>
            Gets the name of this array (readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.Storage">
      <summary>
            Access to the more specialized version (ILCellStorage) of this storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.Item(System.Int32[])">
      <summary>
            Get/set/remove single element
            <para>[ILNumerics Core Module]</para>
      </summary>
      <paramref name="indices" value="Index to element" />
      <value>Inner element, new inner element or null</value>
      <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example><code>
            ILArray&lt;double&gt; A = ILMath.counter(1,12);
            A[2] gives: 3.0
            </code>But the transpose 
            <code>
            A.T[2] gives also: 3.0
            </code> 
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -&gt; out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example><para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para><para><list type="bullet"><listheader>The type of the element returned depends on the type of the element addressed:</listheader><item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item><item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item><item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item></list></para><para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example><code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code></example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetCell.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access. Get/set regular subarray.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">Address range</param>
      <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
      <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para><para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para><para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example><code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para><para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.ILRetLogical">
      <summary>
            Boolean array for high performance relational operations on arbitrary arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
            Logical arrays store true/false conditions as elements. Each element consumes
            one byte. Logical arrays are the output parameter of all relational comparisons.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
      <summary>
            Constructor creating ILRetLogical from dense storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array, the storage given will directly be used for 
            storage of the new logical array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
      <summary>
            create temporary logical from predefined storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">the storage will directly be used as storage of the new logical array</param>
      <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
      <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.ILSize)">
      <summary>
            create temporary logical array of specified size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
      <remarks>
            The size parameter may not be null or an empty array. An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size a logical temporary array of the specified size 
            will be created. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],System.Int32[])">
      <summary>
            Constructor - create ILRetLogical of specified size 
            from data array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
      <param name="data">byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
      <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILRetLogical of the specified size 
            will be created. The type of storage will be <code>byte</code>.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
      <summary>
            Constructor creating ILRetLogical, provide predefined storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
      <param name="size">Size descriptor</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
      <summary>
            Constructor creating ILRetLogical, predefined storage (fast version)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
      <param name="size">Size descriptor</param>
      <param name="nonZeroCount">Number of nonzero elements in <paramref name="data" />. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.Clone">
      <summary>
            Clone of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
        <para>The clone returned will be of the same type as this instance.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.Concat(ILNumerics.ILInLogical,System.Int32)">
      <summary>
            Concatenate this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">N-dimensional array. Except for dimensions <paramref name="dim" />
            the dimensions of A must match the dimensions of this storage</param>
      <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
      <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.Equals(System.Object)">
      <summary>
            Compare elements and shape of this array with another array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Other array</param>
      <returns>true if shape and element values of both arrays match, false otherwise</returns>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.ExportValues(System.Byte[]@)">
      <summary>
            Copy values of all elements into System.Array.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
      <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.GetEnumerator">
      <summary>
            Enumerator returning elements as ElementType
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Enumerator</returns>
      <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILRetLogical.GetHashCode">
      <summary>
            Generate a hash code based on the current arrays values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Hash code</returns>
      <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.GetLimits(System.Byte@,System.Byte@)">
      <summary>
            Get minimum and maximum value of all elements - if any
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="min">[Output] Minimum value</param>
      <param name="max">[Output] Maximum value</param>
      <returns>true if the limits exists and could be computed, false otherwise</returns>
      <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.GetValue(System.Int32[])">
      <summary>
            Get single element from this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Indices, location of element</param>
      <returns>The requested element</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.Reshape(ILNumerics.ILSize)">
      <summary>
            Create reshaped copy of this logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">New dimensions of the array</param>
      <returns>Reshaped copy of this array</returns>
      <remarks>
        <para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size" /> do not match the number of elements in this array.</exception>
    </member>
    <member name="M:ILNumerics.ILRetLogical.Repmat(System.Int32[])">
      <summary>
            Create replication of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims" /> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
      <returns>Array being created out of multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims" /></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.Serialize(System.IO.Stream)">
      <summary>
             Serialize this ILArray into a binary stream.
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
      <returns>True on success, false on error.</returns>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.Shifted(System.Int32)">
      <summary>
            Create logical array from this logical and shift dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">Number of dimensions to shift</param>
      <returns>Shifted version of this array</returns>
      <remarks>
        <para>The shift is done 'to the left':</para>
        <example>
          <code>ILArray&lt;double&gt; A = zeros(2,4);
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2] 
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code>
        </example>
        <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
        <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T" /> property for readability.</para>
        <para>
          <paramref name="shift" /> must be positive. It is taken modulus the number of dimensions.</para>
        <seealso cref="P:ILNumerics.ILDenseArray`1.T" />
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.Subarray(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray from this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">Arrays specifying the ranges to create subarray from</param>
      <returns>Subarray as specified</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
      <summary>
            Send values of this instance to stream.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="stream">Stream to write the values into.</param>
      <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)" /> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
      <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags" />. Specifies the way in which
            the values will be serialized.</param>
      <remarks>
        <para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
        <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[])~ILNumerics.ILRetLogical">
      <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">1-dimensional system array, arbitrary type</param>
      <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
      <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Array)~ILNumerics.ILRetLogical">
      <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Arbitrarily sized System.Array</param>
      <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
      <remarks>The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILRetLogical">
      <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">2D System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILRetLogical">
      <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">3D System.Array</param>
      <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Boolean)~ILNumerics.ILRetLogical">
      <summary>
            Implicitly convert boolean System.Byte to scalar logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">System.Byte</param>
      <returns>Scalar logical array with value of val.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~System.Boolean">
      <summary>
            Implicitly convert logical array to System.Boolean
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Logical array</param>
      <returns>true if elements of A are non-zero, false otherwise 
            </returns>
      <remarks>If A is null or empty, the function returns false. Otherwise returns true, 
            if all elements of A are non-zero and returns false, if A contains zero elements.
            <para>The behavior depends on the setting of the ILSettings.LogicalArrayToBoolConversion switch.
            Per default, only scalar arrays are allowed to be converted implicitely. This can be changed 
            to implicitely convert non-scalar arrays by using ILMath.any on the array.</para><seealso cref="P:ILNumerics.Settings.LogicalArrayToBoolConversion" /><seealso cref="!:ILNumerics.ILMath.any(ILInArray&lt;double&gt;, int)" /><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Int32)~ILNumerics.ILRetLogical">
      <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="val">Scalar value</param>
      <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILLogical)~ILNumerics.ILRetLogical">
      <summary>
            Convert logical to temporary logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Original logical array</param>
      <returns>Temporary logical array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILInLogical)~ILNumerics.ILRetLogical">
      <summary>
            Convert logical input parameter type array to temporary logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Logical input parameter type</param>
      <returns>Temporary logical array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILOutLogical)~ILNumerics.ILRetLogical">
      <summary>
            Convert logical output parameter type array to temporary logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Logical output parameter type</param>
      <returns>Temporary logical array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~ILNumerics.ILArray{System.Byte}">
      <summary>
            Implicitly cast to ILArray&lt;byte&gt;
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">A ILRetLogical</param>
      <returns>ILArray&lt;byte&gt;</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILArray{System.Byte})~ILNumerics.ILRetLogical">
      <summary>
            Implicitly cast from ILArray&lt;byte&gt;
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">An ILArray&lt;byte&gt;</param>
      <returns>logical return array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~ILNumerics.ILInArray{System.Byte}">
      <summary>
            Implicitly cast from ILInArray&lt;byte&gt;
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">An ILInArray&lt;byte&gt;</param>
      <returns>logical return array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILInArray{System.Byte})~ILNumerics.ILRetLogical">
      <summary>
            Implicitly cast from ILInArray&lt;byte&gt;
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">An ILInArray&lt;byte&gt;</param>
      <returns>logical return array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILRetLogical.op_LogicalNot(ILNumerics.ILRetLogical)">
      <summary>
            Invert values of array elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="in1">Input array</param>
      <returns>New logical array, inverted element values</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.NumberNonZero">
      <summary>
            Number of 'true' elements in this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This value caches the number of 'true' elements in this logical array. 
            It may be used for information purposes but is actually needed internally for performance 
            reasons.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.T">
      <summary>
            Shift the dimensions of this array by one (transpose for matrix)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.C">
      <summary>
            Create clone of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.S">
      <summary>
            Size descriptor shortcut
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.Size">
      <summary>
            Size descriptor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.IsColumnVector">
      <summary>
            Test if this array instance is a column vector (e.g. n x 1)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.IsRowVector">
      <summary>
            Test if this array instance is a row vector (e.g. 1 x n)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.IsComplex">
      <summary>
            Determine if this array has complex elements.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.IsEmpty">
      <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.IsMatrix">
      <summary>
            Test if this instance is a matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.IsNumeric">
      <summary>
            Determine if this array holds numeric values.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table"><listheader><term>inner type</term></listheader><item><term>System.double</term><description>floating point, real, 8 bytes </description></item><item><term>System.float</term><description>floating point real, 4 bytes</description></item><item><term>ILNumerics.complex</term><description>floating point complex, 16 bytes</description></item><item><term>ILNumerics.fcomplex</term><description>floating point complex, 8 bytes</description></item><item><term>System.char</term><description>integer, real, 1 byte</description></item><item><term>System.byte</term><description>integer, real, 1 byte</description></item><item><term>System.Int16</term><description>integer, real, 2 byte</description></item><item><term>System.Int32</term><description>integer, real, 4 byte</description></item><item><term>System.Int64</term><description>integer, real, 8 byte</description></item><item><term>System.UInt16</term><description>unsigned integer, real, 2 byte</description></item><item><term>System.UInt32</term><description>unsigned integer, real, 4 byte</description></item><item><term>System.UInt64</term><description>unsigned integer, real, 8 byte</description></item></list><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.IsScalar">
      <summary>
            Test if this instance is a scalar
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.IsVector">
      <summary>
            Test if this array is a vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.Length">
      <summary>
            Length of the longest dimension of this instance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.Name">
      <summary>
            Gets the name of this array (readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILRetLogical.Item(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray access (readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">Range specification</param>
      <returns>Logical array with the elements specified by range</returns>
      <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying any elements 
            in this array. <c>range</c> may contains index specifications for one ... to any 
            dimension. The array returned will have the size specified by range.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.Data.ILAVLTree">
      <summary>
            AVL balanced search tree
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The tree stores unique keys (type:System.Int64, configurable via build) in a balanced search tree.
            <para>The implementation is optimized for random seek access and consecutive write access - if no matching key found. 
            Also, the next higher key for a given query can be returned in O(1).</para><para>The AVL tree class is not intended to be used directly. It supports the ILNumerics infrastructure (ILMemoryPool) 
            internally.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Data.ILAVLTree.Add(System.Int64)">
      <summary>
            Check and add a key to the collection
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="key">Key</param>
      <remarks>The function makes sure, the key is stored in the tree.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Data.ILAVLTree.Remove(System.Int64)">
      <summary>
            Remove key from tree
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="key">Key to be removed</param>
      <remarks>The function makes sure, the tree does not contain a node with the given key.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Data.ILAVLTree.Next(System.Int64)">
      <summary>
            Find next higher key
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="key">Key to find</param>
      <returns>The key with the next higher value compared with <paramref name="key" />, or -1 if no such key exists</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Data.ILAVLTree.Clear">
      <summary>
            Clear the tree from all keys
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Data.ILAVLTree.CheckTree">
      <summary>
            check the consistency of the tree
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Data.ILAVLTree.Count">
      <summary>
            Return number of keys currently existing in the tree
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Data.ILAVLTree.ILAVLTreeNode">
      <summary>
            an AVL tree node
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.key">
      <summary>
            Key
            </summary>
    </member>
    <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.right">
      <summary>
            Right child
            </summary>
    </member>
    <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.left">
      <summary>
            Left child
            </summary>
    </member>
    <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.balance">
      <summary>
            Balance factor for the node
            </summary>
    </member>
    <member name="M:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.ToString">
      <summary>
            String representation of the node
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>String representation of the node</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Data.ILIntList.GetArray">
      <summary>
            caution! This may bring the ILIntList in inconsistent state!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.abs(ILNumerics.ILInArray{System.Byte})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the Input Array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.abs(ILNumerics.ILInArray{System.Double})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.abs(ILNumerics.ILInArray{System.Single})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.abs(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Magnitude of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Magnitude of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.abs(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Magnitude of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Magnitude of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.abs(ILNumerics.ILInArray{System.Int64})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.abs(ILNumerics.ILInArray{System.Int32})">
      <summary>
Absolute values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Absolute values of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.acosc(ILNumerics.ILInArray{System.Double})">
      <summary>
Arccosine of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.acosc(ILNumerics.ILInArray{System.Single})">
      <summary>
Arccosine of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.acos(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Arccosine values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.acos(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Arccosine values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.acos(ILNumerics.ILInArray{System.Single})">
      <summary>
Arccosine of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.acos(ILNumerics.ILInArray{System.Double})">
      <summary>
Arccosine of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arccosine of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.add(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.add(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.add(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.add(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.add(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.add(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.add(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.add(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Add arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise sum of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.all(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.all(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.all(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.all(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.all(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.all(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.all(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.all(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
Determine, if all elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.allall(ILNumerics.ILInArray{System.Double})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILNumerics.ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.allall(ILNumerics.ILInArray{System.Int64})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILNumerics.ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.allall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILNumerics.ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.allall(ILNumerics.ILInArray{System.Int32})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILNumerics.ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.allall(ILNumerics.ILInArray{System.Byte})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILNumerics.ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.allall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILNumerics.ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.allall(ILNumerics.ILInArray{System.Single})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILNumerics.ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.allall(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Determine if array has nonzero elements in all dimensions
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input Array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILNumerics.ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.and(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.and(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.and(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.and(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.and(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.and(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.and(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.and(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'and' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.any(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.any(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.any(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.any(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.any(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.any(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.any(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.any(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
Determine, if any elements are nonzero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.anyall(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.anyall(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.anyall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.anyall(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.anyall(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.anyall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.anyall(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.anyall(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if array has any nonzero elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Scalar logical array</returns>
      <remarks>
        <para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
        <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.all(ILInArray&lt;double&gt;,int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.apply(System.Func{System.Double,System.Double,System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.apply(System.Func{System.Single,System.Single,System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.apply(System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.apply(System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.apply(System.Func{System.Int64,System.Int64,System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.apply(System.Func{System.UInt32,System.UInt32,System.UInt32},ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.apply(System.Func{System.Int32,System.Int32,System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.apply(System.Func{System.Byte,System.Byte,System.Byte},ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Apply an arbitrary function to two arrays
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>The combination of A and B. The result and size depends on the inputs:<list type="table"><item><term>size(A) == size(B)</term><description>Same size as A/B, elementwise combination of A and B.</description></item><item><term>isscalar(A) || isscalar(B)</term><description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description></item><item><term>All other cases</term><description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description></item></list></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.array``1(``0,ILNumerics.ILSize)">
      <summary>
            Create new array, fill elements with constant value
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="value">Constant value for all elements</param>
      <param name="size">Size of new array</param>
      <returns>New array according to size with all elements set to 'value'</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.array``1(``0,System.Int32[])">
      <summary>
            Create new array, fill element with constant value
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="value">Constant value for all elements</param>
      <param name="size">Size of new array</param>
      <returns>New array according to size with all elements set to 'value'</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.array``1(``0[],System.Int32[])">
      <summary>
            Create array, given elements and size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">System.Array of predefined elements</param>
      <param name="size">Size of every dimension for the new array, must correspond to the number of elements in <paramref name="elements" />.</param>
      <returns>Newly created array</returns>
      <remarks>
        <para>The System.Array given as <paramref name="elements" />is taken 
            as storage for the new array without copy. Make sure not to reference that 
            System.Array directly afterwards.</para>
        <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.array``1(``0[],ILNumerics.ILSize)">
      <summary>
            Create array, given elements and size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">System.Array of predefined elements</param>
      <param name="size">Size of the new array, must correspond to the number of elements in <paramref name="elements" />.</param>
      <returns>Newly created array</returns>
      <remarks>
        <para>The System.Array given as <paramref name="elements" />is taken 
            as storage for the new array without copy. Make sure not to reference that 
            System.Array directly afterwards.</para>
        <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool. 
            </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.array``1(ILNumerics.ILSize,``0[])">
      <summary>
            Create array, given elements and size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">Variable argument list with elements</param>
      <param name="size">Size of the new array, must correspond to the number of elements in <paramref name="elements" />.</param>
      <returns>Newly created array</returns>
      <remarks>
        <para>The elements given as <paramref name="elements" /> are used 
            for the new array without copy. For <typeparamref name="T" /> being a reference type, make sure not to reference any  
            elements directly afterwards.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.array``1(``0[])">
      <summary>
            Create column vector from given elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">List of elements</param>
      <returns>Newly created vector with elements given</returns>
      <remarks>
        <para>If an System.Array was given as params argument, the array is directly taken 
            as storage for the new array without copy. Make sure not to reference the 
            System.Array directly afterwards!</para>
        <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool.</para>
        <para>The shape of the vector created is controlled by the setting switch <see cref="P:ILNumerics.Settings.CreateRowVectorsByDefault" />.
            This switch defaults to <c>false</c> which will cause the creation of a column vector. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <see cref="!:ILNumerics.ILMath.row&lt;T&gt;(T[])" />
      <see cref="!:ILNumerics.ILMath.column&lt;T&gt;(T[])" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.row``1(``0[])">
      <summary>
            Create row vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">Elements of the row vector</param>
      <returns>New row vector</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.column``1(``0[])">
      <summary>
            Create column vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">Elements of the column vector</param>
      <returns>New column vector</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.asinc(ILNumerics.ILInArray{System.Single})">
      <summary>
Arcsine of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.asinc(ILNumerics.ILInArray{System.Double})">
      <summary>
Arcsine of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.asin(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Arcsine values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.asin(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Arcsine values of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.asin(ILNumerics.ILInArray{System.Single})">
      <summary>
Arcsine of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.asin(ILNumerics.ILInArray{System.Double})">
      <summary>
Arcsine of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arcsine of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.atan(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Arctangent of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arctangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.atan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Arctangent of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arctangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.atan(ILNumerics.ILInArray{System.Single})">
      <summary>
Arctangent of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arctangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.atan(ILNumerics.ILInArray{System.Double})">
      <summary>
Arctangent of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Arctangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.atan2(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Arcus tangens of elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise arcus tangens of both inputs</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.atan2(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Arcus tangens of elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise arcus tangens of both inputs</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitnot(ILNumerics.ILInArray{System.Int32})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitnot(ILNumerics.ILInArray{System.Byte})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitnot(ILNumerics.ILInArray{System.SByte})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitnot(ILNumerics.ILInArray{System.UInt64})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitnot(ILNumerics.ILInArray{System.Int64})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitnot(ILNumerics.ILInArray{System.UInt32})">
      <summary>
Bitwise 'not' of elements in A.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with the result of bitwise 'not' for element in A.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>The .NET bitwise negation operator is used for the actual operation. See details here: https://msdn.microsoft.com/en-us/library/d2bd4x66.aspx </para>
        <para>ILNumerics arrays overload the unary ~ operator. One may use the ~ operator in order to 
            create the bitwise negation. However, at the end, the ~ operator utilizes this bitnot() function internally, hence it 
            serves as a shortcut only.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitor(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Bitwise 'or' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'or' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitor(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Bitwise 'or' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'or' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitor(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Bitwise 'or' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'or' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitxor(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Bitwise 'xor' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'xor' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitxor(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Bitwise 'xor' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'xor' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitxor(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Bitwise 'xor' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'xor' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitand(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Bitwise 'and' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'and' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitand(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Bitwise 'and' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'and' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.bitand(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Bitwise 'and' of elements in A and B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the result of bitwise 'and' for As and Bs elements.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cart2pol(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">X coordinates</param>
      <param name="Y">Y coordinates</param>
      <param name="Z">Z coordinates (height)</param>
      <param name="outRadius">[Output] Radius if not null on entry</param>
      <param name="outZ">[Output] Z if not null on entry</param>
      <returns>Angles; radius and Z are returned as output parameters, if on entry not null</returns>
      <remarks>Theta, radius and Z must be the same size or either one may be scalar. 
            Polar coordinate arrays returned are of the same size then the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cart2pol(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">X coordinates</param>
      <param name="Y">Y coordinates</param>
      <param name="Z">Z coordinates (height)</param>
      <param name="outRadius">[Output] Radius if not null on entry</param>
      <param name="outZ">[Output] Z if not null on entry</param>
      <returns>Angles; radius and Z are returned as output parameters, if on entry not null</returns>
      <remarks>Theta, radius and Z must be the same size or either one may be scalar. 
            Polar coordinate arrays returned are of the same size then the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ccomplex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create complex array from real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Array with real part elements</param>
      <param name="imag">Array with imaginary part elements</param>
      <returns>Complex array constructed out of real and imaginary parts</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same and neither of 
            the input is scalar.</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ccomplex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Create complex array from real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Array with real part elements</param>
      <param name="imag">Array with imaginary part elements</param>
      <returns>Complex array constructed out of real and imaginary parts</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same and neither of 
            the input is scalar.</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ceil(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Round towards positive infinity
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded up to next integer value</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ceil(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Round towards positive infinity
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded up to next integer value</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ceil(ILNumerics.ILInArray{System.Single})">
      <summary>
Round towards positive infinity
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded up to next integer value</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ceil(ILNumerics.ILInArray{System.Double})">
      <summary>
Round towards positive infinity
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded up to next integer value</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cell(ILNumerics.ILBaseArray[])">
      <summary>
            Create a cell row vector from given arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be copied inside the cell</param>
      <returns>Cell vector</returns>
      <remarks>
        <para>The new cell will be created as vector, having the array 'values' given as parameter as cell elements. Those elements will 
            be protected by changes from outside the cell.</para>
        <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <example>
        <para>A common use of the <c>cell</c> function is the concatenation of arrays and constants for subarray definitions, as shown in the following example:</para>
        <code>
            ILArray&lt;double&gt; A = counter(4,3,2); 
            A
            //&lt;Double&gt; [4,3]
            // 1          5          9 
            // 2          6         10 
            // 3          7         11 
            // 4          8         12 
            
            // extract 1st, 2nd and last row:
            ILArray&lt;double&gt; B = A[cell(0,1,end),full]; 
            B
            //&lt;Double&gt; [3,3]
            // 1          5          9 
            // 2          6         10 
            // 4          8         12 
            </code>
        <para>Here, <c>cell</c> is used to concatenate individual indices determining the rows to select for the subarray. Using a cell here is convenient, because arbitrary types 
            can be stored in cells - integer, floating point types or special placeholders, like expressions (<see cref="!:ILNumerics.ILMath.end" /> and <see cref="!:ILNumerics.ILMath.full" />).</para>
      </example>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cell(ILNumerics.ILSize,ILNumerics.ILBaseArray[])">
      <summary>
            Create cell, initialize with arrays and size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Size of the new cell</param>
      <param name="arrays">List of arrays for the cell elements, column major order</param>
      <returns>Cell of specified size, initialized with arrays</returns>
      <remarks>If number of arrays given is smaller than the number of elements given by <paramref name="size" />, trailing 
            elements in the cell returned will be set to null.
            <para>The <see cref="M:ILNumerics_ILMath_size(params int[])" /> function is convenient for the specification of size descriptors.</para><para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>
            ILArray&lt;double&gt; A = rand(10,20,30); 
            ILCell C = cell(size(3,2),A, A+1, zeros(2,3)); 
            C
            //Cell [3,2]
            // &lt;Double&gt; [10,20,30]          &lt;String&gt;        4th element  
            // &lt;Double&gt; [10,20,30]                                 (null)
            // &lt;Double&gt; [2,3]                                      (null)
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cell(ILNumerics.ILBaseArray[],System.Int32[])">
      <summary>
            Create cell, initialize with arrays and size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Predefined array with arrays, directly be used as new cell element storage</param>
      <param name="size">Size of newly created cell</param>
      <returns>Cell with size of <paramref name="size" /> and elements from <paramref name="arrays" /></returns>
      <remarks>The array given in <paramref name="arrays" /> is directly be used for the newly created cell. Make sure, not 
            to reference the system array afterwards. However, arrays  referenced from within the parameter <paramref name="arrays" /> 
            are stored as clone into the new cell. Therefore, those arrays are properly protected from changes by altering any array outside the cell.
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[])" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.checknull``1(ILNumerics.ILInArray{``0},System.Func{ILNumerics.ILRetArray{``0}})">
      <summary>
            Check if A is valid, assign default on null
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="A">Input parameter</param>
      <param name="onNull">Function executed only if A is null. Used for providing a default value for A in this case.</param>
      <returns>Result of evaluation(A) or A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.check``1(ILNumerics.ILInArray{``0},System.Func{ILNumerics.ILInArray{``0},ILNumerics.ILRetArray{``0}},System.Boolean,System.String,ILNumerics.ILInArray{``0})">
      <summary>
            Check if A is a valid parameter
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="A">Input parameter</param>
      <param name="ErrorMessage">[optional] Exception message</param>
      <param name="evaluation">[optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
      <param name="allowNullInput">[optional] Only if A is null -&gt; for true: returns null, false: throws exception. If <paramref name="Default" /> was defined, this parameter is ignored.</param>
      <param name="Default">[optional] If <paramref name="A" /> is null on input, this value is returned. If no default is given (i.e: null), <paramref name="allowNullInput" /> is evaluated.</param>
      <returns>Result of evaluation(A) or A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput" /> is false</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.check(ILNumerics.ILInLogical,System.Func{ILNumerics.ILInLogical,ILNumerics.ILRetLogical},System.Boolean,System.String)">
      <summary>
            Check if A is a valid parameter
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input parameter</param>
      <param name="ErrorMessage">[optional] Exception message</param>
      <param name="evaluation">[optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
      <param name="allowNullInput">[optional] Only if A is null -&gt; for true: returns null, false: throws exception</param>
      <returns>Result of evaluation(A) or A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput" /> is false</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.check(ILNumerics.ILInCell,System.Func{ILNumerics.ILInCell,ILNumerics.ILRetCell},System.Boolean,System.String)">
      <summary>
            Check if A is a valid parameter
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input parameter</param>
      <param name="ErrorMessage">[Optional] Exception message</param>
      <param name="evaluation">[Optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
      <param name="allowNullInput">[Optional] Only if A is null -&gt; true: returns null, false: throws exception</param>
      <returns>Result of evaluation(A) or A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput" /> is false</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.chol(ILNumerics.ILInArray{System.Double},System.Boolean)">
      <summary>
Cholesky factorization
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br /> 
            The elements of A will not be altered.</param>
      <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
      <returns>Cholesky factorization</returns>
      <remarks>
        <para>If <paramref name="throwException" /> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.chol(ILNumerics.ILInArray{System.Single},System.Boolean)">
      <summary>
Cholesky factorization
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br /> 
            The elements of A will not be altered.</param>
      <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
      <returns>Cholesky factorization</returns>
      <remarks>
        <para>If <paramref name="throwException" /> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.chol(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
Cholesky factorization
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br /> 
            The elements of A will not be altered.</param>
      <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
      <returns>Cholesky factorization</returns>
      <remarks>
        <para>If <paramref name="throwException" /> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.chol(ILNumerics.ILInArray{ILNumerics.complex},System.Boolean)">
      <summary>
Cholesky factorization
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br /> 
            The elements of A will not be altered.</param>
      <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
      <returns>Cholesky factorization</returns>
      <remarks>
        <para>If <paramref name="throwException" /> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.conj(ILNumerics.ILInArray{System.Double})">
      <summary>
            Complex conjugate of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>The array itself</returns>
      <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.conj(ILNumerics.ILInArray{System.Single})">
      <summary>
            Complex conjugate of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>The array itself</returns>
      <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.conj(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Complex conjugate of array A
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex conjugate of array A</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.conj(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Complex conjugate of array A
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex conjugate of array A</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.convert``2(ILNumerics.ILInArray{``0})">
      <summary>
            Convert a numeric array to another numeric type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <typeparam name="inT">Type of array to convert</typeparam>
      <typeparam name="outT">Type of array to return</typeparam>
      <returns>Converted array</returns>
      <remarks> The newly created array will be converted to the required type. 
            <para>The array returned will always use new memory! Even if the type requested 
            matches the incoming type.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{System.UInt64})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{System.Int16})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>double array</returns>
      <remarks>
        <para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to float array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array</param>
      <returns>float array</returns>
      <remarks>
        <para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>complex array</returns>
      <remarks>
        <para>Real input arrays will be converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>fcomplex array</returns>
      <remarks>
        <para>Real input arrays are converted to the real part of the complex array returned.</para>
        <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to byte array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>byte array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tological(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to logical array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Logical array</returns>
      <remarks>
        <para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to Int32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int32 array</returns>
      <remarks>
        <para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to UInt32 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>UInt32 array</returns>
      <remarks>
        <para>The function converts elements of X to UInt32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to Int64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert numeric array to UInt64 array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array </param>
      <returns>Int64 array</returns>
      <remarks>
        <para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.todouble(ILNumerics.ILBaseArray)">
      <summary>
            convert arbitrary numeric array to double array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>double array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint64(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to UInt64 array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>UInt64 (ulong) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint64(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to Int64 array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>Int64 (long) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.touint32(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to UInt32 array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>UInt32 (uint) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint32(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to Int32 array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>Int32 (int) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.toint16(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to Int16 array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>Int16 (short) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tobyte(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to byte array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>byte array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tofcomplex(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to fcomplex array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>fcomplex array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tocomplex(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to complex array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>complex array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tosingle(ILNumerics.ILBaseArray)">
      <summary>
convert arbitrary numeric array to float array
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="X">numeric array, one of supported numeric type</param>
      <returns>Single (float) array</returns>
      <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para><para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cos(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Cosine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cos(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Cosine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cos(ILNumerics.ILInArray{System.Single})">
      <summary>
Cosine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cos(ILNumerics.ILInArray{System.Double})">
      <summary>
Cosine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cosh(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Hyperbolic cosine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cosh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic cosine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cosh(ILNumerics.ILInArray{System.Single})">
      <summary>
Hyperbolic cosine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cosh(ILNumerics.ILInArray{System.Double})">
      <summary>
Hyperbolic cosine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic cosine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.counter(ILNumerics.ILBaseArray[])">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <returns>Double array with elements counting from 1 to dimensions.NumberOfElements</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.counter(System.Int32[])">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <returns>Double array with elements counting from 1 ... dimensions.NumberOfElements</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.counter(System.Double,System.Double,ILNumerics.ILBaseArray[])">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <param name="start">Starting number</param>
      <param name="inc">Incrementing step</param>
      <returns>Double array with elements counting from start to start + (dimensions.NumberOfElements * inc)</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.counter(System.Double,System.Double,ILNumerics.ILSize)">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <param name="start">Starting number</param>
      <param name="inc">Incrementing step</param>
      <returns>Double array with elements counting from start to start + (dimensions.NumberOfElements * inc)</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.counter(ILNumerics.ILSize)">
      <summary>
            Create n-dimensional array with elements counting from 1, double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
      <returns>Double array with elements counting from 1 ... dimensions.NumberOfElements</returns>
      <remarks>This function may be used for the convenient creation of arrays for testing purposes.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.counter``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray[])">
      <summary>
            Create n-dimensional array with counting elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">Initial value</param>
      <param name="increment">Increment for each element</param>
      <param name="dimensions">Variable number of numeric, scalar arrays with dimension specification</param>
      <returns>Array with elements counting from <paramref name="start" /> along the first dimension with steps of <paramref name="increment" />.</returns>
      <remarks>
        <example>
          <code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // This will create an array with all elements having contant value of -4f:
            // (note: start, increment and dimension specifier do not need to be of the same type)
            <![CDATA[ILArray<float> A = ILMath.counter<float>(4.0,0,4,3,2);]]></code>
        </example>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.counter``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILSize)">
      <summary>
            Create n-dimensional array with counting elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">Initial value</param>
      <param name="increment">Increment for each element</param>
      <param name="dimensions">Variable int array with dimension specification</param>
      <returns>Array with elements counting from <paramref name="start" /> to dimensions.NumberOfElements - <paramref name="start" />.</returns>
      <remarks>
        <example>
          <code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // This will create an array with all elements having contant value of -4f:
            // (note: start, increment and dimension specifier do not need to be of the same type)
            <![CDATA[ILArray<float> A = ILMath.counter<float>(4.0,0,4,3,2);]]></code>
        </example>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cross(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Boolean)">
      <summary>
            Cross products of columns of two arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First array with vectors in columns</param>
      <param name="B">Second array with vectors in columns</param>
      <param name="normalize">If true: normalize resulting vectors to length 1.0.</param>
      <returns>Array with cross products of vectors from A and B</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cross(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Boolean)">
      <summary>
            Cross products of columns of two arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First array with vectors in columns</param>
      <param name="B">Second array with vectors in columns</param>
      <param name="normalize">If true: normalize resulting vectors to length 1.0.</param>
      <returns>Array with cross products of vectors from A and B</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.csvread``1(System.String,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String,System.Globalization.CultureInfo)">
      <summary>
            Reads comma seperated values from lines in a string, optionally using custom separators, element and number formats.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type to return.</typeparam>
      <param name="csvData">String with CSV data in lines.</param>
      <param name="startRow">[optional] Start reading the values from that row. Default: 0.</param>
      <param name="startCol">[optional] Start reading values from that column. Default: 0.</param>
      <param name="endRow">[optional] Index of the last row to take into account. Default: last row in <paramref name="csvData" />.</param>
      <param name="endCol">[optional] Index of the last column to take into account. Default: last column in <paramref name="csvData" />.</param>
      <param name="elementConverter">[optional] Custom function to convert each element from its string representation. Default: parse as <see cref="T:System.Double" />.</param>
      <param name="elementSeparator">[optional] String seperating individual elements. Default: , (comma)</param>
      <param name="culture">[optional] Number format used while parsing individual elements. Default: invariant culture (not current thread culture!)</param>
      <returns>Matrix with elements read from <paramref name="csvData" />.</returns>
      <remarks>
        <para>The data lines in <paramref name="csvData" /> is parsed using <paramref name="elementSeparator" /> as element 
            separator. Arbitrary element types <typeparamref name="T" /> can be parsed by providing a customized function 
            <paramref name="elementConverter" /> for parsing individual elements. The current threads culture is temporarily changed to use the 
            <see href="System.Globalization.NumberFormatInfo">number format info</see> provided in <paramref name="culture" />. The number 
            format provides the parser with info about decimal separators among others used to determine number formats for parsing.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.csvread``1(System.IO.Stream,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String,System.Globalization.CultureInfo,System.Text.Encoding)">
      <summary>
            Reads comma seperated values from stream, optionally using custom separators, element and number formats.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type to return.</typeparam>
      <param name="stream">Stream with CSV data in lines.</param>
      <param name="startRow">[optional] Start reading the values from that row. Default: 0.</param>
      <param name="startCol">[optional] Start reading values from that column. Default: 0.</param>
      <param name="endRow">[optional] Index of the last row to take into account. Default: last row in <paramref name="stream" />.</param>
      <param name="endCol">[optional] Index of the last column to take into account. Default: last column in <paramref name="stream" />.</param>
      <param name="elementConverter">[optional] Custom function to convert each element from its string representation. Default: parse as <see cref="T:System.Double" />.</param>
      <param name="elementSeparator">[optional] String seperating individual elements. Default: , (comma)</param>
      <param name="culture">[optional] Number format used while parsing individual elements. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[optional] Encoding used to read bytes from stream. Default: ASCII encoding.</param>
      <returns>Matrix with elements read from <paramref name="stream" />.</returns>
      <remarks>
        <para>The data lines in <paramref name="stream" /> are parsed using <paramref name="elementSeparator" /> as element 
            separator. Arbitrary element types <typeparamref name="T" /> can be parsed by providing a customized function 
            <paramref name="elementConverter" /> for parsing individual elements. The current threads culture is temporarily changed to use the 
            <see href="System.Globalization.CultureInfo">number format info</see> provided in <paramref name="culture" />. The number 
            format of the given culture provides the parser with info about decimal separators among others used to determine number formats for parsing.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.CSVParseDoubleAs``1(System.String)">
      <summary>
            Parses an input string to double first, than converts it if the given T type is different.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Type to return with.</typeparam>
      <param name="element">CSV element to parse.</param>
      <returns>Parsed CSV element with a type of T.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.csvreadinternal``1(ILNumerics.Misc.ILCSVLinesProvider{``0},System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String)">
      <summary>
            Private generalization of reading CSV files. 
            The method hides stream/string input with CsvHelper class. 
            It allows the user to specify special functions to convert their special data.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type to return.</typeparam>
      <param name="helper">CsvHelper to hide stream/string inputs.</param>
      <param name="startRow">[optional] Start reading the values from that row. Default: 0.</param>
      <param name="startCol">[optional] Start reading values from that column. Default: 0.</param>
      <param name="endRow">[optional] Index of the last row to take into account. Default: last row in <paramref name="helper" />.</param>
      <param name="endCol">[optional] Index of the last column to take into account. Default: last column in <paramref name="helper" />.</param>
      <param name="elementParser">[optional] Element parser funtion.</param>
      <param name="elementSeparator">[optional] String seperating individual elements. Default: , (comma)</param>
      <returns>Matrix with elements read from source wrapped by helper.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.CSVParseComplex(System.String)">
      <summary>
            Parses an input string to a complex number.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">CSV element, string representation of a complex number.</param>
      <returns>Complex number as ILNumerics.complex type.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.CSVParseFComplex(System.String)">
      <summary>
            Parses an input string to a single precision complex number.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="element">CSV element, string representation of a complex number.</param>
      <param name="culture">[optional] Culture format info. Default: invariant culture.</param>
      <returns>Complex number as ILNumerics.fcomplex type.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.csvwrite``1(ILNumerics.ILInArray{``0},System.IO.Stream,System.Func{``0,System.String},System.String,System.Globalization.CultureInfo,System.Text.Encoding)">
      <summary>
            Write ILNumerics array as seperated strings to stream
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type of input array A</typeparam>
      <param name="A">ILNumerics array to write as CSV. This is expected to be a matrix.</param>
      <param name="stream">Stream to write values to.</param>
      <param name="elementConverter">[optional] Custom function used to convert elements of A to string. Default: [T].ToString()</param>
      <param name="elementSeparator">[optional] Character chain used to seperate individual elements. Default: ',' (comma).</param>
      <param name="culture">[optional] Number format info used to acquire formatting information for converting numbers to string. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[optional] Encoding used to write the string representation of individual elements to the bytes of the stream.</param>
      <remarks>
        <para>A is expected to be a matrix. If A has more than 2 dimensions trailing dimensions will be joined to the second dimension. This corresponds to: A[":;:"].</para>
        <para>The optional parameters <paramref name="elementConverter" />, <paramref name="elementSeparator" /> and <paramref name="culture" />
            are used to control the format of the resulting CSV result.<paramref name="elementConverter" /> is used to convert a single element of <paramref name="A" /> into its string representation, using the current cultures number format or the <see cref="T:System.Globalization.CultureInfo" /> provided by <paramref name="culture" />.</para>
        <para>Individual elements will be seperated in the CSV result by ',' (comma) or by the character chain provided by <paramref name="elementSeparator" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.csvwrite``1(ILNumerics.ILInArray{``0},System.String,System.Func{``0,System.String},System.String,System.Globalization.CultureInfo,System.Text.Encoding)">
      <summary>
            Write ILNumerics array as seperated strings to file
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type of input array A</typeparam>
      <param name="A">ILNumerics array to write as CSV. This is expected to be a matrix.</param>
      <param name="filename">Name of the file to write values to.</param>
      <param name="elementConverter">[optional] Custom function used to convert elements of A to string. Default: [T].ToString()</param>
      <param name="elementSeparator">[optional] Character chain used to seperate individual elements. Default: ',' (comma).</param>
      <param name="culture">[optional] Number format info used to acquire formatting information for converting numbers to string. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[optional] Encoding used to write the string representation of individual elements to the bytes of the file.</param>
      <remarks>
        <para>A is expected to be a matrix. If A has more than 2 dimensions trailing dimensions will be joined to the second dimension. This corresponds to: A[":;:"].</para>
        <para>The optional parameters <paramref name="elementConverter" />, <paramref name="elementSeparator" /> and <paramref name="culture" />
            are used to control the format of the resulting CSV result.<paramref name="elementConverter" /> is used to convert a single element of <paramref name="A" /> into its string representation, using the current cultures number format or the <see cref="T:System.Globalization.CultureInfo" /> provided by <paramref name="culture" />.</para>
        <para>Individual elements will be seperated in the CSV result by ',' (comma) or by the character chain provided by <paramref name="elementSeparator" />.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumprod(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>For integer element types, the result of cumprod is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumprod(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>For integer element types, the result of cumprod is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumprod(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>For integer element types, the result of cumprod is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumprod(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>For integer element types, the result of cumprod is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumprod(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>For integer element types, the result of cumprod is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumprod(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>For integer element types, the result of cumprod is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumprod(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>For integer element types, the result of cumprod is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumprod(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Cumulative product along elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative products of elements in A</returns>
      <remarks>For integer element types, the result of cumprod is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumsum(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Cumulative sum of elements along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>For integer element types of A, the result of cumsum is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumsum(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Cumulative sum of elements along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>For integer element types of A, the result of cumsum is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumsum(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
            Cumulative sum of elements along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>For integer element types of A, the result of cumsum is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumsum(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Cumulative sum of elements along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>For integer element types of A, the result of cumsum is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumsum(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Cumulative sum of elements along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>For integer element types of A, the result of cumsum is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumsum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Cumulative sum of elements along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>For integer element types of A, the result of cumsum is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumsum(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Cumulative sum of elements along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>For integer element types of A, the result of cumsum is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.cumsum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Cumulative sum of elements along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length &gt; 1).</param>
      <returns>Array of the same size as A with cumulative sums of elements in A</returns>
      <remarks>For integer element types of A, the result of cumsum is not clamped to the limits of the data type. Be aware of overflows!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.det(ILNumerics.ILInArray{System.Double})">
      <summary>
             Determinant of square matrix
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix (square)</param>
      <returns>Determinant of A</returns>
      <remarks>
        <para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br />
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
        <para>For scalar A, a plain copy of A is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.det(ILNumerics.ILInArray{System.Single})">
      <summary>
             Determinant of square matrix
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix (square)</param>
      <returns>Determinant of A</returns>
      <remarks>
        <para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br />
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
        <para>For scalar A, a plain copy of A is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.det(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
             Determinant of square matrix
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix (square)</param>
      <returns>Determinant of A</returns>
      <remarks>
        <para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br />
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
        <para>For scalar A, a plain copy of A is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.det(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
             Determinant of square matrix
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix (square)</param>
      <returns>Determinant of A</returns>
      <remarks>
        <para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br />
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
        <para>For scalar A, a plain copy of A is returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diag(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diag(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diag(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diag(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diag(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diag(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diag(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diag``1(ILNumerics.ILInArray{``0},System.Int32)">
      <summary>
            Diagonal matrix or diagonal of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
      <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition &gt; 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
      <returns>Depending on 'X' a matrix or a vector with the elements on a diagonal.</returns>
      <remarks>The type of the ILArray returned will be the same as the type of X.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(System.Int32,ILNumerics.ILInArray{System.Double})">
      <summary>
            First derivative along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimensions to create derivative along</param>
      <returns>array with first derivative of A along dimension <c>dim</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(ILNumerics.ILInArray{System.Int64},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(System.Int32,ILNumerics.ILInArray{System.Int64})">
      <summary>
            First derivative along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimensions to create derivative along</param>
      <returns>array with first derivative of A along dimension <c>dim</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(ILNumerics.ILInArray{System.UInt32},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(System.Int32,ILNumerics.ILInArray{System.UInt32})">
      <summary>
            First derivative along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimensions to create derivative along</param>
      <returns>array with first derivative of A along dimension <c>dim</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(ILNumerics.ILInArray{System.Int32},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(System.Int32,ILNumerics.ILInArray{System.Int32})">
      <summary>
            First derivative along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimensions to create derivative along</param>
      <returns>array with first derivative of A along dimension <c>dim</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(ILNumerics.ILInArray{System.Byte},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(System.Int32,ILNumerics.ILInArray{System.Byte})">
      <summary>
            First derivative along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimensions to create derivative along</param>
      <returns>array with first derivative of A along dimension <c>dim</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(System.Int32,ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            First derivative along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimensions to create derivative along</param>
      <returns>array with first derivative of A along dimension <c>dim</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(System.Int32,ILNumerics.ILInArray{System.Single})">
      <summary>
            First derivative along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimensions to create derivative along</param>
      <returns>array with first derivative of A along dimension <c>dim</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Take n-th derivative
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
      <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
      <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diff(System.Int32,ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            First derivative along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimensions to create derivative along</param>
      <returns>array with first derivative of A along dimension <c>dim</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.size(ILNumerics.ILBaseArray)">
      <summary>
            Size of dimensions of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Double array with the length of each dimension of A</returns>
      <remarks>If A is null, an empty array will be returned. Otherwise the array returned will always be a row vector of length s. s &gt;= 2<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.size(ILNumerics.ILBaseArray,System.Int32)">
      <summary>
            Length of one specific dimension of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Number of dimension to query the length for</param>
      <returns>Length of dimension 'dim'</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.size(System.Int32[])">
      <summary>
            Create a size descriptor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">Arbitrary number of dimension length</param>
      <returns>Size descriptor</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.length(ILNumerics.ILBaseArray)">
      <summary>
            Longest dimension of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>If A is null:0 - length of longest dimension of A</returns>
      <remarks>This is an alias/abreviation for A.Dimensions.Longest<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ndims(ILNumerics.ILBaseArray)">
      <summary>
            Number of dimensions of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>If A is null: 0 - else number of dimensions of A</returns>
      <remarks>This is an alias/abreviation for A.Dimensions.NumberOfDimensions<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.numel(ILNumerics.ILBaseArray)">
      <summary>
            Number of elements of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Number of elements of A</returns>
      <remarks>This is an alias/abreviation for A.Dimensions.NumberOfElements<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.distL1(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.distL1(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.distL1(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.distL1(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.distL1(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.distL1(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            pairwise L1 distance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input points (matrix)</param>
      <param name="B">input point (vector)</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" /> 
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is cummulative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.divide(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Divide elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.divide(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Divide elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.divide(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Divide elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.divide(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Divide elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.divide(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Divide elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.divide(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Divide elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.divide(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Divide elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.divide(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Divide elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise division of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{System.Double})">
      <summary>
            Compute eigenvalues of general square matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
      <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n]</param>
      <param name="V">Output (optional): eigenvectors</param>
      <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
      <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
      <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> 
            or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
        <para>Depending on the parameter <paramref name="balance" />, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Double})">
      <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <returns>Array of size [n,1] with eigenvalues of A in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
      <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /></exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Double,System.Double)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
      <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /> or if either one is &lt;= 0.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{System.Single})">
      <summary>
            Compute eigenvalues of general square matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
      <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n]</param>
      <param name="V">Output (optional): eigenvectors</param>
      <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
      <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
      <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> 
            or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
        <para>Depending on the parameter <paramref name="balance" />, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Single})">
      <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <returns>Array of size [n,1] with eigenvalues of A in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
      <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /></exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Single,System.Single)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
      <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /> or if either one is &lt;= 0.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Compute eigenvalues of general square matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
      <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n]</param>
      <param name="V">Output (optional): eigenvectors</param>
      <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
      <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
      <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> 
            or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
        <para>Depending on the parameter <paramref name="balance" />, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <returns>Array of size [n,1] with eigenvalues of A in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
      <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /></exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Single,System.Single)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
      <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /> or if either one is &lt;= 0.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Compute eigenvalues of general square matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A. Size [n x n]</param>
      <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
      <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
        <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.eig(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n]</param>
      <param name="V">Output (optional): eigenvectors</param>
      <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
      <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
      <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
      <remarks>
        <para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;)" /> 
            or <see cref="!:ILNumerics.ILMath.eigSymm(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
        <para>Depending on the parameter <paramref name="balance" />, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.eig(ILInArray&lt;double&gt;,ILOutArray&lt;complex&gt;,ref MatrixProperties,bool)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <returns>Array of size [n,1] with eigenvalues of A in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
      <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /></exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Double,System.Double)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
      <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
      <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
        <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" /> or if either one is &lt;= 0.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <returns>Vector of eigenvalues. size [n x 1]</returns>
      <remarks>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
      <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <returns>Vector of eigenvalues. size [n x 1]</returns>
      <remarks>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
      <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <returns>Vector of eigenvalues. size [n x 1]</returns>
      <remarks>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
      <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <returns>Vector of eigenvalues. size [n x 1]</returns>
      <remarks>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
      <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
      <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
      <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
      <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
      <remarks>
        <para>The eigenvectors in 'V' are not normalized!</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck" /> is false and either A and/or B was found not to be symmetric/hermitian</exception>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.empty">
      <summary>
            Create empty double array of size [0,0].
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.empty``1(ILNumerics.ILSize)">
      <summary>
            Create empty double array of specific size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">(Empty-) size of new empty array</param>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.empty``1(System.Int32[])">
      <summary>
            Create empty double array of specific size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">(Empty-) size of new empty array</param>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.empty``1">
      <summary>
            Create empty array of size [0,0] and arbitrary element type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.empty(ILNumerics.ILSize)">
      <summary>
            Create empty double array of specific size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">(Empty-) size of new empty array</param>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.empty(System.Int32[])">
      <summary>
            Create empty double array of specific size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">(Empty-) size of new empty array</param>
      <returns>Empty array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.localMember``1">
      <summary>
            Create new empty array, used for array class member initialization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <returns>Empty array which can afterwards be used for arbitrary assignements (Assign(), or 'array.A = ..' assignements)</returns>
      <remarks>The array returned will be an empty array initially. Its main purpose is to provide 
            a persistant array initialization. The array will not be disposed after leaving the current scope
            and can therefore be utilized for initializing class attributes. After initialization, use the 'ILArray.A = ...' property (C#) 
            or the ILArray.Assign() function to assign new values to the array.<para>[ILNumerics Core Module]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.localLogical">
      <summary>
            Create new empty logical array, used for logical class member (attributes) initialization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Empty logical array which can afterwards be used for arbitrary assignements (Assign(), or 'array.A = ..' assignements)</returns>
      <remarks>The logical array returned will be an empty logical array initially. Its main purpose is to provide 
            a persistant array initialization. The array will not be disposed after leaving the current scope
            and can therefore be utilized for <see href="http://ilnumerics.net/ClassRules.html">initializing class attributes</see>. After initialization, use the 'ILLogical.a = ...' property (C#) 
            or the ILLogical.Assign() function to assign new values to the array.<para>[ILNumerics Core Module]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.localCell">
      <summary>
            Create new empty cell array, used for cell class member (attributes) initialization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Empty cell array which can afterwards be used for arbitrary assignements (Assign(), or 'array.A = ..' assignements)</returns>
      <remarks>The cell array returned will be an empty cell array initially. Its main purpose is to provide 
            a persistant array initialization. The array will not be disposed after leaving the current scope
            and can therefore be utilized for <see href="http://ilnumerics.net/ClassRules.html">initializing class attributes</see>. After initialization, use the 'ILCell.a = ...' property (C#) 
            or the ILCell.Assign() function to assign new values to the array.<para>[ILNumerics Core Module]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="F:ILNumerics.ILMathInternal.pi">
      <summary>
            Definition of pi
            </summary>
      <remarks>This is an convenience alias for Math.PI</remarks>
    </member>
    <member name="F:ILNumerics.ILMathInternal.pif">
      <summary>
            Definition of pi, single precision
            </summary>
      <remarks>This is an convenience alias for Math.PI</remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.macharF(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Single@,System.Single@,System.Single@,System.Single@)">
      <summary>
            Determine machine specific parameter
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>Source: Numerical Recipes in C, p.892<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.macharD(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@)">
      <summary>
            Determine machine specific parameter (double precision)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>Source: Numerical Recipes in C, p.892<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eq(ILNumerics.ILInArray{System.String},ILNumerics.ILInArray{System.String})">
      <summary>
            Elementwise logical 'equal' operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array 1</param>
      <param name="B">Input array 2</param>
      <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
      <remarks>
        <para>On empty input - empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.exp(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Exponential of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Exponential of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.exp(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Exponential of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Exponential of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.exp(ILNumerics.ILInArray{System.Single})">
      <summary>
Exponential of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Exponential of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.exp(ILNumerics.ILInArray{System.Double})">
      <summary>
Exponential of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Exponential of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eye(System.Int32,System.Int32)">
      <summary>
            Create double matrix having unity diagonal values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="columns">Number of columns</param>
      <returns>Unity matrix (diagonal matrix) of type double</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.eye``1(System.Int32,System.Int32)">
      <summary>
            Create unity matrix, arbitrary numeric type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="rows">Number of rows</param>
      <param name="columns">Number of columns</param>
      <returns>Unity matrix (diagonal matrix) of element type T</returns>
      <typeparam name="T">Element type</typeparam>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the type specified is not supported. Supported types are: double, float, complex, fcomplex, int, long, short, byte</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft(ILNumerics.ILInArray{System.Double})">
      <summary>
            Fast fourier transform (1D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first 
            non singleton dimension.</para>
        <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Fast fourier transform (1D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Fast inverse fourier transform (1D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input (frequency domain)</param>
      <returns>Inverse transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftsym(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform, complex hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array</param>
      <returns>Real output array, same size as A</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Fast fourier transform along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Real input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Fast fourier transform along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Inverse fast fourier transform along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftsym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Inverse fast fourier transform, complex hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Real output array, same size as A</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft2(ILNumerics.ILInArray{System.Double})">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The output array returned will be complex hermitian.</para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft2(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft2(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft2sym(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (2D, hermitian input)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft2(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft2(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft2(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft2sym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fftn(ILNumerics.ILInArray{System.Double})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fftn(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftn(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftnsym(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fftn(ILNumerics.ILInArray{System.Double},System.Int32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fftn(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Tnput array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftn(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Inverse fast fourier transform (n-D, specific size)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftnsym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft(ILNumerics.ILInArray{System.Single})">
      <summary>
            Fast fourier transform (1D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first 
            non singleton dimension.</para>
        <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Fast fourier transform (1D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Fast inverse fourier transform (1D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input (frequency domain)</param>
      <returns>Inverse transformed output array</returns>
      <remarks>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftsym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform, complex hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array</param>
      <returns>Real output array, same size as A</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The transformation is computed along the first non 
            singleton dimension.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Fast fourier transform along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Real input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Fast fourier transform along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Inverse fast fourier transform along specific dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftsym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Inverse fast fourier transform, complex hermitian input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
      <returns>Real output array, same size as A</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft2(ILNumerics.ILInArray{System.Single})">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The output array returned will be complex hermitian.</para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft2(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft2(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft2sym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (2D, hermitian input)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft2(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fft2(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft2(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifft2sym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fftn(ILNumerics.ILInArray{System.Single})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fftn(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftn(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftnsym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fftn(ILNumerics.ILInArray{System.Single},System.Int32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fftn(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Tnput array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftn(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Inverse fast fourier transform (n-D, specific size)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ifftnsym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex hermitian input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInArray{System.Double},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInArray{System.Int64},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int64})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInArray{System.UInt32},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.UInt32})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInArray{System.Int32},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInArray{System.Single},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInArray{System.Byte},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Byte})">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.find(ILNumerics.ILInLogical,System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutLogical)">
      <summary>
            Find nonzero elements in A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="limit">Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
      <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
      <param name="V">If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
      <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
      <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fix(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Round towards zero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded towards zero</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fix(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Round towards zero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded towards zero</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fix(ILNumerics.ILInArray{System.Single})">
      <summary>
Round towards zero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded towards zero</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fix(ILNumerics.ILInArray{System.Double})">
      <summary>
Round towards zero
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded towards zero</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fliplr``1(ILNumerics.ILInArray{``0})">
      <summary>
            Reverse order of columns of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Inner element type</typeparam>
      <param name="A">Input matrix</param>
      <returns>Matrix of same size as A, having the order of its columns reversed</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.fliplr(ILNumerics.ILInArray{System.Double})">
      <summary>
            Reverse order of columns of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <returns>Matrix of same size as A, having the order of its columns reversed</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.flipud``1(ILNumerics.ILInArray{``0})">
      <summary>
            Reverse order of rows of a matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Inner element type</typeparam>
      <param name="A">Input matrix</param>
      <returns>Matrix of same size as A, having the order of its rows reversed</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.flipud(ILNumerics.ILInArray{System.Double})">
      <summary>
            Reverse order of rows of a matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <returns>Matrix of same size as A, having the order of its rows reversed</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.floor(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Round towards negative infinity
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded downwards to next integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.floor(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Round towards negative infinity
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded downwards to next integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.floor(ILNumerics.ILInArray{System.Single})">
      <summary>
Round towards negative infinity
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded downwards to next integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.floor(ILNumerics.ILInArray{System.Double})">
      <summary>
Round towards negative infinity
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded downwards to next integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.free``1(``0[])">
      <summary>
            Return a System.Array to the memory pool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">the element type</typeparam>
      <param name="obj4Dispose">the System.Array to be returned to the pool.</param>
      <remarks>Thes function allows the manual regristration of System.Arrays to the ILNumerics memory pool. See <see cref="M:ILNumerics.ILMath.New{T}(int)" /> for a usage example.<para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="M:ILNumerics.ILMath.New{T}(int)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.ge(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ge(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ge(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ge(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ge(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ge(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ge(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ge(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'greater or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gt(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gt(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gt(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gt(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gt(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gt(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gt(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gt(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'greater than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.horzcat(ILNumerics.ILInArray{System.Double}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.horzcat(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.horzcat(ILNumerics.ILInArray{ILNumerics.complex}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.horzcat(ILNumerics.ILInArray{System.Byte}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.horzcat(ILNumerics.ILInArray{System.Int64}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.horzcat(ILNumerics.ILInArray{System.Int32}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.horzcat(ILNumerics.ILInArray{System.Single}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.horzcat``1(ILNumerics.ILInArray{``0}[])">
      <summary>
            Horizontal array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
      <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.imag(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Imaginary part of complex array elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Complex input array</param>
      <returns>Imaginary part of complex array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.imag(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Imaginary part of complex array elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Complex input array</param>
      <returns>Imaginary part of complex array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ind2sub(ILNumerics.ILBaseArray,System.Int32)">
      <summary>
            Convert a single sequential index into a single set of subscript indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="seqindex">Sequential index</param>
      <returns>Subscript indices</returns>
      <remarks>
        <para>The index array returned will have the length of number of dimensions of A.</para>
        <para>If A is a null or an empty array, the return value will be also be empty</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:System.IndexOutOfRangeException">If seqindex is &lt; 0 or &gt;= numel(A)</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.invert(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.invert(ILNumerics.ILInArray{System.SByte},ILNumerics.ILOutArray{System.SByte})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.invert(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Byte})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.invert(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.invert(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.invert(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.invert(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.invert(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Invert elements of A, return result into predefined output array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="outArray">Predefined array for results</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isempty(ILNumerics.ILBaseArray)">
      <summary>
            Test if array is empty
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>True if at least one dimension of A has length 0, false otherwise</returns>
      <remarks>
        <para>This function is an alias for A.IsEmpty. Consider using the matrix property directly for improved performance.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="P:ILNumerics.ILBaseArray.IsEmpty" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.isequal(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Compares two arrays, return System.bool as result
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements and sizes of both arrays match; false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isequalwithequalnans(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isequalwithequalnans(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isequalwithequalnans(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isequalwithequalnans(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isequalwithequalnans(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Compare two arrays, assume NaN and +/- infinity values are comparable and equal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>True if all non-NaN elements in A and B equal, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isfinite(System.Double)">
      <summary>
            Find out, if value is finite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>True for finite values</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isfinite(ILNumerics.complex)">
      <summary>
            Find out, if value is finite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>True for finite values</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isfinite(System.Single)">
      <summary>
            Find out, if value is finite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>True for finite values</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isfinite(ILNumerics.fcomplex)">
      <summary>
            Find out, if value is finite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>True for finite values</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isfinite(ILNumerics.ILInArray{System.Double})">
      <summary>
Finds finite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isfinite(ILNumerics.ILInArray{System.Single})">
      <summary>
Finds finite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isfinite(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Finds finite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isfinite(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Finds finite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isinf(ILNumerics.ILInArray{System.Double})">
      <summary>
Locate infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isinf(ILNumerics.ILInArray{System.Single})">
      <summary>
Locate infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isinf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Locate infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isinf(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Locate infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isnan(ILNumerics.ILInArray{System.Double})">
      <summary>
Finds invalid value elements (not-a-number)
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isnan(ILNumerics.ILInArray{System.Single})">
      <summary>
Finds invalid value elements (not-a-number)
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isnan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Finds invalid value elements (not-a-number)
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isnan(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Finds invalid value elements (not-a-number)
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isneginf(ILNumerics.ILInArray{System.Double})">
      <summary>
Finds negative infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isneginf(ILNumerics.ILInArray{System.Single})">
      <summary>
Finds negative infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isneginf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Finds negative infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isneginf(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Finds negative infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isnull(ILNumerics.ILBaseArray)">
      <summary>
            Determine, if the array A is null (NULL, not assigned)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>True, if the array is null, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isnullorempty(ILNumerics.ILBaseArray)">
      <summary>
            Determine, if the array A is null (NULL or not assigned) or empty
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>True, if the array is null or empty, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isposinf(ILNumerics.ILInArray{System.Double})">
      <summary>
Finds positive infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isposinf(ILNumerics.ILInArray{System.Single})">
      <summary>
Finds positive infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isposinf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Finds positive infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.isposinf(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Finds positive infinite value elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.le(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.le(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.le(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.le(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.le(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.le(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.le(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.le(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'lower or equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being lower or equal to corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolve(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item><item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item><item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="!:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolve(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.MatrixProperties@)">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
      <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the <paramref name="props" /> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. 
            </item><item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item><item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy'.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B by means of rounding errors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), the precision given by <see cref="!:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolveTriUp(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
      <param name="B">Solution vector or matrix. Size [n x m]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via backward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A below the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolveTriLow(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
      <param name="B">Solution vector. Size [n x 1]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via forward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A above the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolve(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item><item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item><item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="!:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolve(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.MatrixProperties@)">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
      <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the <paramref name="props" /> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. 
            </item><item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item><item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy'.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B by means of rounding errors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), the precision given by <see cref="!:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolveTriUp(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
      <param name="B">Solution vector or matrix. Size [n x m]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via backward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A below the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolveTriLow(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
      <param name="B">Solution vector. Size [n x 1]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via forward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A above the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolve(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item><item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item><item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="!:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolve(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@)">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
      <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the <paramref name="props" /> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. 
            </item><item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item><item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy'.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B by means of rounding errors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), the precision given by <see cref="!:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolveTriUp(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
      <param name="B">Solution vector or matrix. Size [n x m]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via backward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A below the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolveTriLow(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
      <param name="B">Solution vector. Size [n x 1]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via forward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A above the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolve(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item><item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item><item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="!:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolve(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.MatrixProperties@)">
      <summary>
            Solve linear equation system
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix A. Size [n x q]</param>
      <param name="B">Right hand side B. Size [n x m]</param>
      <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
      <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
      <remarks>
        <para>Depending on the <paramref name="props" /> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet"><item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. 
            </item><item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para><para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item><item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item><item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy'.</item></list></para>
        <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B by means of rounding errors. </para>
        <para>For specifiying the rank of A in the unsquare case (q != n), the precision given by <see cref="!:ILNumerics.ILMath.eps" /> is used.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolveTriUp(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
      <param name="B">Solution vector or matrix. Size [n x m]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via backward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A below the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linsolveTriLow(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
      <param name="B">Solution vector. Size [n x 1]</param>
      <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
      <returns>Solution x solving A * x = b.</returns>
      <remarks>
        <para>The solution will be determined via forward substitution</para>
        <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
        <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
        <para>Elements of A above the main diagonal will not be accessed.</para>
        <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linspace(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Create linearly spaced row vector of 100 elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">First value</param>
      <param name="end">Last value</param>
      <returns>Row vector with 100 elements linearly spaced between start and end</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linspace``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Create linearly spaced row vector, generic output type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">First value, scalar, numeric</param>
      <param name="end">Last value, scalar, numeric</param>
      <param name="length">Number of elements to create, scalar, numeric</param>
      <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.linspace(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Create linearly spaced row vector, double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">First value</param>
      <param name="end">Last value</param>
      <param name="length">Number of elements to create</param>
      <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.loadArray``1(System.String,System.String)">
      <summary>
            Load single array from matfile file
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type of the array to return</typeparam>
      <param name="filename">Path to the matfile</param>
      <param name="arrayname">[Optional] name of the requested array in the matfile (default: empty -&gt; take the first array found)</param>
      <returns>The array requested</returns>
      <remarks>
        <para>If <paramref name="arrayname" /> is ommited, the first array is returned.</para>
        <para>This function is based on <see cref="T:ILNumerics.ILMatFile" /> which works with Matlab mat files version 6 only. 
            In order to access Matlab mat files of a newer version, use the <see cref="!:ILNumerics.IO.HDF5.H5File" /> API.</para>
        <para>The typeparameter <typeparamref name="T" /> must match the type of elements stored in the mat file.</para>
        <seealso cref="T:ILNumerics.ILMatFile" />
        <seealso cref="!:ILNumerics.IO.HDF5.H5File" />
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.loadImage(System.String,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image file
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="filename">Image filename</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned. All channels are accumulated in the single element. Each channel 
            is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make sure, the image is provided in a compatible format.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.loadImage(System.IO.Stream,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image stream
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="inputStream">Image data as stream</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned. All channels are accumulated in the single element. Each channel 
            is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make sure, the image is provided in a compatible format.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.loadImage(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="image">Image</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned. All channels are accumulated in the single element. Each channel 
            is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make sure, the image is provided in a compatible format.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.loadChannels(System.String,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="filename">Path to image file to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.loadChannels(System.IO.Stream,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="inputStream">Image stream with image data to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.loadChannels(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="image">Image to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.loadBinary``1(System.IO.Stream,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Action{System.Array,System.Int32,System.Array,System.Int32,System.Int32})">
      <summary>
            Load binary data from stream
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type for returned array</typeparam>
      <param name="stream">Input stream to read from</param>
      <param name="leadDimLen">length of the 'leading dimension', how many elements of T fit into one scanline?</param>
      <param name="height">height of the area to read</param>
      <param name="width">widht of the area to read</param>
      <param name="offsetWidth">[Optional] Skip that many columns. Default: 0</param>
      <param name="offsetHeight">[Optional] Skip that many rows. Default: 0</param>
      <param name="convertScanLine">[optional] Function used for copying individual scanlines. Default: null (Buffer.BlockCopy)</param>
      <returns>Array with element type <typeparamref name="T" /> and size as specified with a binary copy of the region read from <paramref name="stream" />.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.logc(ILNumerics.ILInArray{System.Single})">
      <summary>
Logarithm of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.logc(ILNumerics.ILInArray{System.Double})">
      <summary>
Logarithm of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Logarithm of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Logarithm of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log(ILNumerics.ILInArray{System.Single})">
      <summary>
Logarithm of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logarithm of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log(ILNumerics.ILInArray{System.Double})">
      <summary>
Logarithm of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logarithm of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log10c(ILNumerics.ILInArray{System.Single})">
      <summary>
Logarithm of base 10 of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of base 10 of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log10c(ILNumerics.ILInArray{System.Double})">
      <summary>
Logarithm of base 10 of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of base 10 of array elements - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log10(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Logarithm of base 10 of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of base 10 of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log10(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Logarithm of base 10 of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Complex logarithm of base 10 of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log10(ILNumerics.ILInArray{System.Single})">
      <summary>
Logarithm of base 10 of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logarithm of base 10 of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.log10(ILNumerics.ILInArray{System.Double})">
      <summary>
Logarithm of base 10 of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Logarithm of base 10 of array elements - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.logical(System.Byte[],System.Int32[])">
      <summary>
            Create logical array explicitely
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">system array of 0/1 valued byte elements</param>
      <param name="size">the size of the new logical array</param>
      <returns>a new logical with the elements from data and the given size</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.logspace(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create logarithmically spaced row vector of 30 elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">First exponent value</param>
      <param name="end">Last exponent value</param>
      <returns>Row vector with 30 elements logathmically spaced between 10^start and 10^end</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.logspace(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create logarithmically spaced row vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">First exponent value</param>
      <param name="end">Last exponent value</param>
      <param name="length">Number of elements to create</param>
      <returns>Row vector with 'length' elements logarithmically spaced between 10^start and 10^end</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lshift(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Shifts the elements of A bitwise to the left by value of B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the left by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lshift(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Shifts the elements of A bitwise to the left by value of B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the left by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lshift(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Shifts the elements of A bitwise to the left by value of B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the left by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lt(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lt(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lt(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lt(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lt(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lt(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lt(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lt(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'smaller than' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{System.Double})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
             or <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /> instead.</para>
        <para>The matrix L will be a solid ILArray.</para>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix to be decomposed. Size [m x n]</param>
      <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para><example><code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example><para>In order to access the permutation of L, one can use the overloaded version <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /> which returns the permuation matrix P also.</para><para>All of the matrices U and L returned will be solid ILArrays.</para><para>lu uses the Lapack function ?getrf.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
      <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para><example><code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code></example><para>lu uses the Lapack function ?getrf.</para><para>All of the matrices U,L,P returned will be solid ILArrays.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{System.Single})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
             or <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /> instead.</para>
        <para>The matrix L will be a solid ILArray.</para>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix to be decomposed. Size [m x n]</param>
      <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para><example><code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example><para>In order to access the permutation of L, one can use the overloaded version <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /> which returns the permuation matrix P also.</para><para>All of the matrices U and L returned will be solid ILArrays.</para><para>lu uses the Lapack function ?getrf.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
      <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para><example><code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code></example><para>lu uses the Lapack function ?getrf.</para><para>All of the matrices U,L,P returned will be solid ILArrays.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
             or <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /> instead.</para>
        <para>The matrix L will be a solid ILArray.</para>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix to be decomposed. Size [m x n]</param>
      <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para><example><code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example><para>In order to access the permutation of L, one can use the overloaded version <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /> which returns the permuation matrix P also.</para><para>All of the matrices U and L returned will be solid ILArrays.</para><para>lu uses the Lapack function ?getrf.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
      <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para><example><code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code></example><para>lu uses the Lapack function ?getrf.</para><para>All of the matrices U,L,P returned will be solid ILArrays.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
             or <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /> instead.</para>
        <para>The matrix L will be a solid ILArray.</para>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix to be decomposed. Size [m x n]</param>
      <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para><example><code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example><para>In order to access the permutation of L, one can use the overloaded version <see cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /> which returns the permuation matrix P also.</para><para>All of the matrices U and L returned will be solid ILArrays.</para><para>lu uses the Lapack function ?getrf.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.lu(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n]</param>
      <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
      <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
      <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
      <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para><example><code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code></example><para>lu uses the Lapack function ?getrf.</para><para>All of the matrices U,L,P returned will be solid ILArrays.</para><para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;)" />
      <seealso cref="!:ILNumerics.ILMath.lu(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;)" />
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.copyUpperTriangle``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32)">
      <summary>
            Copy upper triangle from PHYSICAL array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Arbitrary inner type </typeparam>
      <param name="A">PHYSICAL ILArray</param>
      <param name="m">Number of rows</param>
      <param name="n">Number of columns</param>
      <returns>Newly created physical array with the upper triangle of A</returns>
      <remarks>No checks are made for m,n fit inside A!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.copyUpperTriangle``1(``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Copy upper triangle from system array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Arbitrary inner type </typeparam>
      <param name="arrIn">System array, size (m x n), column wise ordered</param>
      <param name="arrInM">Number of rows</param>
      <param name="arrInN">Number of columns</param>
      <param name="outM">Number of rows in output matrix</param>
      <returns>Newly created physical array with the upper triangle of A</returns>
      <remarks>No checks are made for m,n fit inside A! copies the main diagonal also.
            the array returned will be of size (min(m,n) x n)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.copyLowerTriangle``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32,``0)">
      <summary>
            Copy lower triangle from PHYSICAL array A, set diagonal to val
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Arbitrary inner type </typeparam>
      <param name="A">PHYSICAL ILArray</param>
      <param name="m">Number of rows</param>
      <param name="n">Number of columns</param>
      <param name="val">Value for diagonal entries</param>
      <returns>Newly created physical array with the lower triangle of A</returns>
      <remarks>No checks are made for m,n fit inside A!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.copyLowerTrianglePerm``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32,``0,System.Int32[])">
      <summary>
            Copy lower triangle from PHYSICAL array A, set diagonal to val, permuted version
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Arbitrary inner type </typeparam>
      <param name="A">PHYSICAL ILArray</param>
      <param name="m">Number of rows</param>
      <param name="n">Number of columns</param>
      <param name="perm">Mapping for rows, must be converted fom LAPACK version to single indices </param>
      <param name="val">Value for diagonal entries</param>
      <returns>Newly created physical array with the lower triangle of A</returns>
      <remarks>No checks are made for m,n fit inside A!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.perm2indicesForward(System.Int32[])">
      <summary>
            Relabel permutation indices from LAPACK ?getrf
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="perm">Lapack pivoting permutation array</param>
      <returns>Index mapping for direct addressing the rows </returns>
      <remarks>Exchange the row labels in the same manner as LAPACK did for pivoting<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.perm2indicesBackward(System.Int32[])">
      <summary>
            Relabel permutation indices from LAPACK ?getrf - backward version
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="perm">Lapack pivoting permutation array</param>
      <returns>Index mapping for direct addressing the rows </returns>
      <remarks>Exchange the row labels in the same manner as LAPACK did for pivoting, but backwards<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.MMultBlockedThreaded(System.Double[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Experimental! Do not use! This function is not working in a mutithreaded context!!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A"></param>
      <param name="B"></param>
      <param name="C"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="k"></param>
      <param name="kc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.MMultBlockedThreaded(System.Single[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Experimental! Do not use! This function is not working in a mutithreaded context!!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A"></param>
      <param name="B"></param>
      <param name="C"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="k"></param>
      <param name="kc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.MMultBlockedThreaded(ILNumerics.fcomplex[],ILNumerics.fcomplex[],ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Experimental! Do not use! This function is not working in a mutithreaded context!!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A"></param>
      <param name="B"></param>
      <param name="C"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="k"></param>
      <param name="kc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.MMultBlockedThreaded(ILNumerics.complex[],ILNumerics.complex[],ILNumerics.complex[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Experimental! Do not use! This function is not working in a mutithreaded context!!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A"></param>
      <param name="B"></param>
      <param name="C"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="k"></param>
      <param name="kc"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.MMultBlockedThreadedSIMD(System.Double[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
            *!HC:inArr*/double* pYA, pXA, pZA;
        </member>
    <member name="M:ILNumerics.ILMathInternal.istrilow(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istriup(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishesslow(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishessup(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishermitian(ILNumerics.ILInArray{System.Double})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istrilow(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istriup(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishesslow(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishessup(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishermitian(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istrilow(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istriup(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishesslow(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishessup(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishermitian(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istrilow(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istriup(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishesslow(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishessup(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishermitian(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istrilow(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istriup(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishesslow(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishessup(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishermitian(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istrilow(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istriup(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishesslow(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishessup(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishermitian(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istrilow(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is a lower triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix of numeric inner type</param>
      <returns>true if A is a lower triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.istriup(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is upper triangular matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper triangular matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishesslow(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is lower Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishessup(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is upper Hessenberg matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ishermitian(ILNumerics.ILInArray{System.Single})">
      <summary>
            Determine if matrix A is Hermitian matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Matrix or scalar A of numeric inner type</param>
      <returns>true if A is a Hermitian matrix, false otherwise</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
            Maximum values along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.max(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Maximum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the maximum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.maxall(ILNumerics.ILInArray{System.Double})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.max" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.maxall(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.max" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.maxall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.max" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.maxall(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.max" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.maxall(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.max" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.maxall(ILNumerics.ILInArray{System.Single})">
      <summary>
            Maximum for all elements of A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar maximum of all elements for A</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.max" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mean(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mean(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mean(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mean(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mean(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mean(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mean(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Mean of array along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input Array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Mean of elements along specified or first non singleton dimension</returns>
      <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.meshgrid(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
      <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
      <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.meshgrid(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="Z">Vector of z values</param>
      <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
      <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
      <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
      <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.meshgrid(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
      <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
      <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.meshgrid(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="Z">Vector of z values</param>
      <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
      <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
      <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
      <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.meshgrid(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
      <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
      <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.meshgrid(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="Z">Vector of z values</param>
      <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
      <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
      <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
      <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.meshgrid(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
      <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
      <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.meshgrid(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Vector of x values</param>
      <param name="Y">Vector of y values</param>
      <param name="Z">Vector of z values</param>
      <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
      <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
      <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
      <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
      <summary>
Minimum value along specified dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Minimum of A and B elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with the minimum elements of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
        <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.minall(ILNumerics.ILInArray{System.Double})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.minall(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.minall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.minall(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.minall(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.minall(ILNumerics.ILInArray{System.Single})">
      <summary>
            Minimum of all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar minimum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mod(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Modulus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mod(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Modulus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mod(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Modulus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mod(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Modulus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mod(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Modulus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.mod(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Modulus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of elementwise modulus operation</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiply(ILNumerics.ILInArray{System.Double}[])">
      <summary>
            Multiplicate an arbitrary number of matrices from left to right
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="matrices">Input matrices </param>
      <returns>Result of matrix multiplication for all matrices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiply(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            General matrix multiply this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <param name="B">Input matrix B</param>
      <returns>Matrix with result of matrix multiplication</returns>
      <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiply(ILNumerics.ILInArray{System.Single}[])">
      <summary>
            Multiplicate an arbitrary number of matrices from left to right
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="matrices">Input matrices </param>
      <returns>Result of matrix multiplication for all matrices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiply(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            General matrix multiply this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <param name="B">Input matrix B</param>
      <returns>Matrix with result of matrix multiplication</returns>
      <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiply(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
      <summary>
            Multiplicate an arbitrary number of matrices from left to right
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="matrices">Input matrices </param>
      <returns>Result of matrix multiplication for all matrices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiply(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            General matrix multiply this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <param name="B">Input matrix B</param>
      <returns>Matrix with result of matrix multiplication</returns>
      <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiply(ILNumerics.ILInArray{ILNumerics.complex}[])">
      <summary>
            Multiplicate an arbitrary number of matrices from left to right
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="matrices">Input matrices </param>
      <returns>Result of matrix multiplication for all matrices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiply(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            General matrix multiply this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <param name="B">Input matrix B</param>
      <returns>Matrix with result of matrix multiplication</returns>
      <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiplyElem(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiplyElem(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiplyElem(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiplyElem(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiplyElem(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiplyElem(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiplyElem(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.multiplyElem(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Multiply arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise multiplication of A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'not equal' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.neq(ILNumerics.ILInArray{System.String},ILNumerics.ILInArray{System.String})">
      <summary>
            Elementwise logical 'not equal' operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array having '1' for elements in A not equal elements in B, '0' else</returns>
      <remarks>
        <para>On empty input - empty array will be returned.</para>
        <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
        <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.New``1(System.Int32)">
      <summary>
             Request System.Array <typeparamref name="T" />[] from ILNumerics Memory Pool
             <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">the element type</typeparam>
      <param name="minLength">
        <b>minimal</b> length of the array returned</param>
      <returns>A system array of element type <typeparamref name="T" /> and minimal length <paramref name="minLength" />.</returns>
      <remarks>
        <para>This function fetches a System.Array from the collection of available arrays which are currently held in the ILNumerics Memory Pool. 
             If no matching array is available, a new array will be allocated from the runtime.</para>
        <para>Important note: the array returned is not guaranteed to be cleared! Furthermore, it may contain more elements than requested by <paramref name="minLength" />!</para>
        <para>The array returned is fetched from the collection of available arrays in the pool. If no matching array was found, a new array is requested from the managed heap.</para>
        <para>The user is reponsible to return the array to the pool once finished using it. The <see cref="M:ILNumerics.ILMath.free{T}(T[])" /> method should be used for returning an array.</para>
        <para>Keep in mind, the array returned may be <b>longer</b> as requested! Therefore, in order to reference its elements use the <paramref name="length" /> parameter rather than the System.Array.Length property.</para>
        <example>A system array is needed inside a computational loop. The loop calls a native function repeatedly which requests a working array. The System.Array is requested from the pool and returned to the pool after usage.
             <code><![CDATA[
            [System.Runtime.InteropServices.DllImport("myDLL")]
            private static extern void MyDllFunc(double[] a, int lenA, double[] b, double[] work, int lenWork);
            
            public static ILRetArray<double> MyFunc(ILInArray<double> A) {
                using (ILScope.Enter(A)) {
                    // myDllFunc needs storage for the result
                    ILArray<double> ret = zeros(A.Size);
                    ILArray<double> tmpRow = zeros(1, A.S[1]);
            
                    // myDllFunc needs a working storage:
                    double[] work = New<double>(A.S[1]);
                    // for all rows of A use the same working array
                    for (int i = 0; i < A.S[0]; i++) {
                        using (ILScope.Enter()) {
                            ILArray<double> ARow = A[i, full];
                            MyDllFunc(ARow.GetArrayForRead(), A.Length, tmpRow.GetArrayForWrite(), work, A.Length);
                            ret[i, full] = tmpRow;
                        }
                    }
                    // return the System.Array to the pool 
                    free(work);
                    return ret;
                }
            }
             ]]></code>
             However, in most situations, the handling of system.arrays directly can be circumvented. The same goal as in the 
             example could be archieved as follows: 
             <code><![CDATA[       
             public static ILRetArray<double> MyFunc(ILInArray<double> A) {
            using (ILScope.Enter(A)) {
                // myDllFunc needs storage for the result
                ILArray<double> ret = zeros(A.Size);
                ILArray<double> tmpRow = zeros(1, A.S[1]);
                // myDllFunc needs a working storage. We us a regular ILNumerics array 
                // which we dont have to free afterwards. 
                ILArray<double> work = zeros(tmpRow.S); 
            
                // for all rows of A use the same working array
                for (int i = 0; i < A.S[0]; i++) {
                    using (ILScope.Enter()) {
                        ILArray<double> ARow = A[i, full];
                        MyDllFunc(ARow.GetArrayForRead(), A.Length, tmpRow.GetArrayForWrite(), work.GetArrayForWrite(), A.Length);
                        ret[i, full] = tmpRow;
                    }
                }
                // returning the working storage is not needed here...
            
                return ret;
            }
            }]]></code>
             Both examples archieve a 100% memory efficiency by completely reusing the memory needed within the function. 
             </example>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.norm(ILNumerics.ILInArray{System.Double},System.Double)">
      <summary>
            Vector or matrix norm
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input matrix or vector</param>
      <param name="degree">[optional] degree of norm (default: 2)</param>
      <returns>Array of same type as input array A</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of: 
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item><item>System.double.PositiveInfinity: return Max(abs(A))</item><item>System.double.NegativeInfinity: return Min(abs(A))</item></list>
            For matrices <paramref name="degree" /> must be one out of: 
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.norm(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Double)">
      <summary>
            Vector or matrix norm
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input matrix or vector</param>
      <param name="degree">[optional] degree of norm (default: 2)</param>
      <returns>Array of same type as input array A</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of: 
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item><item>System.double.PositiveInfinity: return Max(abs(A))</item><item>System.double.NegativeInfinity: return Min(abs(A))</item></list>
            For matrices <paramref name="degree" /> must be one out of: 
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.norm(ILNumerics.ILInArray{System.Single},System.Double)">
      <summary>
            Vector or matrix norm
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input matrix or vector</param>
      <param name="degree">[optional] degree of norm (default: 2)</param>
      <returns>Array of same type as input array A</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of: 
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item><item>System.double.PositiveInfinity: return Max(abs(A))</item><item>System.double.NegativeInfinity: return Min(abs(A))</item></list>
            For matrices <paramref name="degree" /> must be one out of: 
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.norm(ILNumerics.ILInArray{ILNumerics.complex},System.Double)">
      <summary>
            Vector or matrix norm
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input matrix or vector</param>
      <param name="degree">[optional] degree of norm (default: 2)</param>
      <returns>Array of same type as input array A</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of: 
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item><item>System.double.PositiveInfinity: return Max(abs(A))</item><item>System.double.NegativeInfinity: return Min(abs(A))</item></list>
            For matrices <paramref name="degree" /> must be one out of: 
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ones(System.Int32[])">
      <summary>
            Create new double array, set initial values to 1
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ones(ILNumerics.NumericType,ILNumerics.ILSize)">
      <summary>
            Create array initialized with all elements set to one
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType" />
            enum.</param>
      <param name="size">Size descriptor</param>
      <returns>Array of inner type corresponding to <paramref name="type" /> argument.</returns>
      <remarks>The array returned must be casted to the appropriate actual type afterwards and assigned to a concrete array! Caution: 
            This overload is provided for compatibility reasons only! Use <see cref="M:ILNumerics.ILMathInternal.ones``1(ILNumerics.ILSize)" /> instead.
            <para><list type="number"><listheader>The following types are supported: </listheader><item>Double</item><item>Single</item><item>Complex</item><item>FComplex</item><item>Byte</item><item>Int32</item><item>Int64</item></list></para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ones``1(System.Int32[])">
      <summary>
            Create array initialized with all elements set to one
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Numeric type specification.</typeparam>
      <param name="size">Size descriptor</param>
      <returns>Array of inner type corresponding to the given type.</returns>
      <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para><list type="number"><listheader>The following types are supported: </listheader><item>Double</item><item>Single</item><item>complex</item><item>fcomplex</item><item>Byte</item><item>Int32</item><item>Int64</item></list></para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ones``1(ILNumerics.ILSize)">
      <summary>
            Create array initialized with all elements set to one
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Numeric type specification.</typeparam>
      <param name="size">Size descriptor</param>
      <returns>Array of inner type corresponding to the given type.</returns>
      <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para><list type="number"><listheader>The following types are supported: </listheader><item>Double</item><item>Single</item><item>complex</item><item>fcomplex</item><item>Byte</item><item>Int32</item><item>Int64</item></list></para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.ones(ILNumerics.ILSize)">
      <summary>
            Create new double array, set initial values to 1
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.or(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.or(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.or(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.or(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.or(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.or(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.or(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.or(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'or' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pinv(ILNumerics.ILInArray{System.Double})">
      <summary>
            Pseudo - inverse of input argument M
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <returns>Pseudo inverse of input matrix M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest number greater than zero</item></list>
            You may use a overloaded function to define an alternative tolerance. 
            <para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.pinv(ILInArray&lt;double&gt;, double)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.pinv(ILNumerics.ILInArray{System.Double},System.Double)">
      <summary>
            Pseudo inverse of input matrix M
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
      <returns>Pseudo inverse of M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest constructable double precision number greater than zero</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pinv(ILNumerics.ILInArray{System.Single})">
      <summary>
            Pseudo - inverse of input argument M
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <returns>Pseudo inverse of input matrix M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest number greater than zero</item></list>
            You may use a overloaded function to define an alternative tolerance. 
            <para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.pinv(ILInArray&lt;double&gt;, double)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.pinv(ILNumerics.ILInArray{System.Single},System.Single)">
      <summary>
            Pseudo inverse of input matrix M
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
      <returns>Pseudo inverse of M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest constructable double precision number greater than zero</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pinv(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Pseudo - inverse of input argument M
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <returns>Pseudo inverse of input matrix M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest number greater than zero</item></list>
            You may use a overloaded function to define an alternative tolerance. 
            <para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.pinv(ILInArray&lt;double&gt;, double)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.pinv(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.fcomplex)">
      <summary>
            Pseudo inverse of input matrix M
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
      <returns>Pseudo inverse of M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest constructable double precision number greater than zero</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pinv(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Pseudo - inverse of input argument M
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <returns>Pseudo inverse of input matrix M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest number greater than zero</item></list>
            You may use a overloaded function to define an alternative tolerance. 
            <para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.pinv(ILInArray&lt;double&gt;, double)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.pinv(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.complex)">
      <summary>
            Pseudo inverse of input matrix M
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="M">Input matrix M</param>
      <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
      <returns>Pseudo inverse of M</returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet"><item>M * pinv(M) * M  = M </item><item>pinv(M) * M * pinv(M) = pinv(M)</item><item>pinv(M) * M is hermitian</item><item>M * pinv(M) is hermitian</item></list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet"><item>length(M) - the longest dimension of M</item><item>norm(M) being the largest singular value of M, </item><item>Double.epsilon - the smallest constructable double precision number greater than zero</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pol2cart(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Transform polar/ cylindrical coordinates into scalar coordinates
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="theta">Angle to x axis</param>
      <param name="radius">Radius from z axis</param>
      <param name="Z">Height</param>
      <param name="outY">If on entry not null, the Y components are returned in outY</param>
      <param name="outZ">If on entry not null, the Z components are returned in outZ</param>
      <returns>X component, Y and Z are returned as out parameter if requested</returns>
      <remarks>Theta, radius and Z must be of the same size or either one may be scalar. 
            Scalar coordinate arrays returned are of the same size then the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pol2cart(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Transform polar/ cylindrical coordinates into scalar coordinates
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="theta">Angle to x axis</param>
      <param name="radius">Radius from z axis</param>
      <param name="Z">Height</param>
      <param name="outY">If on entry not null, the Y components are returned in outY</param>
      <param name="outZ">If on entry not null, the Z components are returned in outZ</param>
      <returns>X component, Y and Z are returned as out parameter if requested</returns>
      <remarks>Theta, radius and Z must be of the same size or either one may be scalar. 
            Scalar coordinate arrays returned are of the same size then the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.poly(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Polynomial evaluation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="c">Vector of coefficients of the polynomial</param>
      <param name="x">Position where the polynomial is to be evaluated. The position may be either a scalar, a vector or a matrix.</param>
      <example>
        <code><![CDATA[
             //Evaluation of the polynomial 1+x+2.1 x + x^2+3x^3 at (1,1,1)
             ILArray<float> y = Optimization.poly(ILMath.array<float>(1.0, 2.1, 1.0, 3.0),ILMath.ones<float>(3, 1));
            ]]></code>
      </example>
      <returns>The value of a polynomial of degree d at position x, with d=c.lenght-1</returns>
      <remarks> If the input position is an array, the evaluation will be done elementwise<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.poly(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Polynomial evaluation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="c">Vector of coefficients of the polynomial</param>
      <param name="x">Position where the polynomial is to be evaluated. The position may be either a scalar, a vector or a matrix.</param>
      <example>
        <code><![CDATA[
             //Evaluation of the polynomial 1+x+2.1 x + x^2+3x^3 at (1,1,1)
             ILArray<double> y = Optimization.poly(ILMath.array<double>(1.0, 2.1, 1.0, 3.0), ILMath.ones<double>(3, 1));
            ]]></code>
      </example>
      <returns>The value of a polynomial of degree d at position x, with d=c.lenght-1</returns>
      <remarks> If the input position is an array, the evaluation will be done elementwise<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pow(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Power elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pow(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Power elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pow(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Power elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pow(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Power elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pow(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Power elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pow(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Power elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pow(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Power elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.pow(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Power elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Array with elementwise result of A <sup>B</sup>.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.prod(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.prod(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.prod(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.prod(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.prod(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.prod(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.prod(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
Product of array elements along specific dimension
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>
        <para>Array of same size as A, having dim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para>
      </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Double})">
      <summary>
            QR decomposition - raw Lapack output
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
      <remarks>
        <para>Input matrix A will not be altered. </para>
        <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> 
            instead, which returns those factors separately.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            QR decomposition, returning Q and R
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
      <summary>
            QR decomposition, returning Q and R, optionally economical sized
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
      <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize" /> (see remarks below)</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            QR decomposition with pivoting
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
      <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.<para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
      <summary>
            QR decomposition with pivoting, possibly economical sized
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize" /> (see remarks).</param>
      <param name="economySize">
        <para>If true, <list type="bullet"><item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item><item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
        <para>If false, this function acts exactly as its overload 
            <see cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /></para>
      </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize" /> is 
            true, a row vector of length n otherwise</para></param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> 
            (see remarks below)</returns>
      <remarks>
        <para> If <paramref name="economySize" /> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
        <para>If <paramref name="economySize" /> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
        <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Single})">
      <summary>
            QR decomposition - raw Lapack output
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
      <remarks>
        <para>Input matrix A will not be altered. </para>
        <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> 
            instead, which returns those factors separately.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            QR decomposition, returning Q and R
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
      <summary>
            QR decomposition, returning Q and R, optionally economical sized
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
      <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize" /> (see remarks below)</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            QR decomposition with pivoting
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
      <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.<para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
      <summary>
            QR decomposition with pivoting, possibly economical sized
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize" /> (see remarks).</param>
      <param name="economySize">
        <para>If true, <list type="bullet"><item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item><item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
        <para>If false, this function acts exactly as its overload 
            <see cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /></para>
      </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize" /> is 
            true, a row vector of length n otherwise</para></param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> 
            (see remarks below)</returns>
      <remarks>
        <para> If <paramref name="economySize" /> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
        <para>If <paramref name="economySize" /> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
        <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            QR decomposition - raw Lapack output
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
      <remarks>
        <para>Input matrix A will not be altered. </para>
        <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> 
            instead, which returns those factors separately.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            QR decomposition, returning Q and R
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            QR decomposition, returning Q and R, optionally economical sized
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
      <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize" /> (see remarks below)</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            QR decomposition with pivoting
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
      <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.<para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            QR decomposition with pivoting, possibly economical sized
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize" /> (see remarks).</param>
      <param name="economySize">
        <para>If true, <list type="bullet"><item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item><item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
        <para>If false, this function acts exactly as its overload 
            <see cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /></para>
      </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize" /> is 
            true, a row vector of length n otherwise</para></param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> 
            (see remarks below)</returns>
      <remarks>
        <para> If <paramref name="economySize" /> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
        <para>If <paramref name="economySize" /> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
        <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            QR decomposition - raw Lapack output
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
      <remarks>
        <para>Input matrix A will not be altered. </para>
        <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;)" /> 
            instead, which returns those factors separately.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            QR decomposition, returning Q and R
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            QR decomposition, returning Q and R, optionally economical sized
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
      <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
      <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize" /> (see remarks below)</returns>
      <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            QR decomposition with pivoting
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
      <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.<para>[ILNumerics Core Module]</para></remarks>
      <seealso cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;,bool)" />
    </member>
    <member name="M:ILNumerics.ILMathInternal.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            QR decomposition with pivoting, possibly economical sized
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A of size [m x n]</param>
      <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize" /> (see remarks).</param>
      <param name="economySize">
        <para>If true, <list type="bullet"><item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item><item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
        <para>If false, this function acts exactly as its overload 
            <see cref="!:ILNumerics.ILMath.qr(ILInArray&lt;double&gt;, ILOutArray&lt;double&gt;, ILOutArray&lt;double&gt;)" /></para>
      </param>
      <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize" /> is 
            true, a row vector of length n otherwise</para></param>
      <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> 
            (see remarks below)</returns>
      <remarks>
        <para> If <paramref name="economySize" /> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
        <para>If <paramref name="economySize" /> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
        <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.r(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Region creator for subarray specifications
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">Begin of region, index of first element</param>
      <param name="end">End of region, last element</param>
      <returns>An array which specifies all indices of the region</returns>
      <remarks>The r function provides a shorter way to specify regions in subarray
            expressions. Other than alternatives like <see cref="M:ILNumerics.ILMath.vec" />, 
            it also enables the use of the <see cref="F:ILNumerics.ILMath.end" /> keyword - even in 
            conjunction with simple mathematical expressions.<para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>ILArray&lt;double&gt; A = counter(5,4,3), B;
            
            // the following subarrays will all create the same B: 
            B = A[full,r(1,end-1),full]; 
            B = A[r(0,end),"1,2",":"];
            B = A[":;1:2;0:end"];
            
            // however, these expression will <b>not</b> work:
            B = A[":;0:end-1,:"]; // 'end' expression evaluation is not supported in strings. 
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMathInternal.r(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Stepped region creator for subarray specifications
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">Begin of region, index of first element</param>
      <param name="end">End of region, last element</param>
      <param name="step">Increment, distance between created indices</param>
      <returns>An array which specifies the indices of the region</returns>
      <remarks>The r function provides a shorter way to specify regions in subarray
            expressions. Other than alternatives like <see cref="!:ILNumerics.ILMath.vec" />, 
            it also enables the use of the <see cref="!:ILNumerics.ILMath.end" /> keyword - even in 
            conjunction with simple mathematical expressions.<para>[ILNumerics Core Module]</para></remarks>
      <example>
        <code>ILArray&lt;double&gt; A = counter(5,4,3), B;
            
            // the following subarrays will all create the same B: 
            B = A[full,r(1,end-1),full]; 
            B = A[r(0,end),"1,2",":"];
            B = A[":;1:2;0:end"];
            
            // however, these expression will <b>not</b> work:
            B = A[":;0:end-1,:"]; // 'end' expression evaluation is not supported in strings. 
            </code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMathInternal.rand(System.Int32[])">
      <summary>
            Pseudo random N-dimensional array elements.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
      <returns>N-dimensional array filled with random numbers.</returns>
      <remarks>
        <para>The elements lie within the range 0.0 ... 1.0 and are uniformly 
            distributed.</para>
        <para>The initial seed will be set to Environment.TickCount on the first call.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.randn(System.Int32[])">
      <summary>
            Normal randomly-distributed N-dimensional array elements.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
      <returns>N-dimensional array filled with random numbers.</returns>
      <remarks>The elements lie within the range 0.0 ... 1.0 and are choosen to be normally 
            distributed.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.rank(ILNumerics.ILInArray{System.Double},System.Double)">
      <summary>
            Rank of matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
      <returns>Rank of matrix A</returns>
      <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet"><item>length(A) - the longest dimension of A</item><item>norm(A) being the largest singular value of A, </item><item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.rank(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Double)">
      <summary>
            Rank of matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
      <returns>Rank of matrix A</returns>
      <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet"><item>length(A) - the longest dimension of A</item><item>norm(A) being the largest singular value of A, </item><item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.rank(ILNumerics.ILInArray{System.Single},System.Double)">
      <summary>
            Rank of matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
      <returns>Rank of matrix A</returns>
      <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet"><item>length(A) - the longest dimension of A</item><item>norm(A) being the largest singular value of A, </item><item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.rank(ILNumerics.ILInArray{ILNumerics.complex},System.Double)">
      <summary>
            Rank of matrix A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
      <returns>Rank of matrix A</returns>
      <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet"><item>length(A) - the longest dimension of A</item><item>norm(A) being the largest singular value of A, </item><item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Real part of complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Complex input array</param>
      <returns>Real part of complex array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Real part of complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Complex input array</param>
      <returns>Real part of complex array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert real array to complex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>Complex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2complex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Create complex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Double})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Single})">
      <summary>
            Convert real array to fcomplex array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>fcomplex array with A as real part, imaginary part is zero</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.real2fcomplex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
            Create fcomplex array out of real and imaginary parts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real array for real part</param>
      <param name="imag">Real array for imaginary part</param>
      <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
      <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.repmat(ILNumerics.ILInArray{System.Double},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.repmat(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.repmat(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.repmat(ILNumerics.ILInArray{System.Byte},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.repmat(ILNumerics.ILInArray{System.Int64},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.repmat(ILNumerics.ILInArray{System.Int32},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.repmat(ILNumerics.ILInArray{System.Single},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.repmat``1(ILNumerics.ILInArray{``0},System.Int32[])">
      <summary>
            Array replication
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">Input array to be replicated</param>
      <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
      <returns>Reference ILArray as replication of X</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Double},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Double},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Byte},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Byte},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Int64},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Int64},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Int32},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Int32},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Single},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape(ILNumerics.ILInArray{System.Single},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape``1(ILNumerics.ILInArray{``0},System.Int32[])">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="newDimensions">New dimensions array. This may be 
            a comma seperated list or an int array</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions" />. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.reshape``1(ILNumerics.ILInArray{``0},ILNumerics.ILSize)">
      <summary>
            Array reshaping
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array A</param>
      <param name="dim">New dimension</param>
      <returns>Reshaped array</returns>
      <remarks>A will not be changed. A new reference array is created, having 
            the size and number of dimensions specified by dim. <para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim" /> 
            do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.round(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Round to nearest integer
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded to nearest integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.round(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Round to nearest integer
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded to nearest integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.round(ILNumerics.ILInArray{System.Single})">
      <summary>
Round to nearest integer
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded to nearest integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.round(ILNumerics.ILInArray{System.Double})">
      <summary>
Round to nearest integer
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array of same size as A with elements rounded to nearest integer</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.rshift(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Shifts the elements of A bitwise to the right by value of B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the right by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.rshift(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Shifts the elements of A bitwise to the right by value of B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the right by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.rshift(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Shifts the elements of A bitwise to the right by value of B.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array having the bits of elements of A shifted to the right by B.</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sign(ILNumerics.ILInArray{System.Double})">
      <summary>
Signum of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sign(ILNumerics.ILInArray{System.Single})">
      <summary>
Signum of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sign(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Signum of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sign(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Signum of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sign(ILNumerics.ILInArray{System.Int64})">
      <summary>
Signum of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sign(ILNumerics.ILInArray{System.Int32})">
      <summary>
Signum of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sign(ILNumerics.ILInArray{System.Int16})">
      <summary>
Signum of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sign(ILNumerics.ILInArray{System.Byte})">
      <summary>
Signum of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Array with elements signaling the sign of corresponding elements of A</returns>
      <remarks>
        <para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a solid array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sin(ILNumerics.ILInArray{System.Double})">
      <summary>
Sinus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Sinus of elements from input array</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sin(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Sinus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Sinus of elements from input array</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sin(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Sinus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Sinus of elements from input array</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sin(ILNumerics.ILInArray{System.Single})">
      <summary>
Sinus of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Sinus of elements from input array</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sinh(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Hyperbolic sine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic sine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sinh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic sine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic sine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sinh(ILNumerics.ILInArray{System.Single})">
      <summary>
Hyperbolic sine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic sine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sinh(ILNumerics.ILInArray{System.Double})">
      <summary>
Hyperbolic sine of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic sine of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Double})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Double},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Double},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Int64},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.UInt32},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.UInt32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Int32},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Single})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Single},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Single},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Byte},System.Boolean)">
      <summary>
            Sort data in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Byte},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array, n-dimensional</param>
      <param name="descending">Direction of sorting</param>
      <param name="dim">Dimension index to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>The data in A will be sorted along the dimension <paramref name="dim" /> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para><para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth" /> 
            and <see cref="P:ILNumerics.Settings.MinimumQuicksortLength" />.</para><para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para><example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code></example><para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.String})">
      <summary>
            Sort strings in A along first non singleton dimension ascending
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.String},System.Boolean)">
      <summary>
            Sort strings in A along first non singleton dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.String},System.Int32,System.Boolean)">
      <summary>
            Sort strings in A along dimension 'dim'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <param name="dim">Dimension to sort along</param>
      <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort(ILNumerics.ILInArray{System.String},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
      <summary>
             Sort data in A along dimension 'dim'
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array: empty, scalar, vector or matrix</param>
      <param name="descending">Specifies the direction of sorting</param>
      <param name="dim">Dimension to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix also</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>
        <para>The data in A will be sorted using the quick sort algorithm. Data 
             along the dimension <paramref name="dim" /> will get sorted independently from data 
             in the next row/column.</para>
        <para>This overload also returns an array 'Indices' which will hold the indices into the original 
             elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sort``3(ILNumerics.ILInArray{``0},ILNumerics.ILOutArray{``2},System.Int32,System.Boolean,ILNumerics.Algorithms.ILKeyMapper{``0,``1})">
      <summary>
            Generic bucket sort algorithm in A along arbitrary dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array: empty, scalar, vector or matrix</param>
      <param name="descending">Specifies the direction of sorting</param>
      <param name="dim">Dimension to sort along</param>
      <param name="Indices">[Input/Output] The values in Indices will be returned in the same sorted order as the elements 
            in A. This can be used to derive a permutation matrix of the sorted indices.</param>
      <typeparam name="T">Element type of values of A</typeparam>
      <typeparam name="S">Subelement type. For element type of string this would be 'char'</typeparam>
      <typeparam name="I">Element type of indices</typeparam>
      <param name="keymapper">Instancce of an object of type ILKeyMapper. This object must 
            be derived from ILKeyMapper{T,SubelementType} and match the generic argument <typeparamref name="T" />. It will be 
            used to split single elements into its subelements and map their content into bucket numbers. For all 
            reference types except those of type string you will have to write your own ILKeyMapper class for that purpose.</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>
        <para>The data in A will be sorted using the bucket sort algorithm. Data 
            along the dimension <paramref name="dim" /> will get sorted independently. I.e., for dim = 0, columns are sorted independently.</para>
        <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Therefore, the unsorted indices must be provided by the user on entry. Indices must not be null.</para>
        <para>This generic version is able to sort arbitrary element types. Even user defined reference types can be sorted 
            by specifying a user defined ILKeyMapper class instance. Also the type of Indices may be arbitrarily choosen. In difference 
            to the regular sort function overload, Indices must manually be given to the function on entry. Elements in 'Indices'
            are sorted in the same order as the elements of A.</para>
        <para>By using this overload you may use the same permutation matrix several times to reflect the 
            manipulations done to A due multiple sort processes. The Indices given will directly be used for the sorting 
            disregarding initial order.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sqrtc(ILNumerics.ILInArray{System.Single})">
      <summary>
Square root of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array - positive and negative values allowed</param>
      <returns>Square root of elements of A - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sqrtc(ILNumerics.ILInArray{System.Double})">
      <summary>
Square root of array elements - complex output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array - positive and negative values allowed</param>
      <returns>Square root of elements of A - complex output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sqrt(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Square root of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Square root of elements of A </returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sqrt(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Square root of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Square root of elements of A </returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sqrt(ILNumerics.ILInArray{System.Single})">
      <summary>
Square root of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array - only positive values are allowed.</param>
      <returns>Square root of elements of A - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sqrt(ILNumerics.ILInArray{System.Double})">
      <summary>
Square root of array elements - real output
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array - only positive values are allowed.</param>
      <returns>Square root of elements of A - real output</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sub2ind(ILNumerics.ILBaseArray,System.Int32[])">
      <summary>
            Convert subscript indices to sequential index
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="subscripts">Subscripts</param>
      <returns>Sequential index for subscript indices</returns>
      <remarks>The function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.subtract(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.subtract(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.subtract(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.subtract(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.subtract(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.subtract(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.subtract(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.subtract(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Subtract arrays elementwise
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>New array with result of subtraction</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array in this case.</para>
        <para>Vector expansion: if A or B is a colum vector and the other parameter is a matrix with a matching colum length, the vector is used to operate on all columns of the matrix. Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature is sometimes reffered to as 'broadcasting' (numpy) and removes the need for the (costly) repmat function. It works on most binary operators in ILNumerics.</para>
        <para>For all other cases the dimensions of A and B must match.</para>
        <para>For A and B of <i>integer</i> element types the operation is carried out under the utilization of the floating point computing unit in double precision. The result will be clamped to the limits (MinValue ... MaxValue) of the corresponding element data type. So, if for two corresponding elements in A and B the operation results in, let's say: -2 and the element type is 'byte' the resulting element will get the value '0' assigned. (This is sometimes referred to as 'saturation'.)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the sizes of A or B do not match any parameter rule.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sumall(ILNumerics.ILInArray{System.Double})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sumall(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sumall(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sumall(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sumall(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sumall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sumall(ILNumerics.ILInArray{System.Single})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sumall(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Sum all elements of array A
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <returns>
        <para>Scalar sum of all elements of A.</para>
        <para>If A is empty, an empty array will be returned.</para>
      </returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
      <seealso cref="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Int64},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.UInt32},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Int32},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Byte},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.sum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            Sum elements of A along specified dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
      <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Double})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Vector with min(M,N) singular values of A as column vector</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Single})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Vector with min(M,N) singular values of A as column vector</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Vector with min(M,N) singular values of A as column vector</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix A</param>
      <returns>Vector with min(M,N) singular values of A as column vector</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
      <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
      <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
      <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
      <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
      <returns>Singluar values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean,System.Boolean)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
      <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
      <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
      <returns>Singular values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean,System.Boolean)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
      <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
      <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
      <returns>Singular values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean,System.Boolean)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
      <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
      <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
      <returns>Singular values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean,System.Boolean)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix</param>
      <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
      <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
      <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
      <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
      <returns>Singular values as diagonal matrix of same size and type as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tan(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Tangens of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Tangens of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Tangens of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Tangens of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tan(ILNumerics.ILInArray{System.Single})">
      <summary>
Tangens of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Tangens of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tan(ILNumerics.ILInArray{System.Double})">
      <summary>
Tangens of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Tangens of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tanh(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Hyperbolic tangent of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic tangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tanh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic tangent of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic tangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tanh(ILNumerics.ILInArray{System.Single})">
      <summary>
Hyperbolic tangent of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic tangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tanh(ILNumerics.ILInArray{System.Double})">
      <summary>
Hyperbolic tangent of array elements
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array</param>
      <returns>Hyperbolic tangent of array elements</returns>
      <remarks>
        <para>If the input array is empty, an empty array will be returned.</para>
        <para>The array returned will be a dense array.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.trace(ILNumerics.ILInArray{System.Double})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.trace(ILNumerics.ILInArray{System.Int64})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.trace(ILNumerics.ILInArray{System.UInt32})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.trace(ILNumerics.ILInArray{System.Int32})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.trace(ILNumerics.ILInArray{System.Single})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.trace(ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.trace(ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.trace(ILNumerics.ILInArray{System.Byte})">
      <summary>
            Trace of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.triu``1(ILNumerics.ILInArray{``0})">
      <summary>
            Extrac upper triangular part of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Inner type of matrix</typeparam>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Array of size [m x n], holding upper triangular part of A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions.</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.tril``1(ILNumerics.ILInArray{``0})">
      <summary>
            Lower triangular part of matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Inner type of matrix</typeparam>
      <param name="A">Input matrix, size [m x n]</param>
      <returns>Array of size [m x n], holding lower triangular part of A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions.</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Regulary spaced vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">Start value</param>
      <param name="end">End value</param>
      <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with interval 1. The last element 
            of the returned vector will be less than or equal to end, if start <![CDATA[<]]> end.</returns>
      <remarks>This is the same as vector (start,1,end).<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If start <![CDATA[>]]> end</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vec``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Regularly spaced vector, spacing 1
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">Start value</param>
      <param name="end">End value</param>
      <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with stepsize of 1. The last element 
            of the returned vector will be less than or equal to end, if start &lt; end. </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vec``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
      <summary>
            Regulary spaced column vector
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="start">Start value</param>
      <param name="step">Step size</param>
      <param name="end">End value</param>
      <returns>Column vector of length N, where N is the number of elements 
            between start and end, all equally spaced with stepsize of 'step'. The last element 
            of the returned vector will be less than or equal to end, if start &lt; end. If start 
            &gt; end, the elements in the vector will linearly decrease from 
            start to end. In this case, step must be negative.</returns>
      <remarks>
        <para>The shape of the vector created is controlled by the setting switch <see cref="P:ILNumerics.Settings.CreateRowVectorsByDefault" />.
            This setting defaults to 'false' which will cause the creation of a column vector. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vertcat(ILNumerics.ILInArray{System.Double}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vertcat(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vertcat(ILNumerics.ILInArray{ILNumerics.complex}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vertcat(ILNumerics.ILInArray{System.Byte}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vertcat(ILNumerics.ILInArray{System.Int64}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vertcat(ILNumerics.ILInArray{System.Int32}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vertcat(ILNumerics.ILInArray{System.Single}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.vertcat``1(ILNumerics.ILInArray{``0}[])">
      <summary>
            Vertical array concatenation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
      <returns>Larger array having all arrays in 'arrays' placed beneath each other.
            </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.xor(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.xor(ILNumerics.ILInArray{System.UInt32},ILNumerics.ILInArray{System.UInt32})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.xor(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.xor(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.xor(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.xor(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.xor(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.xor(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Elementwise logical 'xor' operator
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="A">Input array A</param>
      <param name="B">Input array B</param>
      <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
      <remarks>
        <para>On empty input an empty array will be returned.</para>
        <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
        <para>Common vector expansion (broadcasting) rules apply for both A and B: A or B can be a matrix and the other parameter can be a row vector with the length equal to 
            the number of columns in the matrix or a column vector with a length being equal to the number of rows in the matrix. This will lead to the vector being operated on 
            the matrix in an efficient way (i.e. without actually replicating the vector data).</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the sizes of both arrays do not qualify for vector expansion (broadcasting) for matrices and vectors.</exception>
    </member>
    <member name="M:ILNumerics.ILMathInternal.zeros(System.Int32[])">
      <summary>
            Create double array with all elements initialized to 0
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Size description</param>
      <returns>Zeros-filled array.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.zeros(ILNumerics.ILSize)">
      <summary>
            Create double array with all elements initialized to 0
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Size descriptor</param>
      <returns>Zeros-filled array.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.zeros``1(ILNumerics.ILSize)">
      <summary>
            Create array with all elements initialized to default(T)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="size">Size descriptor</param>
      <returns>New array, initialized to default(T)</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.zeros``1(System.Int32[])">
      <summary>
            Create new array of arbitrary element type, initialized to '0'
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="size">Size description</param>
      <returns>New array having the size determined by 'dims', initialized to '0'</returns>
      <remarks>For T deriving from Sytem.ValueType elements will be '0'. All other element types
            will be initialized to default(T).<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.zeros(ILNumerics.NumericType,ILNumerics.ILSize)">
      <summary>
            Create array initialized with all elements set to zero
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType" />
            enum.</param>
      <param name="size">Size descriptor</param>
      <returns>Array of inner type corresponding to <paramref name="type" /> argument.</returns>
      <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para><list type="number"><listheader>The following types are supported: </listheader><item>Double</item><item>Single</item><item>Complex</item><item>FComplex</item><item>Byte</item><item>Int32</item><item>Int64</item></list></para><para>This function is provided for downward compatibility reasons only and will be removed in a future update. It is recommended to use the <see cref="M:ILNumerics.ILMathInternal.zeros``1(ILNumerics.ILSize)" /> or <see cref="M:ILNumerics.ILMathInternal.zeros``1(System.Int32[])" /> overloads instead.</para><para>The interface of this function does not confirm to the rules of functions in ILNumerics. Therefore, in order to prevent for potential memory issues, the return value should be converted to 
            a concrete array type explicitely: </para><example><code>
            ILArray&lt;double&gt; A = todouble(zeros(NumericType.double, size(10,20))); 
            
            // better and easier would be: 
            ILArray&lt;double&gt; B = zeros&lt;double&gt;(10,20); 
            </code></example><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="F:ILNumerics.ILMathInternal.Lapack">
      <summary>
            Concrete interface wrapper class providing the native LAPACK functions
            </summary>
      <remarks>The LAPACK wrapper will be initialized the first time, 
            a call to any static method of ILMath is made. The decision, which 
            native module to load is done by use of native CPUID assembly statements.
            If the current processor does not support those calls or is not recognizable
            by ILNumerics, a generic - not optimized - version of native LAPACK code will
            be used than.</remarks>
    </member>
    <member name="F:ILNumerics.ILMathInternal.FFTImplementation">
      <summary>
            Platform specific FFT implementation, <b>internally</b> used to compute fft 
            </summary>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gammaLog(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the natural logarithm of the Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Gamma_function">Wikipedia - Gamma function</a> 
            and <a href="http://mathworld.wolfram.com/LogGammaFunction.html">Wolfram MathWorld - Log Gamma function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>log(gamma(<paramref name="x" />)) with <c>gamma(<paramref name="x" />) = from 0 to ∞ ∫(t^(<paramref name="x" />-1)exp(-t))dt</c>.</returns>
      <remarks>
        <list type="bullet">
          <item>The value of the Gamma function can be found simply using the exponential of the value found from the function. Example: exp(gammaLog(10.0)) will give the value of the gamma function at 10.0.</item>
          <item>In this particular implementation the positive real numbers are supported.</item>
          <item>If the given point <paramref name="x" /> is negative the return value will be double.NaN.</item>
          <item>If the given point <paramref name="x" /> is zero the return value will be double.PositiveInfinity.</item>
          <item>If any of the given points is double.NaN or double.IsInfinity is true, an ArgumentException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gamma(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Gamma_function">Wikipedia - Gamma function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>
        <c>gamma(<paramref name="x" />) = from 0 to ∞ ∫(t^(<paramref name="x" />-1)exp(-t))dt</c>.</returns>
      <remarks>
        <list type="bullet">
          <item>The value of the Gamma function is simply calculated as the exponential of the value found from the natural logarithm of Gamma function.</item>
          <item>In this particular implementation the positive real numbers are supported.</item>
          <item>If the given point <paramref name="x" /> is negative the return value will be double.NaN.</item>
          <item>If the given point <paramref name="x" /> is zero the return value will be double.PositiveInfinity.</item>
          <item>If any of the given points is double.NaN or double.IsInfinity is true, an ArgumentException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.factorial(ILNumerics.ILInArray{System.Int32})">
      <summary>
Factorial, from an array of integer elements.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Factorial">Wikipedia - Factorial</a>.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="n">Input array of non-negative integers.</param>
      <returns>An array of same size as <paramref name="n" /> with the factorial of each element.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input array is empty, an empty array will be returned.</item>
          <item>If an element of the array <paramref name="n" /> is negative, the result will be double.NaN.</item>
          <item>If any of the given points is NaN or Infinity an ArgumentException will be thrown.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.factorialLog(ILNumerics.ILInArray{System.Int32})">
      <summary>
Natural logarithm of factorial, from an array of integer elements.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="n">Input array of non-negative integers.</param>
      <returns>An array of same size as <paramref name="n" /> with the natural logarithm of factorials of each element in <paramref name="n" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input array is empty, an empty array will be returned.</item>
          <item>If an element of the array is negative, the result will be double.NaN.</item>
          <item>If the factorial of an element of the array is infinity, the result will be infinity.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.beta(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
Evaluates the componentwise beta function at an array of points defined by <paramref name="w" /> and <paramref name="z" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Beta_function">Wikipedia - Beta function</a>.
<para>[ILNumerics Core Module]</para>
</summary>
      <param name="z">Input array.</param>
      <param name="w">Input array so that <paramref name="z" /> &gt; <paramref name="w" /> for all component.</param>
      <returns> An array of same size as <paramref name="z" /> and with component values of the beta function.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="z" />i &lt; <paramref name="w" />i, the solution will be double.NaN.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If z and w size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.binomialCoefficients(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            Binomial coefficients of elements in <paramref name="n" /> and <paramref name="k" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Binomial_coefficient">Wikipedia - Binomial coefficient</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="n">Input array <paramref name="n" />.</param>
      <param name="k">Input array <paramref name="k" />.</param>
      <returns>An array of same size as <paramref name="n" /> and <paramref name="k" /> with values of the binomial coefficients.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="n" />i &lt; <paramref name="k" />i, the solution will be double.NaN.</item>
          <item>If any elements in <paramref name="n" /> and <paramref name="k" /> has the same value, the solution will be +1.0.</item>
          <item>If any elements in <paramref name="n" /> or <paramref name="k" /> has a negative value, the solution will be double.NaN.</item>
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If n and k size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.binomialCoefficientsLog(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
      <summary>
            Natural logarithm of binomial coefficients of elements in <paramref name="n" /> and <paramref name="k" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Binomial_coefficient">Wikipedia - Binomial coefficient</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="n">Input array <paramref name="n" />.</param>
      <param name="k">Input array <paramref name="k" />.</param>
      <returns>An array of same size as <paramref name="n" /> and <paramref name="k" /> with values of the binomial coefficients.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="n" />i &lt; <paramref name="k" />i, the solution will be double.NaN.</item>
          <item>If any elements in <paramref name="n" /> and <paramref name="k" /> has the same value, the solution will be +1.0.</item>
          <item>If any elements in <paramref name="n" /> or <paramref name="k" /> has a negative value, the solution will be double.NaN.</item>
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If n and k size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.gammaIncomplete(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the lower incomplete Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Incomplete_gamma_function">Wikipedia - Incomplete gamma function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <param name="a">The parameter of Gamma.</param>
      <returns>The value of the lower incomplete Gamma function.</returns>
      <remarks>
        <list type="bullet">
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If x is empty, an empty array will be returned.</item>
          <item>If any of the given points is NaN or Infinity an ArgumentException will be thrown.</item>
          <item>If any elements in <paramref name="x" /> is negative, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.betaIncomplete(System.Double,System.Double,ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the incomplete Beta function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function">Wikipedia - Incomplete beta function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function is evaluated. <paramref name="x" />  must be in [0,1].</param>
      <param name="a">A scalar, first parameter of the incomplete Beta function.</param>
      <param name="b">A scalar, second parameter of the incomplete Beta function.</param>
      <returns>The value of the incomplete Beta function at a given point.</returns>
      <remarks>
        <list type="bullet">
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If x is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi &gt; 1</c> and <c>xi &lt; 1</c>, double.NaN will be returned at that element.</item>
          <item>If any element of x is <c>xi == 0</c>, 0.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == 1</c>, 1.0 will be returned at that element.</item>
          <item>If a or b is negative, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.errorFunction(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function">Wikipedia - Error function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>The value of the error function at the given point <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, +1.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NegativeInfinity</c>, -1.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NaN</c>, double.NaN will be returned at that element.</item>
          <item>If </item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.errorFunctionComplement(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates of the complementary (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function">Wikipedia - Complementary Error function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>The value of the complementary error function at the given point <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NegativeInfinity</c>, +2.0 will be returned at that element.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.errorFunctionInverse(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the inverse of the (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function#Inverse_functions">Wikipedia - Inverse Error function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the inverse error function at the given point <paramref name="x" />.</returns>&gt;
            <remarks><list type="bullet"><item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item><item>If <paramref name="x" /> is empty, an empty array will be returned.</item><item>If any element of x is <c>xi &gt;= +1.0</c>, double.PositiveInfinity will be returned at that element.</item><item>If any element of x is <c>xi &lt;= -1.0</c>, double.NegativeInfinity will be returned at that element.</item></list><para>[ILNumerics Core Module]</para></remarks></member>
    <member name="M:ILNumerics.ILMathInternal.logistic(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the sigmoid logistic function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Logistic_function">Wikipedia - Logistic function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, +1.0 will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.NegativeInfinity</c>, 0.0 will be returned at that element.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <returns>The value of the logistic function at the given point <paramref name="x" />.</returns>
    </member>
    <member name="M:ILNumerics.ILMathInternal.logit(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the inverse of the sigmoid logistic function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Logit_function">Wikipedia - Logit function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">point defined between 0 and 1.</param>
      <returns>The logarithm of <paramref name="x" /> divided by 1.0 - <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi ≥ 1.0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi ≤ 0.0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 1.0</c>, double.PositiveInfinity will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned at that element.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselGenerator(ILNumerics.ILInArray{System.Double},ILNumerics.ILMathInternal.BesselElement,System.Int32)">
      <summary>
            Common method to evaluate the Bessel-functions.
            This helps to easily maintain the code, and only change at this point.
            Also this method ensures to test the input parameters once, and they are automatically applied to other
            Bessel-functions as well.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">At the points in x.</param>
      <param name="function">The arbitrary Bessel-function.</param>
      <param name="n">Given order n.</param>
      <returns>Evaluated values of the function.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselJ0(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 1.0 will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselJ1(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselJn(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Evaluates the Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselY0(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselY1(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselYn(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Evaluates the Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselModifiedK0(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselModifiedK1(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselModifiedKn(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselModifiedI0(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselModifiedI1(ILNumerics.ILInArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.besselModifiedIn(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMathInternal.diGamma(ILNumerics.ILInArray{System.Double})">
      <summary>
            Computes the Digamma function which is mathematically defined as the derivative of the logarithm of the gamma function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Digamma_function">Wikipedia - Digamma function</a>
            and <a href="http://mathworld.wolfram.com/DigammaFunction.html">Wolfram MathWorld - Digamma function</a>.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="xi">The point where the function is evaluated.</param>
      <returns>The value of the DiGamma function at <paramref name="xi" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="xi" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="xi" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.NaN</c> or <c>xi == double.NegativeInfinity</c>, there will be a double.NaN returned at that element.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, there will be a double.PositiveInfinity returned at that element.</item>
          <item>If any element of x is <c>xi &lt; 0</c> and is a round number, there will be a double.NegativeInfinity returned at that element.</item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMathInternal.end">
      <summary>
            Substitute for the index of the last element of a dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The 'end' placeholder can be used in subarray specification expressions. It will get 
            evaluated in a delayed manner, once the index of the dimension (and therefore the dimension length)
            is known. It than evaluates to the number of the index of the last element in the dimension.
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILMathInternal.eps">
      <summary>
            Double precision epsilon - the smallest difference from 1.0
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMathInternal.epsf">
      <summary>
            Single precision epsilon - the smalles difference from 1.0f
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMathInternal.MachineParameterDouble">
      <summary>
            Give extensive numerical machine parameter informations - double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMathInternal.MachineParameterSingle">
      <summary>
            Give extensive numerical machine parameter informations - single precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMathInternal.full">
      <summary>
            Address the whole dimension for subarray access
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMathInternal.RandomGenerator">
      <summary>
            Random number generator used for any generation of random numbers.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This property is thread safe (by using the [ThreadStatic] attribute).<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="F:ILNumerics.ILMathInternal.BinOptItExMode.VAN">
      <summary>
            vector op. array - not in-place
            </summary>
    </member>
    <member name="F:ILNumerics.ILMathInternal.BinOptItExMode.VAI">
      <summary>
            vector op. arra - in-place
            </summary>
    </member>
    <member name="F:ILNumerics.ILMathInternal.BinOptItExMode.AVN">
      <summary>
            array op. vector - not in-place
            </summary>
    </member>
    <member name="F:ILNumerics.ILMathInternal.BinOptItExMode.AVI">
      <summary>
            array op. vector - in-place
            </summary>
    </member>
    <member name="T:ILNumerics.ILMathInternal.precisionHelper`1">
      <summary>
            Prevent JIT "optimizations" - force single precision to be applied
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">mainly float here</typeparam>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILMathInternal.BesselElement">
      <summary>
            Internal helper delegate to compute an arbitrary Bessel function at the specified order and kind.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="x">The given point.</param>
      <param name="n">The given order.</param>
      <returns>The evaluated function.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.MachineParameterSingle">
      <summary>
            Extensive numerical machine parameter infos - single precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.ibeta">
      <summary>
            Radix
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.it">
      <summary>
            Number of base digits(bits) in the mantissa
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.irnd">
      <summary>
            Rounding and underflow information.  
            </summary>
      <remarks>
        <list type="bullet">
          <listheader>Rounding properties</listheader>
          <item>2,5: IEEE rounding conform </item>
          <item>1,4: not IEEE conform rounding </item>
          <item>0,3: truncating - no rounding </item>
        </list>
        <list type="bullet">
          <listheader>Under-/ Overflow. numbers below xmin will be interpreted as... </listheader>
          <item>0,1,2: zero</item>
          <item>3,4,5: xmin (IEEE conform)</item>
        </list>
      </remarks>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.ngrd">
      <summary>
            Number of guard digits in the product of 2 mantissas
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.machep">
      <summary>
            Exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.negep">
      <summary>
            Exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.iexp">
      <summary>
            Number of exponent bits 
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.minexp">
      <summary>
            Smallest power of ibeta without leading zeros in the mantissa
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.maxexp">
      <summary>
            Smallest power of ibeta where overflow occours
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.eps">
      <summary>
            Distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
      <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.epsneg">
      <summary>
            Alternative eps. ibeta <sup>negep</sup></summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.xmin">
      <summary>
            Smallest floating point number
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterSingle.xmax">
      <summary>
            Largest floating point number
            </summary>
    </member>
    <member name="T:ILNumerics.MachineParameterDouble">
      <summary>
            Extensive numerical machine parameter infos - double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.ibeta">
      <summary>
            Radix
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.it">
      <summary>
            Number of base digits(bits) in the mantissa
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.irnd">
      <summary>
            Rounding and underflow information.  
            </summary>
      <remarks>
        <list type="bullet">
          <listheader>Rounding properties</listheader>
          <item>2,5: IEEE rounding conform </item>
          <item>1,4: not IEEE conform rounding </item>
          <item>0,3: truncating - no rounding </item>
        </list>
        <list type="bullet">
          <listheader>Under-/ Overflow. numbers below xmin will be interpreted as... </listheader>
          <item>0,1,2: zero</item>
          <item>3,4,5: xmin (IEEE conform)</item>
        </list>
      </remarks>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.ngrd">
      <summary>
            Number of guard digits in the product of 2 mantissas
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.machep">
      <summary>
            Exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.negep">
      <summary>
            Exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.iexp">
      <summary>
            Number of exponent bits 
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.minexp">
      <summary>
            Smallest power of ibeta without leading zeros in the mantissa
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.maxexp">
      <summary>
            Smallest power of ibeta where overflow occours
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.eps">
      <summary>
            Distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
      <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.epsneg">
      <summary>
            Alternative eps. ibeta <sup>negep</sup></summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.xmin">
      <summary>
            Smallest floating point number
            </summary>
    </member>
    <member name="F:ILNumerics.MachineParameterDouble.xmax">
      <summary>
            Largest floating point number
            </summary>
    </member>
    <member name="T:ILNumerics.Licensing.ILAsmRuntimeLicense">
      <summary>
            Allows the execution of types. Embedded and loaded from licensed assemblies, restrict execution to that assembly (and not to an individual machine).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Licensing.ILLicense">
      <summary>
            Base class for all licenses
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Licensing.ILLicense.#ctor">
      <summary>
            Create empty license (used for serialization)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Licensing.ILLicense.Sign(System.Text.StringBuilder)">
      <summary>
            Sign the license content using ILNumerics private key
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="sb">string builder with complete license content</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.MinVersion">
      <summary>
            Minimum version of the assembly hosting <see cref="P:ILNumerics.Licensing.ILLicense.TargetTypeName" /> which this license is able to unlock
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.MaxVersion">
      <summary>
            Maximum version of the assembly hosting <see cref="P:ILNumerics.Licensing.ILLicense.TargetTypeName" /> which this license is able to unlock
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.From">
      <summary>
            Start validity date of this license
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.To">
      <summary>
            End validity date of this license, set to DateTime.MaxValue for perpetual licenses.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.TargetTypeName">
      <summary>
            The type name this license is able to unlock.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.TargetAssemblySimpleName">
      <summary>
            Assembly qualified name of the assembly hosting the licensed type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.Empty">
      <summary>
            Singleton of an empty license.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.ID">
      <summary>
            Unique identifier for this license.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicense.IsEvaluation">
      <summary>
            Flag determining if this is a trial license
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Licensing.ILAsmRuntimeLicense.#ctor">
      <summary>
            Create empty asm license (used for serialization)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILAsmRuntimeLicense.Assembly">
      <summary>
            md5 hash of the assembly given by AssemblyName or null (matching all assemblies).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILAsmRuntimeLicense.AssemblyName">
      <summary>
            Fully qualified name or '*' (matching all assemblies).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILAsmRuntimeLicense.CreatedBy">
      <summary>
            Unique ID of the license used to create this asm license.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Licensing.ILDevelopmentLicense">
      <summary>
            Allows the creation of AsmExecutionLicense instances. Installed into / loaded from local registry.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Licensing.ILRegRuntimeLicense">
      <summary>
            Allows the execution of types. Installed into / Loaded  from Registry. Does not restrict execution to individual assemblies. Tagged to an individual machine.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Licensing.ILRegRuntimeLicense.#ctor">
      <summary>
            Create empty registry license (used for serialization)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILRegRuntimeLicense.MachineKey">
      <summary>
            base64 md5 hash of Netbios Name, OSVersion, ProcessorCount
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Licensing.ILDevelopmentLicense.#ctor">
      <summary>
            Create empty development license (used for serialization)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILDevelopmentLicense.TargetFrom">
      <summary>
            controls properties for the resulting AsmRuntimeLicense
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILDevelopmentLicense.TargetTo">
      <summary>
            controls properties for the resulting AsmRuntimeLicense
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Licensing.ILLicenseManager.GetLicenses``1(System.String)">
      <summary>
            Retrieves a collection of licenses for all modules registered on the system.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Collection of available licenses</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicenseManager.Current">
      <summary>
            Singleton instance of the license manager
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Licensing.ILLicensingSVCResponse">
      <summary>
            ILNumerics Licensing service's response.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicensingSVCResponse.Message">
      <summary>
            Message delivered from the licensing SVC. May be null.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicensingSVCResponse.IsSuccess">
      <summary>
            Flag to indicate if the response was successeful.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Licensing.ILLicensingSVCResponse.Content">
      <summary>
            Licenses fetched from the licensing server.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Licensing.ILLicSVCClient.DoInstall">
      <summary>
            By default: install downloaded licenses into the reg. Set this to false in order to not touch the lokal registry. 
            </summary>
    </member>
    <member name="T:ILNumerics.GenEigenType">
      <summary>
            Specifies the type of eigenproblem
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The enumeration describes possible problem definitions for generelized eigenproblems:
            <list type="bullet"><item>Ax_eq_lambBx: A*V = r*B*V</item><item>ABx_eq_lambx: A*B*V = r*V</item><item>BAx_eq_lambx: B*A*V = r*V</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="F:ILNumerics.GenEigenType.Ax_eq_lambBx">
      <summary>
            A*V = r*B*V
            </summary>
    </member>
    <member name="F:ILNumerics.GenEigenType.ABx_eq_lambx">
      <summary>
            A*B*V = r*V
            </summary>
    </member>
    <member name="F:ILNumerics.GenEigenType.BAx_eq_lambx">
      <summary>
            B*A*V = r*V
            </summary>
    </member>
    <member name="T:ILNumerics.LogicalConversionMode">
      <summary>
            Modes for implicit conversions from logical arrays to System.Boolean
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <seealso cref="P:ILNumerics.Settings.LogicalArrayToBoolConversion" />
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.LogicalConversionMode.NonScalarThrowsException">
      <summary>
            Throw an exception on the attempt to convert a non scaler value to logical/boolean.
            </summary>
    </member>
    <member name="F:ILNumerics.LogicalConversionMode.ImplicitAllAll">
      <summary>
            Convert non scalar values to logical/boolean by applying the allall() function (i.e. it is true when all elements are non zero).
            </summary>
    </member>
    <member name="T:ILNumerics.NumericType">
      <summary>
            Enumerate all numeric type names used by ILNumerics
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.NumericType.Double">
      <summary>
            double element type.
            </summary>
    </member>
    <member name="F:ILNumerics.NumericType.Single">
      <summary>
            float element type.
            </summary>
    </member>
    <member name="F:ILNumerics.NumericType.Complex">
      <summary>
            complex element type.
            </summary>
    </member>
    <member name="F:ILNumerics.NumericType.FComplex">
      <summary>
            fcomplex element type.
            </summary>
    </member>
    <member name="F:ILNumerics.NumericType.Byte">
      <summary>
            byte element type.
            </summary>
    </member>
    <member name="F:ILNumerics.NumericType.Int32">
      <summary>
            Int32 element type.
            </summary>
    </member>
    <member name="F:ILNumerics.NumericType.UInt32">
      <summary>
            UInt32 element type.
            </summary>
    </member>
    <member name="F:ILNumerics.NumericType.Int64">
      <summary>
            Int64 element type.
            </summary>
    </member>
    <member name="F:ILNumerics.NumericType.UInt64">
      <summary>
            UInt64 element type.
            </summary>
    </member>
    <member name="T:ILNumerics.ILArrayStreamSerializationFlags">
      <summary>
            Defines the way ILArrays are serialized to stream.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <seealso cref="M:ILNumerics.ILDenseArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Serial">
      <summary>
            Print values 'vectorized': one value after each other. The true dimension configuration 
            of the array will be lost in the result. 
            </summary>
    </member>
    <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Formatted">
      <summary>
            Print values 'matrixwise'. The real dimensions configuration for the array are kept 
            in the result. The array will be printed by pages, consisting out of the 1st and 2nd 
            leading dimnsion. A dimension tag will prefix each page. The format can be used as 
            fancier output version for human reading as well as human readable serialization 
            format. ILArray's are capable of constructing from streams containing this type of 
            output. 
            </summary>
    </member>
    <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Matlab">
      <summary>
            Export whole array instance to matlab 5.0 format
            </summary>
    </member>
    <member name="T:ILNumerics.MatrixProperties">
      <summary>
            Possible properties for matrices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>These properties may be returned by function overloads receiving a MatrixProperties 
            parameter by reference. </para>
        <para><![CDATA[This enum is a bitflag'ed enum! You may query for any combination via the bitwise operators | and &. ]]></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Hermitian">
      <summary>
            Hermitian matrix 
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.PositivDefinite">
      <summary>
            Positive definite
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.UpperTriangular">
      <summary>
            Upper triangular matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.LowerTriangular">
      <summary>
            Lower triangular matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Square">
      <summary>
            Square matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Diagonal">
      <summary>
            Diagonal matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Singular">
      <summary>
            The matrix is singular 
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Hessenberg">
      <summary>
            Hessenberg matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Householder">
      <summary>
            Householder matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Unitary">
      <summary>
            Unitary matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Orthogonal">
      <summary>
            Orthogonal matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Orthonormal">
      <summary>
            Orthonormal matrix
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.RankDeficient">
      <summary>
            The matrix has deficient rank
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.None">
      <summary>
            The matrix has no special properties
            </summary>
    </member>
    <member name="F:ILNumerics.MatrixProperties.Unknown">
      <summary>
            No specific properties known (default)
            </summary>
    </member>
    <member name="T:ILNumerics.Toolboxes.EMInitializationMethod">
      <summary>
            Determine method of center initialization for EM algorithm.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Toolboxes.EMInitializationMethod.KMeans_random">
      <summary>
            Use the kmeans algorithm, choose random samples as centers for start.
            </summary>
    </member>
    <member name="F:ILNumerics.Toolboxes.EMInitializationMethod.KMeans_firstK">
      <summary>
            Use the kmeans algorithm, choose first k samples as centers for start.
            </summary>
    </member>
    <member name="F:ILNumerics.Toolboxes.EMInitializationMethod.User">
      <summary>
            Provide custom centers in the 'InitCenter' argument.
            </summary>
    </member>
    <member name="T:ILNumerics.Toolboxes.DistanceMetrics">
      <summary>
            Distance metrics.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Toolboxes.KRRTypes">
      <summary>
            Type definitions for possible kernels in kernel ridge regression.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Toolboxes.KRRTypes.linear">
      <summary>
            Linear kernel <c>k(x,y) = x'*y</c></summary>
    </member>
    <member name="F:ILNumerics.Toolboxes.KRRTypes.polynomial">
      <summary>
            Polynominal kernel <c>k(x,y) = (x'*y + c)^d</c></summary>
    </member>
    <member name="F:ILNumerics.Toolboxes.KRRTypes.gaussian">
      <summary>
            Gaussian (exponential) kernel <c>k(x,y) = exp(-norm(x-y)/sigma)</c></summary>
    </member>
    <member name="T:ILNumerics.Misc.ILArrayVisualizerProxy">
      <summary>
            ILNumerics Visual Studio Array Visualizer Helper (do not use this class directly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILArrayVisualizerProxy.#ctor(System.Array,ILNumerics.ILSize,System.String)">
      <summary>
            Create a new proxy representing an ILArray vor visualizing in ILNumerics Array Visualizer
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="array">the system array</param>
      <param name="size">the final n-dim array size</param>
      <param name="elementType">the name of the elements type</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILArrayVisualizerProxy.Create``1(ILNumerics.ILDenseArray{``0})">
      <summary>
            Create a new proxy for an existing ILArray (of any kind)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">The element type of the ILArray</typeparam>
      <param name="A">The n-dim ILArray to create a new proxy for</param>
      <returns>ILArray proxy</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILArrayVisualizerProxy.Dispose">
      <summary>
             Dispose off this proxy
             <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILArrayVisualizerProxy.Dispose(System.Boolean)">
      <summary>
            manually dispose off this proxy
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="manual"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILArrayVisualizerProxy.Finalize">
      <summary>
            Finalizer disposing off this proxy
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILArrayVisualizerProxy.CanVisualize">
      <summary>
            (not used)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILArrayVisualizerProxy.Size">
      <summary>
            The size of the array expression this proxy represents
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILArrayVisualizerProxy.Address">
      <summary>
            The physical address of the storage array for the result
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILArrayVisualizerProxy.SystemArray">
      <summary>
            Property exposing the underlying System.Array for the expression result
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILArrayVisualizerProxy.ElementType">
      <summary>
            String representation of the element types of the result
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILArrayVisualizerProxy.Is64BitProcess">
      <summary>
            Determines if the array represented by this proxy runs in the context of a 64 bit process
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILArrayVisualizerProxy.IsDisposed">
      <summary>
            Determines if this proxy has been disposed of
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILArrayVisualizerProxy.SourceType">
      <summary>
            string representation of the (array) type of the original expression result
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILCacheManager">
      <summary>
            Manages local array caches, singleton instance is accessed via: ILNumerics.ILArrayCache&lt;T;gt;.Manager
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILCacheManager.GetCache">
      <summary>
            Create a new ILArrayCache and add to managed caches
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>The new cache</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILCacheManager.FreeAllCaches">
      <summary>
            Dispose all managed caches
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILCacheManager.Manager">
      <summary>
            Singleton instance of a cache manager, used to retrieve local array caches
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.complex">
      <summary>
            Floating point complex value data type of double precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This class extends the system value types for real numbers to complex double 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point system.double brings (abs, log, sqrt, tan etc.),
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (e.g. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','&gt;','&gt;=' etc. Also there are some 
            explicit and some implicit casting operators from / to complex value into system 
            value types.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="F:ILNumerics.complex.real">
      <summary>
            Real part of this complex number
            </summary>
    </member>
    <member name="F:ILNumerics.complex.imag">
      <summary>
            Imaginary part of this complex number
            </summary>
    </member>
    <member name="F:ILNumerics.complex.i">
      <summary>
            Imaginary unit 
            </summary>
    </member>
    <member name="M:ILNumerics.complex.#ctor(System.Double,System.Double)">
      <summary>
            Constructor creating a new complex value
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real part</param>
      <param name="imag">Imaginary part</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Equals(System.Object)">
      <summary>
            Are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="obj">fcomplex object to determine the equality for</param>
      <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Equals(ILNumerics.complex)">
      <summary>
            Check if a complex number equals this complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="other">other complex number</param>
      <returns>true if both, real and imaginary parts of both complex number are (binary) equal, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.GetHashCode">
      <summary>
            Hash code of this comples
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Hash code of this complex</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Subtract two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Multiply two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
        <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true, if real and imaginary part are identical</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Subtract two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Multiply two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
        <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true, if real and imaginary part are identical</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.fcomplex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Double)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Double)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Double)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Double)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Double)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Double)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Double)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Double)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Double)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Double)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int64)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int64)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int64)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int64)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int64)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int64)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int64)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int64)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int64)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int64)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int32)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int32)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int32)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int32)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int32)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int32)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int32)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int32)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int32)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int32)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Single)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Single)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Single)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Single)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Single)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Single)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Single)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Single)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Single)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Single)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Byte)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Byte)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Byte)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Byte)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Byte)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Byte)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Byte)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Byte)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Byte)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Byte)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(System.Double,ILNumerics.complex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(System.Double,ILNumerics.complex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(System.Double,ILNumerics.complex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(System.Double,ILNumerics.complex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(System.Double,ILNumerics.complex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(System.Double,ILNumerics.complex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(System.Double,ILNumerics.complex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(System.Double,ILNumerics.complex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Double,ILNumerics.complex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Double,ILNumerics.complex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(System.Int64,ILNumerics.complex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(System.Int64,ILNumerics.complex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(System.Int64,ILNumerics.complex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(System.Int64,ILNumerics.complex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(System.Int64,ILNumerics.complex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(System.Int64,ILNumerics.complex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(System.Int64,ILNumerics.complex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(System.Int64,ILNumerics.complex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int64,ILNumerics.complex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int64,ILNumerics.complex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(System.Int32,ILNumerics.complex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(System.Int32,ILNumerics.complex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(System.Int32,ILNumerics.complex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(System.Int32,ILNumerics.complex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(System.Int32,ILNumerics.complex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(System.Int32,ILNumerics.complex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(System.Int32,ILNumerics.complex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(System.Int32,ILNumerics.complex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int32,ILNumerics.complex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int32,ILNumerics.complex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(System.Single,ILNumerics.complex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(System.Single,ILNumerics.complex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(System.Single,ILNumerics.complex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(System.Single,ILNumerics.complex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(System.Single,ILNumerics.complex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(System.Single,ILNumerics.complex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(System.Single,ILNumerics.complex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(System.Single,ILNumerics.complex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Single,ILNumerics.complex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Single,ILNumerics.complex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Addition(System.Byte,ILNumerics.complex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Subtraction(System.Byte,ILNumerics.complex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Multiply(System.Byte,ILNumerics.complex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Division(System.Byte,ILNumerics.complex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Equality(System.Byte,ILNumerics.complex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Inequality(System.Byte,ILNumerics.complex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThan(System.Byte,ILNumerics.complex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThan(System.Byte,ILNumerics.complex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Byte,ILNumerics.complex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Byte,ILNumerics.complex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_UnaryNegation(ILNumerics.complex)">
      <summary>
            Unary minus operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Complex input</param>
      <returns>Complex number similar to A, having real and imag part negated</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Implicit(System.Double)~ILNumerics.complex">
      <summary>
            Cast value to complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Value to cast</param>
      <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Implicit(System.Single)~ILNumerics.complex">
      <summary>
            Cast value to complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Value to cast</param>
      <returns>Complex number with the real part having the same value as the a and the imaginary part is 0.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Implicit(ILNumerics.fcomplex)~ILNumerics.complex">
      <summary>
            Cast value to complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Value to cast</param>
      <returns>Complex number being a copy of the real and imaginary parts of a.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Implicit(System.Byte)~ILNumerics.complex">
      <summary>
            Cast value to complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Value to cast</param>
      <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Implicit(System.Int32)~ILNumerics.complex">
      <summary>
            Cast value to complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Value to cast</param>
      <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Implicit(System.Int64)~ILNumerics.complex">
      <summary>
            Cast value to complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Value to cast</param>
      <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Double">
      <summary>
            Cast value from complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Complex value to cast</param>
      <returns>Double number with the real part of a </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Single">
      <summary>
            Cast value from complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Complex value to cast</param>
      <returns>number with the real part of a </returns>
      <remarks>the return value is the result of a cast from double to float.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~ILNumerics.fcomplex">
      <summary>
            Cast value from complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Complex value to cast</param>
      <returns>float complex number with the real and imaginary parts being a copy of a </returns>
      <remarks>The real and imaginary parts are the result of a cast to float.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Byte">
      <summary>
            Cast value from complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Complex value to cast</param>
      <returns>Number with the real part of a </returns>
      <remarks>The return value is the result of a cast to byte.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int32">
      <summary>
            Cast value from complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Complex value to cast</param>
      <returns>Number with the real part of a </returns>
      <remarks>The return value is the result of a cast to Int32.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int64">
      <summary>
            Cast value from complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Complex value to cast</param>
      <returns>number with the real part of a </returns>
      <remarks>the return value is the result of a cast to Int64.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.op_Implicit(System.Numerics.Complex)~ILNumerics.complex">
      <summary>
            Implicitly converts a System.Numerics.Complex type to an ILNumerics.complex.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">System.Numerics.Complex number.</param>
      <returns>ILNumerics.complex number.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Abs(ILNumerics.complex)">
      <summary>
            Absolute value of input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>The absolute value of the input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Angle(ILNumerics.complex)">
      <summary>
            Phase angle of complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>The phase angle of the input</returns>
      <remarks>For the result the Atan2 function of the <see cref="T:System.Math" /> class is used.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Atan(ILNumerics.complex)">
      <summary>
            Arcus tangens of complex input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Complex input</param>
      <returns>Arcus tangens of complex input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Acos(ILNumerics.complex)">
      <summary>
            Arcus cosinus of complex input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Complex input</param>
      <returns>Arcus cosinus of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Acos(System.Double)">
      <summary>
            Arcus cosinus of input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Arcus cosinus of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Asin(System.Double)">
      <summary>
            Arcus sinus of complex input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Arcus sinus of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Asin(ILNumerics.complex)">
      <summary>
            Arcus sinus of input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Arcus sinus of  input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Ceiling(ILNumerics.complex)">
      <summary>
            Round towards positive infinity
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Result is the next integer value greater then input</returns>
      <remarks>ILMath.Ceiling operates in both: real and imaginary parts seperately<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Floor(ILNumerics.complex)">
      <summary>
            Round towards negative infinity
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Result is the next integer value lower then input</returns>
      <remarks>ILMath.Floor operates in both: real and imaginary parts seperately<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Round(ILNumerics.complex)">
      <summary>
            Rounds towards nearest integer
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Result is the nearest integer value for input</returns>
      <remarks>ILMath.Round operates in both: real and imaginary parts deperately<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Sign(ILNumerics.complex)">
      <summary>
            Signum function
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Complex input </param>
      <returns>Sesult as input / Abs(input)</returns>
      <remarks>Sign(input) with input being complex returns the projection onto
            the unit circle. If input is 0+0i the result will be 0+0i.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Truncate(ILNumerics.complex)">
      <summary>
            Truncate a floating point complex value
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Integer part of input</returns>
      <remarks>Operates on real and imaginary parts seperately.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Cos(ILNumerics.complex)">
      <summary>
            Cosinus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Cosine of input</returns>
      <remarks>
        <para>The cosine is computed by the trigonometric euler equation: </para>
        <para>0.5 * [exp(i input) + exp(-i input)]</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Cosh(ILNumerics.complex)">
      <summary>
            Cosinus hyperbolicus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input</param>
      <returns>Cosine hyperbolicus of input</returns>
      <remarks>
        <para>The cosine is computed by the trigonometric euler equation: </para>
        <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Sin(ILNumerics.complex)">
      <summary>
            Sinus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Sinus of input</returns>
      <remarks>
        <para>The sinus is computed by the trigonometric euler equation: </para>
        <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Sinh(ILNumerics.complex)">
      <summary>
            Sinus hyperbolicus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input</param>
      <returns>Sinus hyperbolicus of input</returns>
      <remarks>
        <para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
        <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Exp(ILNumerics.complex)">
      <summary>
            Complex exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="exponent">Exponent</param>
      <returns>Result of exp(exponent)</returns>
      <remarks>For complex exponents, exp(exponent) is computed by
            <para>complex.FromPol(Math.Exp(exponent.real), exponent.imag)</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,System.Double)">
      <summary>
            Complex power for real exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Basis</param>
      <param name="exponent">Exponent</param>
      <returns>Result of input power exponent</returns>
      <remarks>The computation will be carried out by 
            <para>exp(log(input) * exponent)</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Pow(System.Double,System.Double)">
      <summary>
            Complex power - real basis, real exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="basis">Basis</param>
      <param name="exponent">Exponent</param>
      <returns>Complex number.</returns>
      <remarks>The result will be a complex number. For negative basis 
            the basis will be converted to a complex number and the power 
            will be computed in the complex plane.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,ILNumerics.complex)">
      <summary>
            Complex power - complex exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="basis">Basis</param>
      <param name="exponent">Exponent</param>
      <returns>Complex number exp(log(basis) * exponent).</returns>
      <remarks>The result will be the complex number exp(log(basis) * exponent). <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Sqrt(System.Double)">
      <summary>
            Square root
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>The square root of input</returns>
      <remarks>If input is smaller than 0.0, the computation will be done in the complex plane. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Sqrt(ILNumerics.complex)">
      <summary>
            Square root
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>The square root of input</returns>
      <remarks>Numerical recipes in C: Appendix C <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Tan(ILNumerics.complex)">
      <summary>
            Tangens
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Tangens of input</returns>
      <remarks>The tangens is 
            <para>sin(input) / cos(input)</para>
            if cos(input) == 0.0+0.0i, INF will be returned.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Tanh(ILNumerics.complex)">
      <summary>
            Tangens hyperbolicus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Tangens hyperbolicus</returns>
      <remarks>The tangens hyperbolicus is 
            <para>sinh(input) / cosh(input)</para>
            if cosh(input) == 0.0+0.0i, INF will be returned.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Log(ILNumerics.complex)">
      <summary>
            Complex logarithm
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Complex logarithm of input</returns>
      <remarks>The real part of the logarithm is computed by 
            <para>log (abs (input))</para><para>The imaginary part holds the phase of input.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Log(System.Double)">
      <summary>
            Logarithm of real input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value - may be negative</param>
      <returns>Complex logarithm</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Log10(System.Double)">
      <summary>
            Logarithm of base 10 of real input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value - may be negative</param>
      <returns>Complex logarithm of base 10</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Log2(System.Double)">
      <summary>
            Logarithm of base 2 of real input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value - may be negative</param>
      <returns>Complex logarithm of base 2</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Log10(ILNumerics.complex)">
      <summary>
            Logarithm of base 10
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Logarithm of base 10</returns>
      <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Log2(ILNumerics.complex)">
      <summary>
            Logarithm of base 2
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Input value</param>
      <returns>Logarithm of base 2.</returns>
      <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)" />
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.FromPol(System.Double,System.Double)">
      <summary>
            Convert polar notation into cartesian notation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="magnitude">Magnitude</param>
      <param name="angle">Phase</param>
      <returns>Complex value having magnitude and phase</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.ToString">
      <summary>
            Convert to string
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>String displaying the comlex number (full precision)</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.ToString(System.Int32)">
      <summary>
            Print formated output of this number, determine number of digits
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="digits">Number of digits</param>
      <returns>Formated output</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Abs">
      <summary>
            Magnitude of this complex instance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Magnitude</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Angle">
      <summary>
            Phase of this complex instance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Phase</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Acos">
      <summary>
            Arcus cosinus of this complex instance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Arcus cosinus</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Asin">
      <summary>
            Arcus sinus of this complex instance
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>arcus sinus</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Exp">
      <summary>
            Exponential / power of base e
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Power of base e</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Pow(System.Double)">
      <summary>
            Complex power real exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="exponent">Exponent</param>
      <returns>New complex number with result</returns>
      <remarks>If this instance is a and the exponent is e than 
            the result will be the complex number exp(log(a) * e). <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Pow(ILNumerics.complex)">
      <summary>
            Complex power - complex exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="exponent">Exponent</param>
      <returns>Complex number exp(log(this) * exponent).</returns>
      <remarks>If this instance is a than 
            the result will be the complex number exp(log(a) * exponent). <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.Sqrt">
      <summary>
            Square root of this complex value
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Square root of this complex value</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.Log">
      <summary>
            Logarithm of base e
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Logarithm of base e</returns>
      <remarks>The logarithm of a complex number A is defined as follows: <br /><list type="none"><item>real part: log(abs(A))</item><item>imag part: Atan2(imag(A),real(A))</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.complex.IsNaN(ILNumerics.complex)">
      <summary>
            Test if any of real or imaginary parts are NAN's
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Complex number to test</param>
      <returns>true if any of real or imag part is not a number</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.IsInfinity(ILNumerics.complex)">
      <summary>
            Test if any of real or imaginary parts are infinite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Complex number to test</param>
      <returns>true if any of real or imag part is infinite</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.IsPositiveInfinity(ILNumerics.complex)">
      <summary>
            Test if any of real or imaginary parts are pos.nfinite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Complex number to test</param>
      <returns>true if any of real or imag part is positive infinite</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.IsNegativeInfinity(ILNumerics.complex)">
      <summary>
            Test if any of real or imaginary parts are neg. infinite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Complex number to test</param>
      <returns>true if any of real or imag part is negative infinite</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.IsFinite(ILNumerics.complex)">
      <summary>
            Test if any of real or imaginary parts are finite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Complex number to test</param>
      <returns>true if any of real and imag part is finite</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.complex.iszero">
      <summary>
            Test if both of real or imaginary parts are 0
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true if real and imag part is 0</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.complex.conj">
      <summary>
            Complex conjugate
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.complex.INF">
      <summary>
            Positive infinity for real and imag part of complex value
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.complex.Zero">
      <summary>
            New complex, real and imaginary parts are zero
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.complex.NaN">
      <summary>
            Complex quantity, marked as being "not a number"
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILCSVLinesProvider`1">
      <summary>
            Class to hide Stream / String passed behavior for reading CSV lines iteratively.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILCSVLinesProvider`1.GetNextLine(System.String@)">
      <summary>
            Gets the next line with hiding its origin.
            If it is null, the text is reached the end.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Next trimmed line.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILArrayDebuggerProxy`1">
      <summary>
            This class is for internal use only. Do not instantiate from this class!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T"></typeparam>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILException">
      <summary>
            Generic exception, base class for all exceptions thrown by ILNumerics
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <param name="innerException">Inner Exception</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILMathException">
      <summary>
            Base class for mathematical exceptions. Needed e.g. in interpreter for proper error
            messages
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <param name="innerException">Inner Exception</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILDimensionMismatchException">
      <summary>
            One of the most common exceptions: The matrix sizes do not match
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <param name="innerException">Inner Exception</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILArgumentException">
      <summary>
            Something was wrong with the arguments supplied
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <param name="innerException">Inner Exception</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILArgumentSizeException">
      <summary>
            A function argument has the wrong size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <param name="innerException">Inner Exception</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILArgumentTypeException">
      <summary>
            A function was called with a wrong argument type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This exception might be thrown if the size or inner 
            type of a argument is invalid. (e.g. matrix expected, but 3D array found)
            <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <param name="innerException">Inner Exception</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILCastException">
      <summary>
            Thrown on illegal casting attempts
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String)">
      <summary>
            Costructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Addditional message to be included into the exception</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String,System.Exception)">
      <summary>
            Costructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included into the exception</param>
      <param name="innerException">On cascaded exception handling, the exception catched before</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILInvalidOperationException">
      <summary>
            Exception thrown if an operation could not completed
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <param name="innerException">Inner Exception</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Exceptions.ILInvalidLicenseException">
      <summary>
            No valid license could be found
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Exceptions.ILInvalidLicenseException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new ILInvalidLicenseException
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="message">Additional message to be included</param>
      <param name="innerExc">The exception that is the cause of the current exception, or a null reference.</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILExtensionMethods">
      <summary>
            Extension methods for ILNumerics types
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILArray{ILNumerics.complex},System.Numerics.Complex[])">
      <summary>
 
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
               <para>[ILNumerics Core Module]</para>
       </summary>
      <param name="A">this ILNumerics array</param>
      <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
      <returns>System.Array with the elements of A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
      <remarks>
        <para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
        <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
        <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code><para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para><para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para></example>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILInArray{ILNumerics.complex},System.Numerics.Complex[])">
      <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">this ILNumerics array</param>
      <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
      <returns>System.Array with the elements of A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
      <remarks>
        <para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
        <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
        <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code><para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para><para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para></example>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILOutArray{ILNumerics.complex},System.Numerics.Complex[])">
      <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">this ILNumerics array</param>
      <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
      <returns>System.Array with the elements of A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
      <remarks>
        <para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
        <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
        <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code><para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para><para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para></example>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILRetArray{ILNumerics.complex},System.Numerics.Complex[])">
      <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">this ILNumerics array</param>
      <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
      <returns>System.Array with the elements of A</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
      <remarks>
        <para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
        <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
        <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code><para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para><para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para></example>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)" -->
    <member name="T:ILNumerics.fcomplex">
      <summary>
            Floating point complex value data type of float (single) precision
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This class extends the system value types for real numbers to complex float 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point System.double brings (abs, log, sqrt, tan etc.) for 
            float precision complex,
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (e.g. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','&gt;','&gt;=' etc. Also there are some 
            explicit and some implicit casting operators from / to fcomplex values into system 
            value types. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="F:ILNumerics.fcomplex.real">
      <summary>
            Real part of this complex number
            </summary>
    </member>
    <member name="F:ILNumerics.fcomplex.imag">
      <summary>
            Imaginary part of this complex number
            </summary>
    </member>
    <member name="F:ILNumerics.fcomplex.i">
      <summary>
            Imaginary unit 
            </summary>
    </member>
    <member name="M:ILNumerics.fcomplex.#ctor(System.Single,System.Single)">
      <summary>
            Construct new float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="real">Real part</param>
      <param name="imag">Imaginary part</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Equals(System.Object)">
      <summary>
            Are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="obj">fcomplex object to determine the equality for</param>
      <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Equals(ILNumerics.fcomplex)">
      <summary>
            Check if a fcomplex number equals this fcomplex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="other">other complex number</param>
      <returns>true if both, real and imaginary parts of both complex number are (binary) equal, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.GetHashCode">
      <summary>
            Give HashCode of this fcomplex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>HashCode of this fcomplex number</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Subtract two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Multiply two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
        <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true, if real and imaginary part are identical</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,ILNumerics.complex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Subtract two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Multiply two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
        <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true, if real and imaginary part are identical</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int64)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int32)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Single)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Single)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Single)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Single)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Single)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Single)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Single)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Single)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Single)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Single)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Byte)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Double)">
      <summary>
            Add two complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Double)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Double)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Double)">
      <summary>
            Divide two numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Double)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Double)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Double)">
      <summary>
            Freater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Double)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Double)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Double)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int64,ILNumerics.fcomplex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int32,ILNumerics.fcomplex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(System.Single,ILNumerics.fcomplex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Single,ILNumerics.fcomplex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(System.Single,ILNumerics.fcomplex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(System.Single,ILNumerics.fcomplex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(System.Single,ILNumerics.fcomplex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(System.Single,ILNumerics.fcomplex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Single,ILNumerics.fcomplex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(System.Single,ILNumerics.fcomplex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Single,ILNumerics.fcomplex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Single,ILNumerics.fcomplex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Addition(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Add two complex values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First summand</param>
      <param name="B">Second summand</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Subtract two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Minuend</param>
      <param name="B">Subtrahend</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Multiply(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Multiply two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">First factor</param>
      <param name="B">Second factor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Division(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Divide two values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Divident</param>
      <param name="B">Divisor</param>
      <returns>Result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Equality(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Equality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>Result</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Inequality(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Unequality comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
      <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Greater than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThan(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Lower than comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Greater than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is greater than real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Byte,ILNumerics.fcomplex)">
      <summary>
            Lower than or equal to comparison for complex numbers
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Left side</param>
      <param name="B">Right side</param>
      <returns>true if real part of A is lower then real part of B, false otherwise</returns>
      <remarks>Only the real parts are compared!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_UnaryNegation(ILNumerics.fcomplex)">
      <summary>
            Unary minus operator
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="in1">fcomplex input</param>
      <returns>fcomplex number similar to in1, having real and imag part negated</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Abs(ILNumerics.fcomplex)">
      <summary>
            Magnitude value of float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex number</param>
      <returns>Magnitude of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Angle(ILNumerics.fcomplex)">
      <summary>
            Angle of complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex number to compute angle of</param>
      <returns>Angle of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)">
      <summary>
            Arcus cosinus for float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Arcus cosinus of input</returns>
      <remarks>The arcus cosinus of a complex number is computed by
            <para>Log(Sqrt(input^2 - 1) + input) * i </para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Acos(System.Single)">
      <summary>
            Arcus cosinus of real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">float input</param>
      <returns>Arcus cosinus of input</returns>
      <remarks>For input &gt; 1.0, <see cref="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)" /> will be used. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Asin(System.Single)">
      <summary>
            Arcus sinus of real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">float input</param>
      <returns>Arcus sinus of input</returns>
      <remarks>For input &gt; 1.0, <see cref="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)" /> will be used. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)">
      <summary>
            Arcus sinus for complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Arcus sinus of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Exp(ILNumerics.fcomplex)">
      <summary>
            Power of base e for float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Result of Exp(input)</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex,System.Double)">
      <summary>
            fcomplex power real exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">Basis </param>
      <param name="exponent">Exponent</param>
      <returns>New fcomplex number with result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Pow(System.Double,System.Double)">
      <summary>
            Complex power - real basis, real exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="basis">Basis</param>
      <param name="exponent">Exponent</param>
      <returns>fcomplex number.</returns>
      <remarks>The result will be a fcomplex number. For negative basis 
            the basis will be converted to a fcomplex number and the power 
            will be computed in the fcomplex plane.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex,ILNumerics.fcomplex)">
      <summary>
            Power: complex base, complex exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="basis">Basis</param>
      <param name="exponent">Exponent</param>
      <returns>result of basis^exponent</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Sqrt(System.Single)">
      <summary>
            Square root of real input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">float input</param>
      <returns>Square root of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Sqrt(ILNumerics.fcomplex)">
      <summary>
            Square root of complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Square root of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Tan(ILNumerics.fcomplex)">
      <summary>
            Tangens of float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Tangens of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Tanh(ILNumerics.fcomplex)">
      <summary>
            Tangens hyperbolicus of float complex input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Tangens hyperbolicus</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Log(ILNumerics.fcomplex)">
      <summary>
            Natural logarithm of complex input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Natural logarithm of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Log10(ILNumerics.fcomplex)">
      <summary>
            Logarithm to base 10
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Logarithm of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Log2(ILNumerics.fcomplex)">
      <summary>
            Logarithm of base 2
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Logarithm of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Log(System.Single)">
      <summary>
            Logarithm of real input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">float input - may be negative</param>
      <returns>Complex logarithm</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Log10(System.Single)">
      <summary>
            Logarithm of base 10 of real input
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">float input - may be negative</param>
      <returns>Complex logarithm of base 10</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Log2(System.Single)">
      <summary>
            Logarithm of base 2
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">float input - may be negative</param>
      <returns>Complex logarithm of base 2</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.FromPol(System.Single,System.Single)">
      <summary>
            Convert from polar to cartesian form
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="magnitude">Magnitude</param>
      <param name="angle">Angle</param>
      <returns>fcomplex number with magnitude <c>magnitude</c> 
            and phase <c>angle</c></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.ToString">
      <summary>
            Convert this float complex number to string
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>String representation of this float complex number</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.ToString(System.Int32)">
      <summary>
            Print formated output of this number, determine number of digits
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="digits">Number of digits</param>
      <returns>Formatted output</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Abs">
      <summary>
            Magnitude of this float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Magnitude</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Angle">
      <summary>
            Phase angle of this float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Phase angle </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Acos">
      <summary>
            Arcus cosinus of this float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Arcus cosinus</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Asin">
      <summary>
            Arcus sinus of this float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Arcus sinus</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Atan(ILNumerics.fcomplex)">
      <summary>
            Arcus tangens of float complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Arcus tangens of input</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Ceiling(ILNumerics.fcomplex)">
      <summary>
            Round towards next greater integer
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Rounded float complex number</returns>
      <remarks>Real and imaginary parts are independently rounded 
            towards the next integer value towards positive infinity.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Floor(ILNumerics.fcomplex)">
      <summary>
            Round towards next lower integer
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Rounded float complex number</returns>
      <remarks>Real and imaginary parts are independently rounded 
            towards the next integer value towards negative infinity.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Round(ILNumerics.fcomplex)">
      <summary>
            Round mercantilistic
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex number</param>
      <returns>Rounded number</returns>
      <remarks>Real and imaginaty parts are rounded independently. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Sign(ILNumerics.fcomplex)">
      <summary>
            Signum function
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns> Signum of input</returns>
      <remarks>
            For numbers a = 0.0 + 0.0i, sign(a)'s real and imag parts are 0.0. 
            For all other numbers sign(a) is the projection onto the unit circle.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Truncate(ILNumerics.fcomplex)">
      <summary>
            Truncate a floating point complex value
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Integer part of input</returns>
      <remarks>Operates on real and imaginary parts seperately.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Cos(ILNumerics.fcomplex)">
      <summary>
            Cosinus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Cosinus of input</returns>
      <remarks>
        <para>The cosinus is computed by the trigonometric euler equation: </para>
        <para>0.5 * [exp(i input) + exp(-i input)]</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Cosh(ILNumerics.fcomplex)">
      <summary>
            Cosinus hyperbolicus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Cosinus hyperbolicus of input</returns>
      <remarks>
        <para>The cosinus is computed by the trigonometric euler equation: </para>
        <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Sin(ILNumerics.fcomplex)">
      <summary>
            Sinus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Sinus of input</returns>
      <remarks>
        <para>The sinus is computed by the trigonometric euler equation: </para>
        <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Sinh(ILNumerics.fcomplex)">
      <summary>
            Sinus hyperbolicus
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>Sinus hyperbolicus of input</returns>
      <remarks>
        <para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
        <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Exp">
      <summary>
            Exponential / power of base e
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Power of base e</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Pow(System.Double)">
      <summary>
            Power of fcomplex number, real exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="exponent">Exponent</param>
      <returns>New fcomplex number with result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex)">
      <summary>
            Power of fcomplex number, complex exponent
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="exponent">Exponent</param>
      <returns>New fcomplex number with result</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Sqrt">
      <summary>
            Square root of fcomplex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Square root</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.Log">
      <summary>
            Logarithm of fcomplex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Natural logarithm</returns>
      <remarks>The logarithm of a complex number A is defined as follows: <br /><list type="none"><item>real part: log(abs(A))</item><item>imag part: Atan2(imag(A),real(A))</item></list><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.IsNaN(ILNumerics.fcomplex)">
      <summary>
            Test if any of real or imaginary parts are NAN's
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>true if any of real or imag part is not a number</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.IsInfinity(ILNumerics.fcomplex)">
      <summary>
            Test if any of real or imaginary parts are infinite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>true if any of real or imag part is infinite</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.IsPositiveInfinity(ILNumerics.fcomplex)">
      <summary>
            Test if any of real or imaginary parts are pos. infinite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>true if any of real or imag part is positive infinite</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.IsNegativeInfinity(ILNumerics.fcomplex)">
      <summary>
            Test if any of real or imaginary parts are neg. infinite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>true if any of real or imag part is negative infinite</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.IsFinite(ILNumerics.fcomplex)">
      <summary>
            Test if any of real or imaginary parts are finite
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">fcomplex input</param>
      <returns>true if any of real and imag part is finite</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.Double)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">double</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.Single)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">float</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.Byte)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">byte</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.Char)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">char</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int16)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Int16</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int32)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Int32</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int64)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">Int64</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt16)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">UInt16</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt32)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">UInt32</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt64)~ILNumerics.fcomplex">
      <summary>
            Implicit cast real number into complex number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">UInt64</param>
      <returns>fcomplex number with real part equals a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Double">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Single">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Byte">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Char">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int16">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int32">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">complex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int64">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt16">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt32">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt64">
      <summary>
            Explicit cast complex number into real number
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="a">fcomplex number</param>
      <returns>Real number with real part of a</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.fcomplex.iszero">
      <summary>
            Test if real and imag part are zero
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>true if real and imag parts are zero, false else</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.fcomplex.conj">
      <summary>
            Complex conjugate
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.fcomplex.INF">
      <summary>
            Positive infinity for real and imag part of complex value
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.fcomplex.Zero">
      <summary>
            New fcomplex, real and imaginary parts are zero
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.fcomplex.NaN">
      <summary>
            fcomplex quantity, marked as being "not a number"
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILMatFile">
      <summary>
            Matlab .mat file wrapper class
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This class reads and writes Matlab .mat files version 6! ! 
            All numeric array types are supported. The reading and writing of 
            Matlab cell arrays is not supported yet.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="F:ILNumerics.ILMatFile.ReservedKeywords">
      <summary>
            List of keywords which Matlab disallows for variable names
            </summary>
    </member>
    <member name="M:ILNumerics.ILMatFile.sizeOf(ILNumerics.ILMatFile.MatFileType)">
      <summary>
            size of single elements stored in Matlab's *.mat files
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="type">one of Matlab's inner element types</param>
      <returns>size in bytes </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.read_miMATRIX(System.IO.BinaryReader)">
      <summary>
            read ONE array (arbitrary dimensions/type) from MAT file
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="br">binary reader initialized and pointing to the beginning of the subarray element.</param>
      <returns>ILBaseArray of size and type originally stored into the mat file.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.readElementGeneric(System.IO.BinaryReader,ILNumerics.ILMatFile.MatFileType,System.Array@,System.Int32@,System.Int32)">
      <summary>
            read array of supported matlab data types
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="br">binary reader, opened and correctly positioned</param>
      <param name="storageType">actual storage type</param>
      <param name="realData">output: on return, the array read</param>
      <param name="len">input: number of bytes to read, on return: number of elements in array</param>
      <param name="paddBytes">padding border, the stream will be read to the next border of length 'paddBytes'.</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.createNameSubelement(System.String,System.Int32@,System.Byte[]@)">
      <summary>
            create name subelement for Matfile storage - padded to 8 byte border
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arrName">name property</param>
      <param name="type">will be 'miINT8' on return</param>
      <param name="data">return data array </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.getElementClass(ILNumerics.ILBaseArray)">
      <summary>
            get mat file array class type corresponding to this arra element type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arr">arra with generic system type or complex/fcomplex</param>
      <returns>mat file array class type code (int value)</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.getElementLength(ILNumerics.ILBaseArray)">
      <summary>
            get storage length of inner array elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="arr">base array in question</param>
      <returns>storage length in bytes</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.typeToString(ILNumerics.ILMatFile.MatFileType)">
      <summary>
            Convert MatFileType enumeration member to string representation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="type">MatFileType enumeration member</param>
      <returns>String representing the Matlab's inner element type</returns>
      <remarks>This function is obsolete. You may directly use the enumeration's functionality instead.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.AddArray(ILNumerics.ILBaseArray,System.String)">
      <summary>
            Add array to collection of arrays in this ILMatFile container
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">Array to be added to ILMatFile</param>
      <returns>String used to identify the array in the collection of arrays</returns>
      <remarks>
        <para>The internal <c>Name</c> property of array given will be used as identification key.</para>
        <para>Note, the test if elements of A are supported by MatFile specification is done if the MatFile is to be written to stream ('write').</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILInvalidOperationException">If the internal name of A does not fullfill the restrictions given by Matlab.</exception>
    </member>
    <member name="M:ILNumerics.ILMatFile.GetArray``1(System.String)">
      <summary>
            Retrieve array by name
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Expected type of the array</typeparam>
      <param name="name">Name of the array to retrieve</param>
      <returns>A clone of the array found or null, if no array with the given name exists</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.GetArray``1(ILNumerics.ILBaseArray)">
      <summary>
            Retrieve array by index
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Expected type of the array</typeparam>
      <param name="index">Index of the array</param>
      <returns>A clone of the array found or null, if no array at the given index exists</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.Write(System.IO.Stream)">
      <summary>
            Write this mat file into a binary stream
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="stream">Stream to receive data. This will commonly be a FileStream object.</param>
      <remarks>
        <para>This method writes the full content of the current mat file into a binary stream. The file 
            afterwards is suitable to be read again by ILNumerics.MatFile classes or by compatible *.mat file 
            readers - including Matlab, e.g.</para>
        <example>
          <code>
            MatFile m = new MatFile(myarrays); 
            using (Stream s = new FileStream("test.mat",FileMode.Create)) {
                m.Write(s);
            }
            </code>
        </example>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.Write(System.String)">
      <summary>
            Write all arrays to *.mat file
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="filename">Filename of the file to write the mat file to</param>
      <remarks>
        <para>The method writes the full content of the matfile to the file specified. If the filename 
            points to a file which already exists, that file will be overwritten. Otherwise a new file will
            be created. </para>
        <para>The file will be suitable for reading by ILNumerics.MatFile classes or by compatible *.mat file 
            readers - including e.g. matlab</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.#ctor(System.String)">
      <summary>
            Create MatFile object from existing mat file
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="file2open">Path to Matlab mat file to open</param>
      <remarks>Curently mat files up to Matlab version 6.5 are supported. Compressed mat file content is not supported yet.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.#ctor(ILNumerics.ILBaseArray[])">
      <summary>
            Create MatFile object from ILBaseArray
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="input">ILBaseArray of arbitrary size/type</param>
      <exception cref="T:System.ArgumentNullException">If input array was null or one of the names in the input arrays does not fullfill the restrictions made from Matlab</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.#ctor">
      <summary>
            Create an empty MatFile object
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMatFile.Dispose">
      <summary>
            Dispose all arrays of the matfile object
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>Calling dispose should be the last action for a matfile object. It is recommended to 
            utilize the matfile class in using blocks (C#) only.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILMatFile.Filelocation">
      <summary>
            Path to mat file, if this object was created from an existing mat file.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMatFile.Keys">
      <summary>
            List all key names currently stored with arrays
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILMatFile.Arrays">
      <summary>
            Retrieve a cell with all arrays stored in the mat file
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The cell returned will be clone of the arrays stored in the mat file. Altering any cell 
            elements will leave the arrays in the matfile (class/memory object) untouched.
            <para>The cell returned will be of size [n,2], where n is the number of arrays contained. The 
            first row saved the arrays, the second row containes scalar string arrays with the name of 
            the array in the corresponding row.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILMatFile.Item(System.String)">
      <summary>
            Add or replace named array to this MatFile
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="name">The assigned name of the array</param>
      <remarks>
        <para>The get acces is provided for compatibility reasons only. It may be removed in a future version! Use one of the typed retrieval functions <see cref="M:ILNumerics.ILMatFile.GetArray``1(System.String)" /> or <see cref="M:ILNumerics.ILMatFile.GetArray``1(ILNumerics.ILBaseArray)" /> instead.</para>
        <para>For get access the name must exist as key in the container. Use the MatFile.Keys property to get a list of all names if needed</para>
        <para>For set access, the name given must not be null or empty. It cannot be one of the <see cref="F:ILNumerics.ILMatFile.ReservedKeywords">ReservedKeywords</see>.
            If the name allready exist in the collection as name, the array currently assigned to it will be replaced. If the value is null, the current array will be removed from the list. If the name does 
            not already exist, the new array will be added and assigned to this name.</para>
        <para>Restrictions on array names: Matlab allowes variables to have names of maximum length 63. Therefore, if the 
            name given was larger than 63, it will be abbreviated. Names must start with a letter and contain only digits, (ASCII) letters or underscores '_'.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the name does not fullfill the restrictions given from Matlab</exception>
    </member>
    <member name="P:ILNumerics.ILMatFile.Count">
      <summary>
            Number of arrays in the mat file container
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILMatFile.MatFileType">
      <summary>
            Inner types for MATLAB data elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miUNKNOWN">
      <summary>
            unknown 
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miINT8">
      <summary>
            Int8
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT8">
      <summary>
            UInt8
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miINT16">
      <summary>
            Int16
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT16">
      <summary>
            UInt16
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miINT32">
      <summary>
            int32
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT32">
      <summary>
            UInt32
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miSINGLE">
      <summary>
            float
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miDOUBLE">
      <summary>
            double
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miINT64">
      <summary>
            Int64
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT64">
      <summary>
            UInt64
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miMATRIX">
      <summary>
            matrix type (general)
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miCOMPRESSED">
      <summary>
            compressed
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF8">
      <summary>
            utf8 encoded
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF16">
      <summary>
            utf16 encoded
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF32">
      <summary>
            utf32 encoded
            </summary>
    </member>
    <member name="T:ILNumerics.ILMatFile.MatFileArrayClass">
      <summary>
            Types for matrix chunks
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxCELL_CLASS">
      <summary>
            cell
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSTRUCT_CLASS">
      <summary>
            struct
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxOBJECT_CLASS">
      <summary>
            object
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxCHAR_CLASS">
      <summary>
            char
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSPARSE_CLASS">
      <summary>
            sparse
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxDOUBLE_CLASS">
      <summary>
            double
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSINGLE_CLASS">
      <summary>
            float
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT8_CLASS">
      <summary>
            Int8
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT8_CLASS">
      <summary>
            UInt8
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT16_CLASS">
      <summary>
            Int16
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT16_CLASS">
      <summary>
            UInt16
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT32_CLASS">
      <summary>
            Int32
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT32_CLASS">
      <summary>
            UInt32
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT64_CLASS">
      <summary>
            Int32
            </summary>
    </member>
    <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT64_CLASS">
      <summary>
            UInt32
            </summary>
    </member>
    <member name="T:ILNumerics.ILMemoryPool">
      <summary>
            The ILNumerics Memory Pool is the heart of the ILNumerics memory management.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The pool reduces the pressure on the systems memory caused by larger objects.
            <para>Arrays created in ILNumerics will try to allocate their memory from the pool. If the attempt fails, the memory is gathered from the regular managed heap instead.</para><para>Disposed array objects deterministically register their underlying storage in the pool for later reusing. The process is triggered by a deterministic disposal 
            pattern in conjunction with <a href="http://ilnumerics.net/$Arrays.html">ILNumerics array types</a> and <a href="http://ilnumerics.net/$FunctionRules.html">ILNumerics Function Rules</a>.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="F:ILNumerics.ILMemoryPool.Pool">
      <summary>
            The only global ILMemoryPool instance 
            </summary>
    </member>
    <member name="M:ILNumerics.ILMemoryPool.MinArrayLength``1">
      <summary>
            Gets the minimum length required for arrays of a certain element type to be stored in the pool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type of the pool</typeparam>
      <returns>minumun element length</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMemoryPool.New``1(System.Int64,System.Boolean,System.Boolean@)">
      <summary>
            Get new array of type T from memory pool.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="length">Size of T[]</param>
      <param name="clear">If true, set the elements in T[] to default(T)</param>
      <param name="cleared">Always true if <paramref name="clear" /> was set. Otherwise this will be true if the array was newly created instead of being recycled from the pool. False otherwise.</param>
      <remarks>
        <para>If the pool contains an unused matching element of sufficient size this element will be returned. If <paramref name="clear" /> was false,
            the result might still contain the old data.</para>
        <para>If the pool does not contain a matching element a new one is created.</para>
        <para>
          <b>Note:</b> The returned array may be larger than requested if it was recycled from the pool.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <returns>An array of type T of at least length <paramref name="length" /></returns>
    </member>
    <member name="M:ILNumerics.ILMemoryPool.New``1(System.Int64)">
      <summary>
            Get an array from the memory pool without clearing the elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="length">Required minimum length</param>
      <remarks>The returned array is only guaranteed to have at least length <paramref name="length" />. Its length may exceed <paramref name="length" />.
            There is no guarantee on the values contained in the returned array! To force all elements to their default value 
            use <see cref="M:ILNumerics.ILMemoryPool.New{T}(length, bool, out bool)" /><para>[ILNumerics Core Module]</para></remarks>
      <returns>An array of type T of at least length <paramref name="length" />.</returns>
    </member>
    <member name="M:ILNumerics.ILMemoryPool.Free``1(``0[])">
      <summary>
            Return a array of type T that is not needed anymore to the pool.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="array">The array to add to the pool</param>
      <remarks>You may also "free" objects not retrieved from the pool, in which case they are registered in the pool.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMemoryPool.MaxBytes``1">
      <summary>
            Get maximal potential size of the memory pool for objects of type T
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <returns>Maximal number of bytes in pool</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMemoryPool.Reset``1(System.Int64,System.Int32)">
      <summary>
            Reset &amp; reconfigure the pool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="MinPoolArrayLen">Minimum length for array object to be stored inside the pool</param>
      <param name="maxSizeMB">Overall size the memory pool consumes at most</param>
      <remarks>Reset will dispose all objects currently hold in the pool!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMemoryPool.Info(System.Boolean)">
      <summary>
            Give information about pool state
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shortVersion">true (default): abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info</param>
      <returns>Infos about current pool state</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILMemoryPoolInternal`1">
      <summary>
            Memory pool serving as temporary storage for System.Array objects
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The pool reduces the pressure on the systems memory caused by larger objects.
            <para>Arrays created in ILNumerics will first try to reclaim their memory from this pool. If that 
            fails, the memory is allocated from the managed heap only.</para><para>Disposed array objects register their underlying System.Array in the pool for 
            later reusing. The process is triggered by the ILNumerics memory management automatically.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Reset(System.Int64,System.Int32)">
      <summary>
            Reset &amp; reconfigure the pool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="MinArrayLength">Minimum length for array object to be stored inside the pool</param>
      <param name="PoolSizeMB">Overall size the memory pool consumes at most</param>
      <remarks>Reset will dispose all objects currently hold in the pool!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.DisposeContent">
      <summary>
            Dispose all objects currently hold in the pool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The pool get cleared and continues working with the same parameters after the call has finished. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Free(`0[])">
      <summary>
            Return or register an array object of value type in the pool that is not used anymore, i.e. free it
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">arbitrary element type</typeparam>
      <param name="arr">array</param>
      <remarks>
        <para>In order to be stored in the pool, the array must meet the minimum array length and must fit into the global pool size.
            Null objects or empty arrays or array not suitable for the pool will be silently ignored.</para>
        <para>If the new array is too large to fit into the remaining pool space, the oldest objects in the pool will be released until the object can get registered.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.New(System.Int64)">
      <summary>
            Request a System.Array instance (may not be cleared!)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">value type</typeparam>
      <param name="length">
        <b>minimum</b> length of array</param>
      <returns>System.Array - either from the pool or a newly created array</returns>
      <remarks>
        <para>If a suitable System.Array was found in the pool, this object is returned. 
            Otherwise a new array is created.</para>
        <para>There is no way of determining, if the array was reclaimed from pool or newly created! 
            If you must be sure, the element values are set to default(T), call the overloaded version 
            <see cref="!:ILNumerics.Misc.ILMemoryPool.New&lt;T&gt;(long, bool, out bool)" /> instead!</para>
        <para>If a new array could not get created due to an OutOfMemoryException, a garbage collection
            is triggered and the array is again requested from the pool. If this again fails, another attempt 
            to create the array is done. Exceptions may thrown from this last attempt are not catched and 
            therefore must be handled by the calling function.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.New(System.Int64,System.Boolean,System.Boolean@)">
      <summary>
            Request a System.Array instance and optionally clear the array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">value type</typeparam>
      <param name="length">length of array</param>
      <param name="clear">if true, the elements of the array returned are set to default(T).</param>
      <param name="iscleared">out paramater determining if the array returned has been cleared</param>
      <returns>System.Array - either from the pool or a newly created array</returns>
      <remarks>
        <para>If a suitable System.Array was found in the pool, this object is returned. Otherwise a new array is created.</para>
        <para>If the <paramref name="clear">clear </paramref> parameter was set to false, the
            <paramref name="iscleared">iscleared</paramref> parameter can be used to determine, if the object
            was returnd from the pool and may need extra clearing.</para>
        <para>If a new array could not get created due to an OutOfMemoryException, a garbage 
            collection is triggered and the array is again requested from the pool. If this again failes, 
            another attempt to create the array is done. Exceptions eventually thrown from this last 
            attempt are not catched and given back to the callee.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info(System.Boolean,System.Boolean)">
      <summary>
            Give infos about pool state, optionally reset counters
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
      <param name="reset">true: reset internal counter for reclaimed objects/ - bytes</param>
      <returns>infos about current pool state</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info">
      <summary>
            Give extended infos about pool state
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Full info about current and reclaimed pool objects</returns>
      <remarks>For short version infos use the overloaded version <see cref="!:ILNumerics.Misc.ILMemoryPool.Info(bool)" /><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info(System.Boolean)">
      <summary>
            Give infos about pool state, optionally reset counters
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
      <returns>infos about current pool state</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Shrink(System.Int64)">
      <summary>
            shrink the pool's content to SHRINK_PERCENT of the maximum pool size or at the size, suitable to store requestLen
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="requestLen">minimum length to make available (bytes)</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MaxRequestedLengthIncrease">
      <summary>
            factor used, to allow returned arrays to exceed the requested array length
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MinArrayLength">
      <summary>
            minimum length of array objects for recognition in the pool (default: 80k)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MaxBytes">
      <summary>
            maximum size of the pool configured in bytes
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.SuccessRate">
      <summary>
            percentage of allocation requests which could be successfully be completed
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.ReclaimedBytesCount">
      <summary>
            Number of reclaimed bytes since the pool exists
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The counter will be reset by calls to <see cref="!:ILNumerics.Misc.ILMemoryPool.Reset(int, int)" /><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.ReclaimedObjectsCount">
      <summary>
            Number of reclaimed objects since the pool exists
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The counter will be reset by calls to <see cref="!:ILNumerics.Misc.ILMemoryPool.Reset(int, int)" /><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.Misc.ILThreadPool">
      <summary>
            simple thread pool implementation - NOT THREAD SAFE !!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILResult`1">
      <summary>
            Result datatype, used for storing computational results and applying them to new data within ILNumerics machine learning functions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">Datatype of underlying array elements</typeparam>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILResult`1.Apply(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
      <summary>
            Apply the result on new datapoints
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="X">New datapoints, same dimension as used for learning.</param>
      <param name="arguments">Optional arguments.</param>
      <returns></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILResult`1.Dispose">
      <summary>
            Disposes the object.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILResult`1.IsDisposed">
      <summary>
            Flag to indicate if the result is disposed.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.ILScope">
      <summary>
            An artificial scope class, used by the ILNumerics memory management
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray[])">
      <summary>
             Begins an artificial scope block within a local function block
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="inputArrays">Any <b>input</b> arry, given as parameter for the current function</param>
      <returns>A new scope</returns>
      <remarks>
        <para>The <c>ILScope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>ILScope</c> is used, to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <example>
        <para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
        <code><![CDATA[ILRetArray<double> FreqPeaks(ILInArray<double> inData, ILOutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (ILScope.Enter(inData)) {    
                         
                    ILArray<double> Data = check(inData); 
                    ILArray<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    ILArray<double> Window = stdWindowFunc(Data.Length);  
                    ILArray<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    ILArray<double> indices = empty();  
                    ILArray<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray)">
      <summary>
             Begins an artificial scope block within a local function block
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="inputArrays">Any <b>input</b> arry, given as parameter for the current function</param>
      <returns>A new scope</returns>
      <remarks>
        <para>The <c>ILScope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>ILScope</c> is used, to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <example>
        <para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
        <code><![CDATA[ILRetArray<double> FreqPeaks(ILInArray<double> inData, ILOutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (ILScope.Enter(inData)) {    
                         
                    ILArray<double> Data = check(inData); 
                    ILArray<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    ILArray<double> Window = stdWindowFunc(Data.Length);  
                    ILArray<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    ILArray<double> indices = empty();  
                    ILArray<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILScope.Dispose">
      <summary>
            Dispose all arrays in this scope
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILScope.Context">
      <summary>
            The threading context - individual for each thread
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILScope.ILThreadingContext.RegisterArray(ILNumerics.ILBaseArray)">
      <summary>
            Registers an ILNumerics array for disposal after the current scope was left
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">arbitrary ILNumerics array</param>
      <remarks>
        <para>This method is part of the memory managent of ILNumerics. You should not 
            call this method explicitely!</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILScopeList`1.Peek(System.Int32)">
      <summary>
            peek element at distance 'index' from END!!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="index"></param>
      <returns></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Settings">
      <summary>
            The class provides static setting properties to control the behaviour of ILNumerics, see <a href="http://ilnumerics.net/$Configuration.html">Configuration</a> in the online documentation
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Settings.KnownIDENames">
      <summary>
            List of known IDE executable names used for detecting design mode and disabling OpenGL renderers for unsupported IDE.
            </summary>
      <remarks>
        <para>Currently the known IDEs span the following exe names: "devenv", "vbexpress", "vcsexpress", "vwdexpress", and "monodevelop".</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Settings.LoadDefaults">
      <summary>
            (Re)load settings from the application configuration file
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.DefaultRenderer">
      <summary>
            Configures or defines the default renderer used for interactive drawing controls like ILPanel, default: null (auto)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>By default, ILNumerics selects the optimal renderer for interactive panels (<see cref="!:ILNumerics.Drawing.ILPanel"></see>) automatically. For situations where 
            this does not work efficiently, the user is able to define the default renderer manually by setting this flag, either via app.config or programmatically.</para>
        <para>The setting will be considered for all panels created with ILNumerics at a later point.</para>
        <para>When setting this property via app.config, use the key 'ILNDefaultRenderer' and provide it one of the values of the RendererTypes enum. Valid values are any available interactive renderer: 
            <list type="bullet"><item>GDI</item><item>OpenGL</item><item>DirectX</item></list></para>
        <para>Using no setting signals ILNumerics to determine the optimal renderer automatically. This will cause OpenGL to be used. In a later version, on Windows it will default to DirectX.</para>
        <para>Keep in mind, the actual type of the renderer used at runtime may differs from that setting, since ILNumerics prevents from known situations where certain renderers are not working properly.</para>
        <para>ILNuerics provides the following options to determine the actual renderer used for ILPanel. Settings are applied in the following order. Subsequent settings may override values which were set earlier.</para>
        <list type="bullet">
          <item>ILNumerics.Settings, applied via app.config value 'ILNDefaultRenderer'</item>
          <item>ILNumerics.Settings, applied programmatically: <code>Settings.DefaultRenderer = ... </code></item>
          <item>Individual driver configuration for each <code>ILPanel</code>: <code>ILPanel.Driver = ... RendererTypes.OpenGL /  ...</code></item>
        </list>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.ShowMessageBoxOnGDIFallback">
      <summary>
            Gets or sets a flag indicating if a message box is shown to the user, once the rendering driver falls back to GDI; default: true
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>If at runtime unrecoverable errors prevent the driver from rendering successfully, a message box will inform the user 
            about the issue before the driver falls backt to GDI rendering. Setting this flag to false prevents the message box from showing.</para>
        <para>Potential problems with accelerated drivers commonly include: 
            <list type="bullet"><item>Outdated drivers: for OpenGL GPU rendering, currently OpenGL version 3.1 or higher is required.</item><item>Buggy drivers: especially 'first day support' drivers often show bugs with newer OpenGL functionality</item><item>Deactivated drivers: mobile devices sometimes deactivate GPU rendering for energy savings</item><item>Virtual machines and remote desktop connections do often provide limited access to graphics hardware only. This may leads to OpenGL contexts of 
            lower versions than neccessary and/or to the use of software implementations for OpenGL which may cause common problems with ILNumerics drawing controls. </item></list></para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.AllowInArrayAssignments">
      <summary>
            Performance switch, dis-/allow direct assignments to input parameters - brings more efficient 
            memory management, default: true (safer, less efficient)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>If this switch is set to 'false', you promise not to assign any values to input parameters 
            of type <c>ILInArray</c>, <c>ILInCell</c> or <c>ILInLogical</c>. This allows ILNumerics for more efficent 
            memory management, decreases the overall memory footprint of the application and enables certain 
            array operations to be automatically computed in-place. Depending on the specific algorithm
            the performance profit may range from 1% up to even about 30%.</para>
            This switch should be set for the whole application globally. It is not recommended to change the state of 
            this switch once the application runs.
            <para>Since this switch targets the full application, all functions and modules involved must also follow 
            that contract! For all builtin functions of ILNumerics, compliance with this rule is garanteed. This means, if you are 
            not using any 3rd party algorithms and are able to make sure your own functions follow that scheme as well, it is safe 
            to set this switch to <c>false</c> and profit from faster execution times.</para><para>See the <a href="http://ilnumerics.net/$PerfMemoryOpt.html">Optimizing Performance</a> article in the online documentation.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Settings.OpenGL31_FIX_GL_CLIPVERTEX">
      <summary>
            Work around OpenGL driver issues regarding GL_ClipDistance; set to true on problems on older GL 3.1 hardware (like GT 3XXM series); default: auto
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>On GL version 3.1 contexts, if the linking of affected shaders fails, the switch is automatically set to true.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Settings.CreateRowVectorsByDefault">
      <summary>
            Control layout of vectors when not specified explicitly.
            <list type="bullet"><item><term>true</term><description>When a vector is created without exlicitely specifying its shape, create a row vector</description></item><item><term>false (default)</term><description>When a vector is created without exlicitely specifying its shape, create a column vector</description></item></list>
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This setting affects the way ILNumerics handles the default shape for vectors created. One example is <see cref="!:ILNumerics.ILMath.array&lt;T&gt;( T[])" />, 
            where only the number of elements is given - but no size is specified. By default, ILNumerics will interpret the elements as targeting the <b>first</b> 
            dimension, ie. dimension #0. This will create a column vector. Setting this switch to 'true' will make ILNumerics to create a row vector in 
            such situations instead.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Settings.MemoryPoolProfileMaxLength">
      <summary>
            Upper limit of the range of array length to gather profiler information for
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MemoryPoolProfileMinLength">
      <summary>
            Lower limit of the range of array length to gather profiler information for
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MemoryPoolProfileFileName">
      <summary>
            If set to any non empty value, this setting triggers the memory pool profiler
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>Profiling the memory pool gives insights into those functions, which potentially 
            cause memory leaks in your application. It writes extensive stack trace information into the 
            logfile determined by this setting. It will contain the stack trace of any function, requesting 
            memory from the pool, which is never given back to the pool. Use this information in order to find and 
            correct those places - and increase stability and performance of your application. However, 
            make sure, this switch is cleared (or renamed) for production systems, since running the profiler 
            will diminish performance significantly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Settings.NativeDependenciesAbsolutePath">
      <summary>
            The absolute directory where ILNumerics should look for native dependencies (LAPACK, HDF5 etc.); default: empty string
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>By default (i.e.: empty string) ILNumerics will automatically determine the include path for native dependencies on startup. 
            In order to do so, the bitrate (Environment.Is64BitProcess) is examined and depending on its value one of 'bin32' or 'bin64' is 
            added to the beginning of the current PATH environment variable.</para>
        <para>In order to overwrite this behavior, one may set the absolut path to be included here. Note, this will prevent the 
            automatic (bitrate dependend) behaviour! When configuring the NativeDependenciesAbsolutePath the user must keep the 
            current bitrate into account and is responsible for placing the right binary distribution files into that folder. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MeasurePerformanceAtRuntime">
      <summary>
            Gives the current setting for the reporting of runtime performance measures to the windows performance monitor (perfmon) (readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>Activating this switch requires administrative rights on each system the application is run - at least for the first time! This is 
            necessary in order to register the performance counters to the system. Afterwards, the application does not require administrative rights anymore.
            <para>Measuring the performance at runtime does not produce a substantial impact on the performance of your algorithm. However, due to the need for elevated rights 
            the feature is disabled by default. In order to enable it, a configuration variable named "ILNMeasurePerformanceAtRuntime" needs to be set in your 
            application configuration file.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Settings.ManagedMultiplyBlockSize">
      <summary>
            Block size used for blocked managed matrix multiply, default: 150
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.ManagedMultiplyMaxElementSize">
      <summary>
            Threshold on number of elements in either input matrix below which matrix multiplication is done managed only, default: 200
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MinimumQuicksortLength">
      <summary>
            Determine the minimum length for arrays to be sorted via Quicksort algorithm, smaller arrays are sorted via insertion sort
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MaxNumberThreads">
      <summary>
            Maximum number of threads for parallel execution of internal functions in ILNumerics
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>In order to maximize execution speed of numerical algorithms, the value of <c>MaxNumberThreads</c> should be equal to the number 
            of <b>real</b> processor cores on the system. For processors utilizing <a href="http://en.wikipedia.org/wiki/Hyper-threading">Hyper-threading</a> the number on virtual cores 
            may be higher. However, since those virtual cores share certain ressources for execution, parallel utiliziation can not efficently be done with them. In this cases, the number of 'cores' 
            appearing e.g. in the windows task manager is misleading and the true number of independent cores should be used for <c>MaxNumberThreads</c> instead. Consult your proccessor vendor in order to find out, how many 
            independant cores your system utilizes.</para>
        <para>Since the number of independent cores is not reliably determined by .NET, ILNumerics defaults to 2 cores on all multicore machines. Therefore, this setting should be <a href="http://ilnumerics.net/$Configuration.html">set manually</a> for 
            better processor utilization on multicore machines.</para>
        <para>If your algorithm uses custom parallel execution models, it may 
            be necessary to set this value to '1'. ILNumerics will run single threaded than - leaving you the option to configure 
            the execution on parallel threads on your own.</para>
        <para>The setting of this value also effects the corresponding value of any unmanaged optimized support library (e.g. MKL) internally used by ILNumerics.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MaxNumberThreadsConfigured">
      <summary>
            Determine, if the current setting of <see cref="P:ILNumerics.Settings.MaxNumberThreads" /> is the result of a custom configuration.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MinParallelElement3Count">
      <summary>
            Threshold used to determine, if computations of O(n^3) built-in-functions are done in parallel on multicore machines; default: 300.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MinParallelElement2Count">
      <summary>
            Threshold used to determine, if computations of O(n^2) built-in-functions are done in parallel on multicore machines; default: 500.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MinParallelElement1Count">
      <summary>
            Threshold used to determine, if computations of O(n) built-in-functions are done in parallel on multicore machines; default: 1000.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MinElementLength4SystemArrayCopy">
      <summary>
            Threshold used to determine the minimum number of elements for system array copy. default: 10.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth">
      <summary>
            Maximal recursion depth the quicksort can go. default: 100 (for array length up to 2^100).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Settings.LogicalArrayToBoolConversion">
      <summary>
            Controls implicit conversions from logical arrays to System.Boolean
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This setting specifies, how logical arrays are converted to System.Boolean. Those 
            conversions are important, in order to simplify expressions like 
            <code>if (A &gt; B) { ... }</code> on arrays A and B. 
            <para>Here, the comparison <code>A &gt; B</code> creates a logical array of the same size than A and B. The logical array contains
            the result of the elementwise 'greater than' comparison. This setting here controls, how that logical is converted
            to a System.Boolean, in order to evaluate the 'if' condition. </para><para>The default is <c>LogicalConversionMode.NonScalarThrowsException</c>, which would cause an exception to be thrown in 
            the example above. Only scalar logical arrays can be used in such implicit conversions than.</para><para>In order to further simplify the syntax, the <c>LogicalConversionMode.ImplicitAllAll</c> setting can be used. The above expression
            would evaluate to true, if <b>all</b> elements of B are greater than corresponding elements of A. This settings therefore 
            eases the syntax for most situations. However, since most comparison operators comply to the underlying <b>all</b> rule, 
            the '!=' (not equal to) operator does not - at least to the extend of common intuition. In an expression: 
            <code>if (A != B) { ... }</code> one would intuitively expect to execute the code block, if <b>at least one element</b> of A does not equal the corresponding element
            of B. However, due to the <b>all</b> rule, this is not the case! In fact, the code would be executed only, if <b>all</b> elements would 
            evaluate to true. I.e. if no single pair of corresponding elements in A and B are equal. In order to 
            get the intuitively expected behavior, one would override this by:
            <code>if (ILMath.any(A != B)) { ... } </code> 
            Since it may cause hard to find bugs, this setting should be used with care.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Settings.UseThreadAffinity">
      <summary>
            Determine, if main and worker threads should bind to constant cpus or not. The default is not to bind.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>It usually is more efficient, to leave control of cpu binding to the runtime. However, if in certain situations, more control is required, this flag can 
            be used to make ILNumerics worker threads be affine to corresponding (native) threads.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.ILSize">
      <summary>
            ILSize - dimensions for array objects (immutable)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The class internally manages the dimensions of ILNumerics arrays. 
            The class is immutable. Therefore, once created, it informs the user 
            about all dimension related properties, but cannot get altered.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.#ctor(System.Int32[])">
      <summary>
            Create new ILSize
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">variable length dimensions specifier</param>
      <remarks>Trailing singleton dimensions of dims will be kept.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.#ctor(ILNumerics.ILBaseArray[])">
      <summary>
            Create new size descriptor from given data
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="size">Size description</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.#ctor(System.Boolean,System.Int32[])">
      <summary>
            Create new size descriptor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="trimSingletons">true: trailing singleton 
            dimensions will be trimmed, false: keep trailing singleton dimensions</param>
      <param name="size">Size description</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.WorkingDimension">
      <summary>
            Find default dimension to work on
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Index of first non singleton dimension (i.e. dimension that is not 1); 0, if this array is a scalar.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.SequentialIndexDistance(System.Int32)">
      <summary>
            Storage distance of elements in dimension dim
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dim">0-based index of dimension to query the element distance for</param>
      <returns>Storage distance of elements between adjacent elements of dimension dim
            </returns>
      <remarks>If dimension index dim is larger than the number of 
            dimensions of this array, the number of elements will 
            be returned (trailing singleton dimensions).<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.GetSequentialIndexDistances(System.Int32)">
      <summary>
            Distances between adjacent elements for all dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="minLength">minimum length of array to be 
            returned. If this is larger than the number of dimensions 
            in this size descriptor, the array will have minLength elements, 
            with elements outside this dimensions repeating the value 
            of the last dimension. The length of the array returned will 
            be equal or greater than max(minLength,NumberOfDimensions).</param>
      <remarks>This is provided for performance reasons and should be 
            used internally only. It enables developer of index access routines 
            to cache the elements distances directly inside their functions 
            without having to query the info on every index access.
            <para>Keep in mind, only the distances for the number of my 
            dimensions are returned. Higher dimensions must be set to 
            NumberOfElements if needed. This is different than querying 
            the distances by SequentialIndexDistance(int), which will assume 
            and return trailing dimensions to be 1.</para><para>IMPORTANT: ALTERING THE ARRAY RETURNED IS NOT ALLOWED AND 
            MAY LEAD TO SERIOUS INSTABILITY AND UNWANTED SIDE EFFECTS!</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.ToIntArray">
      <summary>
            Transfer my dimensions to integer array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Integer array containing a copy of all dimensions length</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.ToIntArray(System.Int32)">
      <summary>
            Transfer my dimensions to integer array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="length">Minimum length of output array. If length 
            is larger than my dimensions, trailing ones will be added.</param>
      <returns>Integer array containing a copy of dimensions length. 
            Trailing elements outside my dims will be one.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.ToIntArrayEx(System.Int32)">
      <summary>
            return dimension vector, fixed length, for subarray operations
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="length"></param>
      <returns>dimension vector, corresponds to reshaped or unlimited dimensions</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.IndexFromArray(System.Int32[])">
      <summary>
            Transform indices from int[] System.Array into sequential index of underlying 1dim array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">int array of nrDims length, min length: 1, all indices must fit into my dimensions</param>
      <returns>Index pointing to element defined by 'idx'</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.IndexFromArray(System.Boolean@,System.Int32[]@,System.Int32[])">
      <summary>
            Transform dimension position into sequential index, gather expand 
            information
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">int array of arbitrary length</param>
      <param name="MustExpand">[output] true, if the indices 
            given address an element outside of 
            this dimensions size. In this case, the output parameter 
            'Dimensions' carry the sizes 
            of new dimensions needed. False otherwise</param>
      <param name="dimensions">sizes of dimension if expansion is needed. 
            Must be predefined to length of max(idx.Length,m_nrDims) at least</param>
      <returns>Index number pointing to the value's position in 
            sequential storage.</returns>
      <remarks>no checks are made for idx to fit inside dimensions! 
            This functions is used for left side assignments. Therefore it 
            computes the destination index also if it lays outside 
            the array bounds.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.IndexFromArray(System.Int32[],System.Int32)">
      <summary>
            Unshift dimensions of indices from int[] Array 
            and translate to index for sequential storage access 
            in my dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">int array of the same length as 
            the number of dimensions of this storage. Indices must 
            lay within my dimensions.</param>
      <param name="unshift">Number of dimensions to unshift 
            idx before computing index</param>
      <returns>Index number pointing to the value's position 
            in sequential storage.</returns>
      <remarks>If idx contains elements (indices) larger than 
            my dimension bounds, an exception will be thrown. If unshift 
            is 0, the length of idx may be smaller than the length of 
            my dimensions. However, with unshift &gt; 0 the result 
            is undefined.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.GetShifted(System.Int32)">
      <summary>
            Return shifted version
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">Number of dimensions to shift. The value
            will be considered modules the number of dimensions of 
            this size descriptor.</param>
      <returns>Shifted version of this size descriptor object.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.GetReshapedSize(System.Int32)">
      <summary>
            Create dimension sizes for reshaping index adressing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimCount">Needed number of destination array dimensions</param>
      <returns>Dimension sizes, cutted trailing dimensions are multiplied to last dimension returned.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.IsSameSize(ILNumerics.ILSize)">
      <summary>
            Compares the size of this dimension to another dimension object.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dim2">size descriptor to compare this to.</param>
      <returns>Returns true if the sizes are the same, else returns false. 
            The comparison is made by recognizing singleton dimensions. Therefore 
            only non singleton dimensions are compared in the order of their 
            appearance. </returns>
      <remarks>The function returns true, if the squeezed dimensions of 
            both size descriptors match.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.IsSameShape(ILNumerics.ILSize)">
      <summary>
            Compares the shape of this dimension to another dimension object
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dim2">size descriptor to compare this to.</param>
      <returns>Returns true if the shapes are the same, else returns false. </returns>
      <remarks>This function is more strict than IsSameSize. In order 
            for two dimensions to have the same shape, ALL dimensions must match - 
            even singleton dimensions.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.GetSqueezed">
      <summary>
            [deprecated] Create copy of this size descriptor having all singleton 
            dimensions removed.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>a squeezed copy</returns>
      <remarks>This function is deprecated. Use the ILSize.Squeeze()
            memeber instead. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.Squeeze">
      <summary>
            Create and return copy without singleton dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Copy of this size descriptor having all singleton dimensions removed.</returns>
      <remarks> This function does not alter this object (since ILSize is 
            immutable).
            <para>All arrays in ILNumerics have at least 2 dimensions. 
            Therefore all but the first two singleton dimensions can be removed.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.Trim">
      <summary>
            Return size descriptor, having trailing singleton dimensions removed
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Copy without trailing singleton dimensions</returns>
      <remarks>This object will NOT be altered. As usual for all ILArrays, 
            the result wil have at least 2 dimensions.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.ToString">
      <summary>
            Pretty print dimensions in the format "[a,b,c]"
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Dimensions as String</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.GetHashCode">
      <summary>
            Generate hash code based on the dimension information
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Hash code</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILSize.Equals(System.Object)">
      <summary>
            Checks for equaltiy of this dimensions to another dimensions object
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="obj">Dimensions object to compare this instance with</param>
      <returns>true, if both dimensions have the same <b>shape</b></returns>
      <remarks>This is equivalent to <c>IsSameShape((ILSize)obj)</c>.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.op_Inequality(ILNumerics.ILSize,ILNumerics.ILSize)">
      <summary>
            'Not equal' operator on two instances of <see cref="T:ILNumerics.ILSize" />
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="s1">first size object</param>
      <param name="s2">second size object</param>
      <returns>true, if both instances do not have the same <b>shape</b></returns>
      <remarks>The operator is an alias for <code>!ILSize.Equals()</code><para>If either one of <paramref name="s1" /> or <paramref name="s2" /> is null, the operator returns false.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILSize.op_Equality(ILNumerics.ILSize,ILNumerics.ILSize)">
      <summary>
            'Equal' operator on two instances of <see cref="T:ILNumerics.ILSize" />
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="s1">first size object</param>
      <param name="s2">second size object</param>
      <returns>true, if both instances have the same <b>shape</b></returns>
      <remarks>The operator is an alias for <code>ILSize.Equals()</code>.
            <para>If either one of <paramref name="s1" /> or <paramref name="s2" /> is null, the operator returns false.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILSize.Empty00">
      <summary>
            An size descriptor of size 0x0
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILSize.Scalar1_1">
      <summary>
            An size descriptor of size 1x1
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILSize.Column2_1">
      <summary>
            An size descriptor of size 2x1
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILSize.Column3_1">
      <summary>
            An size descriptor of size 3x1
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILSize.NumberOfDimensions">
      <summary>
Get number of dimensions.
<para>[ILNumerics Core Module]</para>
</summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILSize.NonSingletonDimensions">
      <summary>
            Number of non singleton dimensions of the array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>Non singleton dimensions are dimensions which length is larger than 1. 
            Empty dimensions (length = 0) will not be taken into account.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILSize.NumberOfElements">
      <summary>
            Number of elements in the array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILSize.Longest">
      <summary>
            Length of the longest dimension
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.ILSize.Item(System.Int32)">
      <summary>
            Get length for dimension specified (Readonly)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Index of dimension</param>
      <returns>Length of dimension specified by idx</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If idx is negative</exception>
      <remarks>
        <para>For idx corresponds to an existing dimension, 
            the length of that dimension is returned. If idx is larger than 
            the number of dimensions 1 is returned. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Native.IILFFT">
      <summary>
            Interface for all FFT methods supported
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            performs backward n-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="nDims">number of dimensions of fft</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            performs backward n-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="nDims">number of dimensions of fft</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            performs backward 1-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimension to perform fft along</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            performs backward 1-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimension to perform fft along</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            performs backward n-dimensional fft on hermitian sequence
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="nDims">number of dimensions of fft</param>
      <returns>result, same size as A</returns>
      <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            performs backward n-dimensional fft on hermitian sequence
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="nDims">number of dimensions of fft</param>
      <returns>result, same size as A</returns>
      <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            performs backward 1-dimensional fft on hermitian sequence
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimension to perform fft along</param>
      <returns>result, same size as A</returns>
      <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            performs backward 1-dimensional fft on hermitian sequence
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimension to perform fft along</param>
      <returns>result, same size as A</returns>
      <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            performs n-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="nDims">number of dimension of fft</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            performs n-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="nDims">number of dimension of fft</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            performs n-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="nDims">number of dimension of fft</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            performs n-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="nDims">number of dimension of fft</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
      <summary>
            performs 1-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimension to perform fft along</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{System.Double},System.Int32)">
      <summary>
            performs 1-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimension to perform fft along</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            performs 1-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimension to perform fft along</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{System.Single},System.Int32)">
      <summary>
            performs 1-dimensional fft
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">input array</param>
      <param name="dim">dimension to perform fft along</param>
      <returns>result, same size as A</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILFFT.FreePlans">
      <summary>
            Clear all currently cached plans. Tasks like FreePlans should be left to the ILNumerics memory management. Calling the method manually (without good reasons) may lead to poor performance!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Native.IILFFT.CachePlans">
      <summary>
            true, if the implementation caches plans between subsequent calls
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Native.IILFFT.SpeedyHermitian">
      <summary>
            true, if the implementation efficiently transforms from/to hermitian sequences (hermitian symmetry).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>If this property returns 'true', the implementation brings increased performance. 
            If not, the symmetry methods will bring no performance advantage over the 1D transforms. <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.Native.ILACMLFFT">
      <summary>
            Wrapper for FFT interface using ACML ver. 3.6
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Native.ILFFTW3FFT">
      <summary>
            Wrapper for FFT interface using FFTW3 libs
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Native.ILFFTW3FFT.fftw_iodim">
      <summary>
            This struct is used to define (n-dimensional) transform sizes
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>This struct is only user in C-API. It is NOT used for the Fortran interface (i.e. it's not used in here)!!! <para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.n">
      <summary>
            length of dimension
            </summary>
    </member>
    <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.iS">
      <summary>
            input stride
            </summary>
    </member>
    <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.oS">
      <summary>
            output stride
            </summary>
    </member>
    <member name="T:ILNumerics.Native.MKLParameter">
      <summary>
            MKL configuration parameters (constant definitions)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Native.MKLValues">
      <summary>
            MKL configuration values (constant definitions)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Native.MKLImports">
      <summary>
            import functions (pinvoke)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.MKLImports.DftiComputeForward(System.IntPtr,System.Double[],System.Double[])">
            DFTI native DftiComputeForward declaration 
        </member>
    <member name="M:ILNumerics.Native.MKLImports.DftiComputeBackward(System.IntPtr,System.Double[],System.Double[])">
            DFTI native DftiComputeBackward declaration 
        </member>
    <member name="T:ILNumerics.Native.ILMKLFFT">
      <summary>
            Wrapper for FFT interface using MKL 10_03
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILMKLFFT.FreePlans">
      <summary>
            Invalidates the currently cached fft descriptor. Calling this method manually is mostly not needed and may even lead to poor performance.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Native.IILLapack">
      <summary>
            Interface to all LAPACK/BLAS functions available
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>Each native module must implement this interface explicitly. Calls 
            to native functions are made virtual by calling functions of this interface.
            Therefore the user can transparently call any function regardless of the 
            plattform the assymbly (currently) runs on. The native modules implementing
            this interface take care of the details of implementation. 
            <para>Usually users of the library will not have to handle with this interface. 
            Its functions will be used from inside built in functions and are therefore wrapped 
            (mainly from inside <see cref="T:ILNumerics.ILMath">ILNumerics.ILMath</see>).</para><para>Every LAPACK/BLAS function is explicitly implemented for any type supported.
            e.g. IILLapack includes four functions doing general matrix multiply: dgemm, zgemm, cgemm and sgemm - 
            for all four floating point datatypes supported from the LAPACK package.</para><para>LAPACK is an open source linear algebra functions package optimized for 
            use together with highly natively optimized BLAS functions. A LAPACK guide is 
            available in the internet: <see href="http://www.netlib.org/lapack">www.netlib.org</see>.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
      <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="B">pointer to array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
      <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="B">pointer to array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
      <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="B">pointer to array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
      <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="B">pointer to array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dgesdd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
      <summary>
             singular value decomposition, new version, more memory needed
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table"><listheader><term>jobz value</term><description>... will result in:</description></listheader><item><term>A</term><description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description></item><item><term>S</term><description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description></item><item><term>O</term><description>If M &gt;= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description></item><item><term>N</term><description>no columns of U or rows of V**T are computed.</description></item></list></param>
      <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
      <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
      <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M &gt;= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item><item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
      <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
      <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
      <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
      <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
      <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
      <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
      <param name="info">
        <list>
          <item> 0:  successful exit.</item>
          <item><![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
          <item><![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
        </list>
      </param>
      <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sgesdd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
      <summary>
             singular value decomposition, new version, more memory needed
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table"><listheader><term>jobz value</term><description>... will result in:</description></listheader><item><term>A</term><description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description></item><item><term>S</term><description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description></item><item><term>O</term><description>If M &gt;= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description></item><item><term>N</term><description>no columns of U or rows of V**T are computed.</description></item></list></param>
      <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
      <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
      <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M &gt;= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item><item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
      <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
      <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
      <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
      <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
      <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
      <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
      <param name="info">
        <list>
          <item> 0:  successful exit.</item>
          <item><![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
          <item><![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
        </list>
      </param>
      <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cgesdd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
      <summary>
             singular value decomposition, new version, more memory needed
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table"><listheader><term>jobz value</term><description>... will result in:</description></listheader><item><term>A</term><description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description></item><item><term>S</term><description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description></item><item><term>O</term><description>If M &gt;= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description></item><item><term>N</term><description>no columns of U or rows of V**T are computed.</description></item></list></param>
      <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
      <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
      <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M &gt;= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item><item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
      <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
      <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
      <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
      <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
      <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
      <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
      <param name="info">
        <list>
          <item> 0:  successful exit.</item>
          <item><![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
          <item><![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
        </list>
      </param>
      <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zgesdd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
      <summary>
             singular value decomposition, new version, more memory needed
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table"><listheader><term>jobz value</term><description>... will result in:</description></listheader><item><term>A</term><description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description></item><item><term>S</term><description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description></item><item><term>O</term><description>If M &gt;= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description></item><item><term>N</term><description>no columns of U or rows of V**T are computed.</description></item></list></param>
      <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
      <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
      <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M &gt;= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item><item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
      <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
      <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
      <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
      <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
      <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
      <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
      <param name="info">
        <list>
          <item> 0:  successful exit.</item>
          <item><![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
          <item><![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
        </list>
      </param>
      <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
      <summary>
             singular value decomposition, older version, less memory needed
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item><item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item><item> = 'O':  If M &gt;= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item><item> = 'N':  no columns of U or rows of V**T are computed.</item></list></param>
      <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
      <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
      <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M &gt;= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item><item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
      <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
      <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
      <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
      <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
      <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
      <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
      <param name="info">
        <list>
          <item> 0:  successful exit.</item>
          <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
          <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
        </list>
      </param>
      <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
      <summary>
             singular value decomposition, older version, less memory needed
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item><item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item><item> = 'O':  If M &gt;= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item><item> = 'N':  no columns of U or rows of V**T are computed.</item></list></param>
      <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
      <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
      <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M &gt;= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item><item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
      <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
      <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
      <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
      <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
      <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
      <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
      <param name="info">
        <list>
          <item> 0:  successful exit.</item>
          <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
          <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
        </list>
      </param>
      <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
      <summary>
             singular value decomposition, older version, less memory needed
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item><item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item><item> = 'O':  If M &gt;= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item><item> = 'N':  no columns of U or rows of V**T are computed.</item></list></param>
      <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
      <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
      <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M &gt;= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item><item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
      <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
      <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
      <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
      <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
      <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
      <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
      <param name="info">
        <list>
          <item> 0:  successful exit.</item>
          <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
          <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
        </list>
      </param>
      <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
      <summary>
             singular value decomposition, older version, less memory needed
             <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item><item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item><item> = 'O':  If M &gt;= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item><item> = 'N':  no columns of U or rows of V**T are computed.</item></list></param>
      <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
      <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
      <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M &gt;= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item><item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
      <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
      <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
      <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
      <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
      <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M &gt;= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
      <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
      <param name="info">
        <list>
          <item> 0:  successful exit.</item>
          <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
          <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
        </list>
      </param>
      <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dpotrf(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
      <summary>
            cholesky factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.spotrf(System.Char,System.Int32,System.Single[],System.Int32,System.Int32@)">
      <summary>
            cholesky factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cpotrf(System.Char,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
      <summary>
            cholesky factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zpotrf(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
      <summary>
            cholesky factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dpotri(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
      <summary>
            matrix inverse via cholesky factorization (?potrf)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.spotri(System.Char,System.Int32,System.Single[],System.Int32,System.Int32@)">
      <summary>
            matrix inverse via cholesky factorization (?potrf)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cpotri(System.Char,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
      <summary>
            matrix inverse via cholesky factorization (?potrf)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zpotri(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
      <summary>
            matrix inverse via cholesky factorization (?potrf)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dpotrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
      <summary>
            solve equation system via cholesky factorization (?potrs)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.spotrs(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
      <summary>
            solve equation system via cholesky factorization (?potrs)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cpotrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
      <summary>
            solve equation system via cholesky factorization (?potrs)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zpotrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
      <summary>
            solve equation system via cholesky factorization (?potrs)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dgetrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
      <summary>
            LU factorization of general matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sgetrf(System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Int32@)">
      <summary>
            LU factorization of general matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cgetrf(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],System.Int32@)">
      <summary>
            LU factorization of general matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zgetrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
      <summary>
            LU factorization of general matrix
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dgetri(System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
      <summary>
            inverse of a matrix via LU factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sgetri(System.Int32,System.Single[],System.Int32,System.Int32[],System.Int32@)">
      <summary>
            inverse of a matrix via LU factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cgetri(System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],System.Int32@)">
      <summary>
            inverse of a matrix via LU factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zgetri(System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
      <summary>
            inverse of a matrix via LU factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dorgqr(System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
      <summary>
            QR factor extraction
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sorgqr(System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32@)">
      <summary>
            QR factor extraction
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cungqr(System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32@)">
      <summary>
            QR factor extraction
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zungqr(System.Int32,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
      <summary>
            QR factor extraction
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dgeqrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
      <summary>
            QR factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sgeqrf(System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32@)">
      <summary>
            QR factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cgeqrf(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32@)">
      <summary>
            QR factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zgeqrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
      <summary>
            QR factorization
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dgeqp3(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32@)">
      <summary>
            QR factorisation with column pivoting
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sgeqp3(System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Single[],System.Int32@)">
      <summary>
            QR factorisation with column pivoting
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cgeqp3(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],ILNumerics.fcomplex[],System.Int32@)">
      <summary>
            QR factorisation with column pivoting
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zgeqp3(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32@)">
      <summary>
            QR factorisation with column pivoting
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Int32@)">
      <summary>
            multipliation for general matrix with QR decomposition factor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Int32@)">
      <summary>
            multipliation for general matrix with QR decomposition factor
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dtrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
      <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
      <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
      <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
      <param name="N">order of A</param>
      <param name="nrhs">number of right hand sides - columns of matrix B</param>
      <param name="A">square matrix A</param>
      <param name="LDA">spacing between columns for A</param>
      <param name="B">(input/output) on input: right hand side, on output: solution x </param>
      <param name="LDB">spacing between columns for B</param>
      <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.strtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
      <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
      <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
      <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
      <param name="N">order of A</param>
      <param name="nrhs">number of right hand sides - columns of matrix B</param>
      <param name="A">square matrix A</param>
      <param name="LDA">spacing between columns for A</param>
      <param name="B">(input/output) on input: right hand side, on output: solution x </param>
      <param name="LDB">spacing between columns for B</param>
      <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.ctrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
      <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
      <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
      <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
      <param name="N">order of A</param>
      <param name="nrhs">number of right hand sides - columns of matrix B</param>
      <param name="A">square matrix A</param>
      <param name="LDA">spacing between columns for A</param>
      <param name="B">(input/output) on input: right hand side, on output: solution x </param>
      <param name="LDB">spacing between columns for B</param>
      <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.ztrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
      <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
      <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
      <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
      <param name="N">order of A</param>
      <param name="nrhs">number of right hand sides - columns of matrix B</param>
      <param name="A">square matrix A</param>
      <param name="LDA">spacing between columns for A</param>
      <param name="B">(input/output) on input: right hand side, on output: solution x </param>
      <param name="LDB">spacing between columns for B</param>
      <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.dgetrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32,System.Int32@)">
      <summary>
            solve system of linear equations by triangular matrices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="trans">transpose before work?</param>
      <param name="N">number rows</param>
      <param name="NRHS">number right hand sides</param>
      <param name="A">matrix A</param>
      <param name="LDA">spacing between columns: A</param>
      <param name="IPIV">pivoting indices</param>
      <param name="B">matrix B</param>
      <param name="LDB">spacing between columns: B</param>
      <param name="info">success info</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.sgetrs(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Single[],System.Int32,System.Int32@)">
      <summary>
            solve system of linear equations by triangular matrices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="trans">transpose before work?</param>
      <param name="N">number rows</param>
      <param name="NRHS">number right hand sides</param>
      <param name="A">matrix A</param>
      <param name="LDA">spacing between columns: A</param>
      <param name="IPIV">pivoting indices</param>
      <param name="B">matrix B</param>
      <param name="LDB">spacing between columns: B</param>
      <param name="info">success info</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.cgetrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],ILNumerics.fcomplex[],System.Int32,System.Int32@)">
      <summary>
            solve system of linear equations by triangular matrices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="trans">transpose before work?</param>
      <param name="N">number rows</param>
      <param name="NRHS">number right hand sides</param>
      <param name="A">matrix A</param>
      <param name="LDA">spacing between columns: A</param>
      <param name="IPIV">pivoting indices</param>
      <param name="B">matrix B</param>
      <param name="LDB">spacing between columns: B</param>
      <param name="info">success info</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.IILLapack.zgetrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32,System.Int32@)">
      <summary>
            solve system of linear equations by triangular matrices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="trans">transpose before work?</param>
      <param name="N">number rows</param>
      <param name="NRHS">number right hand sides</param>
      <param name="A">matrix A</param>
      <param name="LDA">spacing between columns: A</param>
      <param name="IPIV">pivoting indices</param>
      <param name="B">matrix B</param>
      <param name="LDB">spacing between columns: B</param>
      <param name="info">success info</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Native.ILACML4_1">
      <summary>
            LAPACK implementation for AMD processors
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>By using this module, you will have to make sure,
            you placed all runtime binaries for AMD's performance library 
            into the binary output dir accessable for ILNumerics assemblies. 
            Those modules must be donwloaded seperately, since it is not 
            permitted to distribute them among with LGPL code. However, 
            developing and redistributing of products with ACML is possible though. 
            AMD currently does not charge money for a redistributable 
            license, given that one signs a license agreement with AMD 
            individually.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.Native.ILLapackGenLinux">
      <summary>
            Generic LAPACK implementation, unsupported processor types
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackGenLinux.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
      <summary>
            Implements wrapper for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to double array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="B">pointer to double array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined double array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackGenLinux.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
      <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to double array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="B">pointer to double array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined double array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackGenLinux.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
      <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to double array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="B">pointer to double array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined double array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackGenLinux.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
      <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to double array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="B">pointer to double array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined double array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackGenLinux.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="a"></param>
      <param name="lda"></param>
      <param name="s"></param>
      <param name="u"></param>
      <param name="ldu"></param>
      <param name="vt"></param>
      <param name="ldvt"></param>
      <param name="info"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackGenLinux.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="a"></param>
      <param name="lda"></param>
      <param name="s"></param>
      <param name="u"></param>
      <param name="ldu"></param>
      <param name="vt"></param>
      <param name="ldvt"></param>
      <param name="info"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackGenLinux.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="a"></param>
      <param name="lda"></param>
      <param name="s"></param>
      <param name="u"></param>
      <param name="ldu"></param>
      <param name="vt"></param>
      <param name="ldvt"></param>
      <param name="info"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackGenLinux.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="a"></param>
      <param name="lda"></param>
      <param name="s"></param>
      <param name="u"></param>
      <param name="ldu"></param>
      <param name="vt"></param>
      <param name="ldvt"></param>
      <param name="info"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Native.ILLapackMKL10_0">
      <summary>
            Generic LAPACK implementation, unsupported processor types
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.FreeBuffers">
      <summary>
            Free all buffers from the MKL Fast Memory Management. Use sparingly and carefully!
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
      <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to double array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="B">pointer to double array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined double array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
      <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to double array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="B">pointer to double array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined double array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
      <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to double array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="B">pointer to double array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined double array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
      <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
      <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
      <param name="M">Number of rows in A</param>
      <param name="N">Number of columns in B</param>
      <param name="K">Number of columns in A and number of rows in B</param>
      <param name="alpha">multiplicationi factor for A</param>
      <param name="A">pointer to double array A</param>
      <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
      <param name="B">pointer to double array B</param>
      <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
      <param name="beta">multiplication faktor for matrix B</param>
      <param name="C">pointer to predefined double array C of neccessary length</param>
      <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
      <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="a"></param>
      <param name="lda"></param>
      <param name="s"></param>
      <param name="u"></param>
      <param name="ldu"></param>
      <param name="vt"></param>
      <param name="ldvt"></param>
      <param name="info"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="a"></param>
      <param name="lda"></param>
      <param name="s"></param>
      <param name="u"></param>
      <param name="ldu"></param>
      <param name="vt"></param>
      <param name="ldvt"></param>
      <param name="info"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="a"></param>
      <param name="lda"></param>
      <param name="s"></param>
      <param name="u"></param>
      <param name="ldu"></param>
      <param name="vt"></param>
      <param name="ldvt"></param>
      <param name="info"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Native.ILLapackMKL10_0.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
      <summary>
            singular value decomposition
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="jobz"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="a"></param>
      <param name="lda"></param>
      <param name="s"></param>
      <param name="u"></param>
      <param name="ldu"></param>
      <param name="vt"></param>
      <param name="ldvt"></param>
      <param name="info"></param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.SpecialFunctionsHelper">
      <summary>
            Useful functions for the SpecialFunctions class. It contains all internal methods.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.SpecialFunctionsHelper.BetaApprox(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
      <summary></summary>
      <param name="a"></param>
      <param name="b"></param>
      <param name="x"></param>
      <returns></returns>
    </member>
    <member name="M:ILNumerics.SpecialFunctionsHelper.poly(System.Double,System.Double[])">
      <summary>
            Evaluate a polynomial at point x.
            Coefficients are ordered by power with power k at index k.
            Example: coefficients [3,-1,2] represent y=2x^2-x+3.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="z">The location where to evaluate the polynomial at.</param>
      <param name="coefficients">The coefficients of the polynomial, coefficient for power k at index k.</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.SpecialFunctionsHelper.ErfImp(System.Double,System.Boolean)">
      <summary>
            Implementation of the error function.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="z">Where to evaluate the error function.</param>
      <param name="invert">Whether to compute 1 - the error function.</param>
      <returns>the error function.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.SpecialFunctionsHelper.ErfInvImpl(System.Double,System.Double,System.Double)">
      <summary>
            The implementation of the inverse error function.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="p">First intermediate parameter.</param>
      <param name="q">Second intermediate parameter.</param>
      <param name="s">Third intermediate parameter.</param>
      <returns>the inverse error function.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Storage.ILCellStorage">
      <summary>
            The class realizes an internal storage wrapper for cell arrays. It takes care of value semantics for reference types.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Storage.ILDenseStorage`1">
      <summary>
            The class realizes an internal storage wrapper. It stores the internal data array
            and the dimension specifications for both: ILRetArray and ILDenseStorage (reference and solid).
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics.Storage.ILStorage">
      <summary>
            Background storage object used internally.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Storage.ILStorage.m_size">
      <summary>
            size of this storage
            </summary>
    </member>
    <member name="P:ILNumerics.Storage.ILStorage.Size">
      <summary>
            Size of the storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILStorage`1.GetValueTyped(System.Int32[])">
      <summary>
            Get single value from this storage.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Integer array holding the dimension specifier</param>
      <returns>Element at the position pointed to by idx.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILStorage`1.SetValueTyped(`0,System.Int32[])">
      <summary>
            Set value of element at the specified position.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">new value</param>
      <param name="idx">position of the element to be altered</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Storage.ILDenseStorage`1.m_data">
      <summary> 
            Internal storage object. Contains the final System.Array storage and a reference counter.
            </summary>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetLimits(`0@,`0@)">
      <summary>
            Get minimum and maximum value of all elements - if these exist.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="minValue">Output: minimum value.</param>
      <param name="maxValue">Output: maximum value.</param>
      <returns>True if the limits exists and could be computed, false otherwise.</returns>
      <remarks>Empty arrays will return false. The output parameter will be default(type).<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetLimits(`0@,`0@,System.Boolean)">
      <summary>
            Get minimum and maximum value of all elements - if existing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="minValue">Output: minimum value.</param>
      <param name="maxValue">Output: maximum value.</param>
      <param name="includeInfNaNs">true: recognize Inf, NaN values; false: ignore those values</param>
      <returns>True if the limits exists and could be computed, false otherwise.</returns>
      <remarks>Empty arrays will return false. The output parameter will be default(ElementType) then.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.ToString">
      <summary>
            Write information about the ILDenseStorage to string.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>String containing general information about the current instance of 
            ILDenseStorage and the formatted elements' values.</returns>
      <remarks>If the number of elements exceeds a certain amount, the display will be abreviated.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.ValuesToString(System.Int32)">
      <summary>
            print formated values to string
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="maxLength">Maximum number of characters per line. 0: no limit</param>
      <returns>StringBuilder object filled with formated values.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Equals(System.Object)">
      <summary>
            Check if the content of this array equals the content of obj.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="obj">storage containing the values with which to compare this array.</param>
      <returns>True if all elements contained in obj are equal to the 
            elements of this array, false otherwise.</returns>
      <remarks>This method compares the object references of corresponding elements. 
            The size and type of both arrays must match. Otherwise false will be returned.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Equals(ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Test if this dense storage equals another dense storage.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">storage to compare this storage with</param>
      <returns>True if all elements and dimension sizes match, false otherwise.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetHashCode">
      <summary>
            generate a hash code based on the current arrays values
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>hash code</returns>
      <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a expensive 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.Storage.ILRange,ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Alter values specified by range.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">ILRange specifying the dimensions/indices to be altered.</param>
      <param name="values">new values</param>
      <remarks>
            The values pointed to by range will be replaced with the values 
            found in 'values'. Important: the range cannot specify indices outside of my dimensions! 
            Therefore, the storage must have been expanded in advance, if needed!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Double},ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int64},ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int32},ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int16},ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Single},ILNumerics.Storage.ILDenseStorage{`0})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.ShiftDimensions(System.Int32)">
      <summary>
            Create referencing or solid array from this array, with shifted dimensions.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">Number of dimensions to shift the array.</param>
      <returns>Shifted ILDenseStorage of the same type.</returns>
      <remarks>
        <para>Shift is done 'to the left'.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Reshape(ILNumerics.ILSize)">
      <summary>
            reshape <b>this</b> storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="newDimensions">new dimensions of the storage.</param>
      <remarks>
        <para>This storage will be changed! The operation is cheap, since the 
            number of elements (and their values) do not change. The same countable array
            is used in conjunction with a new dimension specifier. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this storage.</exception>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Reshape(System.Int32[])">
      <summary>
            reshape <b>this</b> storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dims">new dimension length of the storage.</param>
      <remarks>
        <para>This storage will be changed! The operation is cheap, since the 
            number of elements (and their values) do not change. The same underlying storage 
            is used in conjunction with the new dimension specifier.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this storage.</exception>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Concat(ILNumerics.Storage.ILDenseStorage{`0},System.Int32)">
      <summary>
            concatenate this storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="A">n dimensional storage</param>
      <param name="dim">Index of dimension along which to concatenate the arrays.
            If dim is larger than the number of dimensions of one of the arrays
            its value will be used in modulus.</param>
      <returns>Array having the size of both input arrays laid beside one 
            another along the <paramref name="dim" />'s-dimension</returns>
      <remarks>The array returned will be a copy of both arrays involved. None 
            of the input arrays will be altered.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Repmat(System.Int32[])">
      <summary>
            Replicate this storage to create a larger array.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="sizes">Sizes description. This may be a 
            list or an array of integer values. If the number of elements in <paramref name="sizes" /> is 
            less the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimensions of this array, the result 
            will have its number of dimensions extended accordingly. </param>
      <returns>array which is made out of multiple copies of this array along 
            specified dimensions, according to <paramref name="sizes" />.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Remove(System.Int32,ILNumerics.Storage.ILRange)">
      <summary>
            Remove individual parts of a dimension from <b>this</b> storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimension">index of the dimension, where <c>indices</c> are to be removed</param>
      <param name="range">range of indices to be removed from <paramref name="dimension" /></param>
      <remarks>The mutating function directly operates on <b>this</b> storage! After the function returns, this storage may have its dimensions changed!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.OnSerialize(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Prepare for serialization.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="context">Streaming Context - provided by the formatter.</param>
      <remarks>nothing to do here<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Post operations aftre deserializing is finished.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="context">Streaming context provided by the formatter.</param>
      <remarks>nothing to do here<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValue(System.Int32[])">
      <summary>
            Get single value from this storage.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Integer array holding the dimension specifier</param>
      <returns>Element at the position pointed to by idx.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValueTyped(System.Int32[])">
      <summary>
            Get single value from this storage.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Integer array holding the dimension specifier</param>
      <returns>Element at the position pointed to by idx.</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValueSeq(System.Int32,System.Int32[]@)">
      <summary>
            Get single value from this storage by a single sequential access.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">Integer array holding the dimension specifier 
            pointing to the value.</param>
      <param name="dims">Out value: return position mapped to dimensions.</param>
      <returns>Object in the position pointed to by idx.</returns>
      <remarks>dims is the final position into the array for the sequential index specification <c>idx</c>.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetValue(System.Object,System.Int32[])">
      <summary>
            Set single value to element at the specified index.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">New value.</param>
      <param name="idx">Index of the element to be altered.</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetValueTyped(`0,System.Int32[])">
      <summary>
            Set value of element at the specified position.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">new value</param>
      <param name="idx">position of the element to be altered</param>
      <remarks>
        <para>This function does support automatic expansion of the array
            if indices lay outside the dimension limits of the array. However, because 
            of ambiguity reasons this is not reliable supported for vector sized arrays.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.getBaseIndex(System.Int32[])">
      <summary>
            [depricated] Convert index array into sequential index for storage access.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">int array with dimension specification.</param>
      <returns>Index of requested value inside the solid storage. This 
            value can directly be used to query the corresponding value via GetArrayForRead()[return_value].
            </returns>
      <remarks>
        <b>This function is deprecated! Use <see cref="M:ILNumerics.ILSize.IndexFromArray(System.Int32[])" /> instead!</b>
        <br />
            If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimension will be used. 
            If length of idx is larger than the dimensions of this storage, the behavior
            is undefined. Therefore this function should be enclosed in try, catch blocks 
            to handle this case!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.getBaseIndex(System.Boolean@,System.Int32[]@,System.Int32[])">
      <summary>
            [depricated] Convert index array into sequential index for storage access. Ommit any bound checking.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">int array with dimensions specification.</param>
      <param name="MustExpand">Output parameter. On return determine, if the index 
            specification points outside of the dimensions of this ILDenseStorage and the array 
            must be expanded before accessing elements on that position.</param>
      <param name="dimensions">if the array was found to be expanded, this are the 
            needed dimension sizes for the new array. The sizes are computed from the range 
            specification given.</param>
      <returns>Index of requested value inside the solid storage. This 
            value may directly be used to query the value via m_data[return_value].
            The value returned is valid for solid storages as well as for reference 
            storages.
            </returns>
      <remarks>
        <para>idx must be not null and must contain at least one element.</para>
        <para>If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimensions will be used. 
            If length of idx is larger than the dimensions of this storage, the index of 
            the expanded array will be returned.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExportValues(`0[]@)">
      <summary>
            Copy values of all elements into System.Array.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="result">System.Array, holding all element values of this ILDenseStorage.</param>
      <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'result' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetArrayForWrite">
      <summary>
            Get direct reference to inner System.Array storage for <b>write access</b>
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>reference to inner System.Array</returns>
      <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics! Keep in minds, the length 
            of the array may exceeds the number of elements.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;! (You have been warned!)</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetArrayForRead">
      <summary>
            Get direct reference to inner System.Array storage for <b>read access</b>
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>reference to inner System.Array for reading</returns>
      <remarks>This method is provided for experts only! Altering elements of this 
            array may cause the data to be invalidated or corrupted! Use this array only for reading! Note 
            the ILNumerics array storage format (column major). Keep in mind, the length 
            of the array may exceeds the number of elements! 
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T&gt;! (You have been warned!)</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Clone">
      <summary>
            Create lazy,shallow copy of this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>ILDenseStorage as copy of this storage.</returns>
      <remarks>The ILDenseStorage object returned will be of the same size and type than this object.
            <para>The copy is done lazy. This means, the new storage will at first share the memory 
            with that storage. This will take almost no memory / processor time. As soon as attempts 
            are made to <b>alter</b> the new storage, it will be detached from this storage and use own memeory.</para><para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetEnumerator">
      <summary>
            enumerator returning elements as ElementType
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExtractRemovalParameter(ILNumerics.ILBaseArray[],System.Int32@,ILNumerics.Data.ILIntList@,ILNumerics.ILSize@)">
      <summary>
            helper function to gather some parameters for partial dimension removal
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="rng">object with index specifications. May be of 
            type ILBaseArray[] with numeric arrays or a string array according 
            to the format of <see cref="T:ILNumerics.Storage.ILRange" />. 
            </param>
      <param name="dimensionIdx">Out parameter: index of dimension the indices to be removed lie in.</param>
      <param name="indices">Indices to be removed.</param>
      <param name="dimensions">Dimension structure, can be used to reshape the storage <b>before</b> the removal</param>
      <remarks>If range comprises a range dimension specification which is smaller than 
            the actual number of dimension of this storage, the storage must be reshaped in advance of the removal. 
            This reshaping proccess will <b>not</b> be done inside this function! However 
            the <c>dimension</c> value returned reflects the size of the storage before removing and therefore
            can be utilized for reshaping the storage.<para>[ILNumerics Core Module]</para></remarks>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If:<list type="bullet"><item>The length of range exceeds the dimensions of this storage.</item><item>More than one or less than one dimension of <c>range</c> was not null.</item><item>The type of range was invalid, or</item><item>Range is of type <see cref="T:ILNumerics.ILBaseArray" />, but the element type is not numeric</item></list></exception>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExpandArray(ILNumerics.Storage.ILLeftSideRange)">
      <summary>
            Expanded <b>this</b> storage for index addressing outside of my dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range">range specification with size for destination array</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExpandArray(System.Int32[])">
      <summary>
            Expand <b>this</b> storage for index addressing outside of my dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">sizes of dimensions for the new storage</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.copyUpperTriangle(System.Int32)">
      <summary>
            Copy upper triangular part of this array into new solid array.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="n">Length of first dimension of destination array.</param>
      <returns>Solid array of size [n x {ThisColumnCount})].</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.copyLowerTriangle">
      <summary>
            Copy lower triangular part of this array into new solid array.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>Solid array of same size than this array.</returns>
      <remarks>If this is not a 2D array, only the first dimension is referenced.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.#ctor(`0[],ILNumerics.ILSize)">
      <summary>
            create new dense storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="system_array">countable array</param>
      <param name="dimensions">dimensions</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Dispose(System.Boolean)">
      <summary>
            dispose this storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>Calling Dispose should be the last method called for an ILDenseStorage.</para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Detach">
      <summary>
            detach this storage: copy its countable array if necessary
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.Subarray(ILNumerics.ILBaseArray[])">
      <summary>
            Subarray from this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range"> arrays specifying the ranges to create subarray from</param>
      <returns>subarray as specified</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateRangedSubarray(ILNumerics.ILBaseArray{ILNumerics.Misc.ILRegularRange})">
      <summary>
            subarray from single dim, single range
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>subarray (column vector)</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Linq.Expressions.Expression})">
      <summary>
            create new subarray storage, sequentially addressed elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">sequential indices, arbitrary size</param>
      <returns>new storage, type of this storage, size and shape of indices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Double})">
      <summary>
            create new subarray storage, sequentially addressed elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">sequential indices, arbitrary size</param>
      <returns>new storage, type of this storage, size and shape of indices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Int64})">
      <summary>
            create new subarray storage, sequentially addressed elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">sequential indices, arbitrary size</param>
      <returns>new storage, type of this storage, size and shape of indices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Int32})">
      <summary>
            create new subarray storage, sequentially addressed elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">sequential indices, arbitrary size</param>
      <returns>new storage, type of this storage, size and shape of indices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Single})">
      <summary>
            create new subarray storage, sequentially addressed elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">sequential indices, arbitrary size</param>
      <returns>new storage, type of this storage, size and shape of indices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageFull">
      <summary>
            create column vector of all this array elements
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>new storage, type of this storage, size and shape of indices</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorage(ILNumerics.Storage.ILRange)">
      <summary>
            create subarray from ILDenseStorage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="range"></param>
      <returns></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateShiftedStorage(System.Int32)">
      <summary>
            create new storage, shift dimensions
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="shift">number of dimensions to shift</param>
      <returns>shifted storage </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILDenseStorage`1.ReferenceCount">
      <summary>
            number of storages referencing the current data array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILDenseStorage`1.IsDisposed">
      <summary>
            Determine, if this storage has already been disposed.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
      <summary>
            create new cell storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="system_array">countable array</param>
      <param name="dimensions">dimensions</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.SetValueTyped(ILNumerics.Storage.ILStorage,System.Int32[])">
      <summary>
            replace array at specified location
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="value">new scalar value for element</param>
      <param name="indices">indices of element to be altered, supports 'deep indexing'</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.GetValueTyped(System.Int32[])">
      <summary>
            get element from this cell storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">indices of element</param>
      <returns>element </returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.IsTypeOf``1(ILNumerics.ILBaseArray[])">
      <summary>
            test if an element of the cell is an array of the given element type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">the array element type to check the cell element against</typeparam>
      <param name="position">position of the cell element to be tested</param>
      <returns>true if the element found at the given position is an array of the element type <typeparamref name="T" />, false otherwise</returns>
      <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T" />. That means, in order to find out, if the first cell element stores an array of int (<c>ILArray&lt;int&gt;</c>), 
            one may use <c>cell.IsTypeOf&lt;int&gt;(0)</c></para><para>In order to test, if a cell element is of cell type, one can provide the type <c>ILCell</c> as type parameter: 
            <c>cell.IsTypeOf&lt;ILCell&gt;(0)</c>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <c>ILCell</c>. The reason of this is: the type of elements of <c>ILCell</c> is 
            an implementation detail and therefore hidden to the user.</para><para>[ILNumerics Core Module]</para></remarks>
      <example>
        <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
        <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short&gt;(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String&gt;      first element  &lt;Int16&gt; [2,3,4,5,6] 
                     &lt;Double&gt;          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string&gt;(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell&gt;(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short&gt;(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell&gt;(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double&gt;(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;&gt; never gives true
            </code></example>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.GetValue(System.Int32[])">
      <summary>
            gives clone of value addressed, supports deep index addressing
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices"></param>
      <returns></returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.GetValue``1(System.Int32[])">
      <summary>
            get single element from cell storage, predefined element type
            <para>[ILNumerics Core Module]</para>
      </summary>
      <typeparam name="T">predefined type</typeparam>
      <param name="indices">location of element to return</param>
      <returns>element</returns>
      <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the element found is not of the specified type</exception>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Double},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int64},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int32},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int16},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Single},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
      <summary>
            Alter elements of this storage adressed by sequential indices
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">array specifying the elements to be altered, sequential indexing</param>
      <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
      <remarks>
        <para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.Detach">
      <summary>
            detach this storage: copy its countable array if needed
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCellStorage.DeepReferenceElements">
      <summary>
            walk all elements of this cell and recursively replace them with clones of themself
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>Due to the cloning mechanism of ILNumerics, the full clone 
            will be cheap by using lazy copies of the data. Cloned elements will automatically be detached on write access.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(System.Int32)">
      <summary>
            create new countable array by size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="length"></param>
      <remarks>The memory for the newly created array is requested from memory pool. All elements of the array 
            are initialized with default(ElementType).<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(System.Int32,System.Boolean)">
      <summary>
            create new countable array by size
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="length">Length of the array.</param>
      <param name="clear">Clear the array or not.</param>
      <remarks>The memory for the newly created array is requested from memory pool. Depending on the value of 
            'clear', the elements of the array are NOT initialized and therefore may contain garbage data!.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(`0[],System.Int32)">
      <summary>
            create new countable array, provide system array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="data">system array to be used as storage array directly</param>
      <param name="length">minimum lenght of array needed</param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCountableArray`1.IncreaseReference">
      <summary>
            increase reference counter
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCountableArray`1.DecreaseReference">
      <summary>
            decrease reference counter
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCountableArray`1.Dispose">
      <summary>
            Dispose off this array: register it in pool
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILCountableArray`1.CreateCopy">
      <summary>
            return (solid) copy of this countable array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>newly created array</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILCountableArray`1.Data">
      <summary>
            Access to the internal system array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILCountableArray`1.Length">
      <summary>
            minimal length of the system array to be used for computations
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILCountableArray`1.ReferenceCount">
      <summary>
            number of storages referencing to this array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>In order to in-/decrease the reference counter, use 
            the <see cref="M:ILNumerics.Storage.ILCountableArray`1.IncreaseReference" />
            and <see cref="M:ILNumerics.Storage.ILCountableArray`1.DecreaseReference" /> functions.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="T:ILNumerics.Storage.ILRange">
      <summary>
            base class for ranges, used to define subarray ranges
            <para>[ILNumerics Core Module]</para>
      </summary>
      <description>ILRange is used to define those parts of indices of an array,
            which are to be extracted into a new subarray. 
            The class (and derived classes) parse indices given for each dimension and expand them into a 2-dimensional 
            integer array, needed for fast element traversal.
            <para>The class is internally used only and not intended to be used from outside ILNumerics.</para></description>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Storage.ILRange.m_range">
      <summary>
            hold ranges as 2 dimensional System.Array
            </summary>
    </member>
    <member name="M:ILNumerics.Storage.ILRange.Map(System.Int32[],System.Int32[]@)">
      <summary>
            Evaluates (maps) index array on my range.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="idx">int array indexing location inside this range</param>
      <param name="retIdx">(output) also return the result into array given</param>
      <returns>Mapped int[] array. It can be used for direct addressing the physical storage object.</returns>
      <remarks>retIdx must be at least of length m_nrDims. No check is made for this assumption!<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILRange.ParseDimension(System.String,System.Int32)">
      <summary>
            parse single dimension specifier from string
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="indices">valid index specification</param>
      <param name="dimlen">number of elements in dimension to be parsed</param>
      <returns>array with indices defined in 'indices'</returns>
      <remarks>the indices are parsed the way needed for sequential addressing. This means: 
            full dimensions address the whole array. Full dimensions are transformed into negative 
            placeholder indices nevertheless! SetRange must handle that accordingly.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILRange.RangeArray">
      <summary>
            for performance reasons: give reference to internal array
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32)">
      <summary>
            Index access for ILRange objects. Set/returns Index array for specified dimension.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>A reference to the internal object will be returned directly! (performance)<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32,System.Int32)">
      <summary>
            Index access for ILRange objects. returns the destIndex destination dimension for dimension specifyied by dimNr.
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>The access is readonly! No checks are made, if the requested indices exist.<para>[ILNumerics Core Module]</para></remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILRange.Size">
      <summary>
            Create trimmed size descriptor from indices in ILRange object
            <para>[ILNumerics Core Module]</para>
      </summary>
      <returns>new size descriptor with the neccessary size to define 
            an array as defined by all indices in this range</returns>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="F:ILNumerics.Storage.ILLeftSideRange.m_expandDimensions">
      <summary>
            sizes of dimensions to be expanded
            </summary>
    </member>
    <member name="F:ILNumerics.Storage.ILLeftSideRange.m_expanding">
      <summary>
            internal field, stores expanding flag
            </summary>
    </member>
    <member name="P:ILNumerics.Storage.ILLeftSideRange.Expanding">
      <summary>
            true for left side ranges, if at least one dimension must be expanded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILLeftSideRange.ExpandDimensions">
      <summary>
            array with sizes of dimensions to be expanded
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="P:ILNumerics.Storage.ILLogicalStorage.NumberNonZero">
      <summary>
            cached number of non-zero elements in this logical storage
            <para>[ILNumerics Core Module]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.Storage.ILRightSideRange.#ctor(ILNumerics.ILSize,System.Int32[])">
      <summary>
            rempat consctructor - for performance reasons
            <para>[ILNumerics Core Module]</para>
      </summary>
      <param name="dimension">source array dimensions</param>
      <param name="range">destination array repmattings </param>
      <remarks>
        <para>[ILNumerics Core Module]</para>
      </remarks>
    </member>
  </members>
</doc>